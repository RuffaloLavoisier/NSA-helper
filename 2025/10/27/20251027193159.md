# Commit: d897cfd861b8f46e3776cd833208a92bbf464312
## Message: Merge remote-tracking branch
'origin/GP-2370-dragonmacher-dtm-tree-remember-selection--SQUASHED'
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java
index 2a3b3ba9526..6d85fec672a 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java
@@ -318,7 +318,7 @@ protected void programActivated(Program program) {
 	protected void programClosed(Program program) {
 		// assumption: at this point programDeactivated(Program) has been called, so we don't
 		// have to perform any cleanup that is done by that method.
-		provider.programClosed();
+		provider.programClosed(program);
 		editorManager.dismissEditors(program.getDataTypeManager());
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java
index 3f5bb0c0644..39cb33228e6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java
@@ -18,8 +18,7 @@
 import java.awt.Component;
 import java.awt.Point;
 import java.awt.event.MouseEvent;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 
 import javax.swing.*;
 import javax.swing.event.*;
@@ -95,6 +94,11 @@ public class DataTypesProvider extends ComponentProviderAdapter {
 	private boolean filterOnNameOnly;
 	private DtFilterState filterState = new DtFilterState();
 
+	/**
+	 * Saves state of program nodes so the state can be restored as users tab between programs
+	 */
+	private Map<Long, TreePath> programTreeState = new HashMap<>();
+
 	public DataTypesProvider(DataTypeManagerPlugin plugin, String providerName) {
 		this(plugin, providerName, false);
 	}
@@ -361,6 +365,10 @@ private void buildComponent() {
 		splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
 
 		archiveGTree = new DataTypeArchiveGTree(plugin);
+
+		ArchiveRootNode rootNode = (ArchiveRootNode) archiveGTree.getModelRoot();
+		rootNode.setNodeListener(new ProgramNodeUpdateListener());
+
 		archiveGTree.addMouseListener(new GMouseListenerAdapter() {
 
 			private GTreeNode lastClickedNode;
@@ -673,11 +681,10 @@ void domainObjectRestored(DataTypeManagerDomainObject domainObject) {
 		}
 		if (domainObject instanceof Program) {
 			Program program = (Program) domainObject;
-			Program programInTree = plugin.getProgram(); // May be null.
+			Program programInTree = plugin.getProgram(); // may be null
 			if (program == programInTree) {
 				DataTypeArchiveGTree gTree = getGTree();
 				ArchiveNode node = getProgramArchiveNode();
-				// don't know how this can be null, but a mysterious stack trace showed it.
 				if (node != null) {
 					GTreeState state = gTree.getTreeState(node);
 					node.structureChanged();
@@ -697,14 +704,12 @@ else if (domainObject instanceof DataTypeArchive) {
 		}
 	}
 
-	private ArchiveNode getProgramArchiveNode() {
+	private ProgramArchiveNode getProgramArchiveNode() {
 		GTreeNode rootNode = getGTree().getModelRoot();
 		List<GTreeNode> children = rootNode.getChildren();
 		for (GTreeNode node : children) {
-			ArchiveNode archiveNode = (ArchiveNode) node;
-			Archive archive = archiveNode.getArchive();
-			if (archive instanceof ProgramArchive) {
-				return archiveNode;
+			if (node instanceof ProgramArchiveNode programNode) {
+				return programNode;
 			}
 		}
 		return null;
@@ -900,8 +905,64 @@ String getPreviewText() {
 		return previewPane.getText();
 	}
 
-	void programClosed() {
+	private void restoreProgramTreeState(ProgramArchiveNode programNode) {
+		ProgramArchive programArchive = (ProgramArchive) programNode.getArchive();
+		Program program = programArchive.getProgram();
+		long id = program.getUniqueProgramID();
+		TreePath selectedPath = programTreeState.get(id);
+		if (selectedPath == null) {
+			return;
+		}
+
+		TreePath[] selectionPaths = archiveGTree.getSelectionPaths();
+		List<TreePath> list = new ArrayList<>(Arrays.asList(selectionPaths));
+		list.add(selectedPath);
+		archiveGTree.setSelectionPaths(list);
+	}
+
+	private void saveProgramTreeState(ProgramArchiveNode programNode) {
+		//
+		// Save the program's selected path as a convenience to the user when we are about to switch
+		// to a new program.  The act of switching will replace the program node, throwing away all
+		// expansion and selection info.   It does not seem useful to save too many selected paths
+		// of the program node, so only save the path if there is a single selection.  This will 
+		// be helpful in the case that the user was working with a single data type in the program.
+		//
+		ProgramArchive programArchive = (ProgramArchive) programNode.getArchive();
+		Program program = programArchive.getProgram();
+		long id = program.getUniqueProgramID();
+		GTreeState state = archiveGTree.getTreeState();
+		List<TreePath> paths = state.getSelectedPaths();
+		programTreeState.remove(id);
+
+		TreePath treePath = getSingleProgramSelection(programNode, paths);
+		if (treePath != null) {
+			programTreeState.put(id, treePath);
+		}
+	}
+
+	private TreePath getSingleProgramSelection(ProgramArchiveNode programNode,
+			List<TreePath> paths) {
+
+		if (paths.size() != 1) {
+			return null;
+		}
+
+		TreePath treePath = paths.get(0);
+		Object[] path = treePath.getPath();
+		if (path.length > 2) {  // the program node is the second element in a selection path
+			if (path[1] == programNode) {
+				return treePath;
+			}
+		}
+		return null;
+	}
+
+	void programClosed(Program program) {
 		archiveGTree.cancelWork();
+
+		long id = program.getUniqueProgramID();
+		programTreeState.remove(id);
 	}
 
 	void archiveClosed(DataTypeManager dtm) {
@@ -997,4 +1058,24 @@ private void dataTypeSelected(EventOrigin eventOrigin, DataType dt) {
 		contextChanged();
 	}
 
+//=================================================================================================
+// Inner Classes
+//=================================================================================================
+
+	private class ProgramNodeUpdateListener implements ArchiveRootNodeListener {
+
+		@Override
+		public void archiveNodeAdded(ArchiveNode node) {
+			if (node instanceof ProgramArchiveNode programNode) {
+				restoreProgramTreeState(programNode);
+			}
+		}
+
+		@Override
+		public void archiveNodeRemoved(ArchiveNode node) {
+			if (node instanceof ProgramArchiveNode programNode) {
+				saveProgramTreeState(programNode);
+			}
+		}
+	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java
index ede28c2b213..8b1e8d777a1 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java
@@ -31,10 +31,11 @@ public class ArchiveRootNode extends DataTypeTreeNode {
 
 	private DataTypeManagerHandler archiveManager;
 	private RootNodeListener archiveListener;
+	private boolean programDtmOnly;
 
-	private DtFilterState dtFilterState = new DtFilterState();
+	private ArchiveRootNodeListener listener;
 
-	private boolean programDtmOnly;
+	private DtFilterState dtFilterState = new DtFilterState();
 
 	public ArchiveRootNode(DataTypeManagerHandler archiveManager) {
 		this(archiveManager, false);
@@ -51,6 +52,14 @@ private void init() {
 		archiveManager.addArchiveManagerListener(archiveListener);
 	}
 
+	/**
+	 * Add a listener to know when the program archive node is added and removed.
+	 * @param listener the listener
+	 */
+	public void setNodeListener(ArchiveRootNodeListener listener) {
+		this.listener = listener;
+	}
+
 	public DataTypeManagerHandler getArchiveHandler() {
 		return archiveManager;
 	}
@@ -100,7 +109,7 @@ public boolean isModifiable() {
 	}
 
 	// a factory method to isolate non-OO inheritance checks
-	private final GTreeNode createArchiveNode(Archive archive, DtFilterState filterState) {
+	private final ArchiveNode createArchiveNode(Archive archive, DtFilterState filterState) {
 
 		if (programDtmOnly) {
 			if (archive instanceof ProgramArchive) {
@@ -219,17 +228,19 @@ private ArchiveNode getArchiveNode(Archive archive) {
 // Inner Classes
 //==================================================================================================
 
-	class RootNodeListener implements ArchiveManagerListener {
+	private class RootNodeListener implements ArchiveManagerListener {
 
 		@Override
 		public void archiveClosed(Archive archive) {
 			if (!isLoaded()) {
 				return;
 			}
+
 			List<GTreeNode> allChildrenList = getChildren();
 			for (GTreeNode node : allChildrenList) {
 				ArchiveNode archiveNode = (ArchiveNode) node;
 				if (archive == archiveNode.getArchive()) {
+					listener.archiveNodeRemoved(archiveNode);
 					removeNode(archiveNode);
 					archiveNode.dispose();
 					return;
@@ -243,7 +254,7 @@ public void archiveOpened(Archive archive) {
 				return;
 			}
 
-			GTreeNode node = createArchiveNode(archive, dtFilterState);
+			ArchiveNode node = createArchiveNode(archive, dtFilterState);
 			if (node == null) {
 				return;
 			}
@@ -254,6 +265,8 @@ public void archiveOpened(Archive archive) {
 				index = -index - 1;
 			}
 			addNode(index, node);
+
+			listener.archiveNodeAdded(node);
 		}
 
 		@Override
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNodeListener.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNodeListener.java
new file mode 100644
index 00000000000..c0f94486410
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNodeListener.java
@@ -0,0 +1,34 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.core.datamgr.tree;
+
+/**
+ * An interface to listen to the program archive node being added and removed.
+ */
+public interface ArchiveRootNodeListener {
+
+	/**
+	 * Called when a node has been added to the root node
+	 * @param node the added node
+	 */
+	public void archiveNodeAdded(ArchiveNode node);
+
+	/**
+	 * Called when a node is about to be removed from the root node
+	 * @param node the node that is about to be removed
+	 */
+	public void archiveNodeRemoved(ArchiveNode node);
+}
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPluginTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPluginTest.java
index a9972ba0eef..ceae705122b 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPluginTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPluginTest.java
@@ -28,6 +28,7 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
 
 import javax.swing.*;
 import javax.swing.tree.DefaultTreeCellEditor;
@@ -51,6 +52,7 @@
 import ghidra.app.plugin.core.datamgr.archive.DataTypeManagerHandler;
 import ghidra.app.plugin.core.datamgr.tree.*;
 import ghidra.app.plugin.core.function.AbstractEditFunctionSignatureDialog;
+import ghidra.app.plugin.core.progmgr.ProgramManagerPlugin;
 import ghidra.app.plugin.core.programtree.ProgramTreePlugin;
 import ghidra.app.services.DataTypeManagerService;
 import ghidra.app.services.ProgramManager;
@@ -61,8 +63,8 @@
 import ghidra.program.database.ProgramDB;
 import ghidra.program.database.data.ProgramDataTypeManager;
 import ghidra.program.model.data.*;
-import ghidra.test.AbstractGhidraHeadedIntegrationTest;
-import ghidra.test.TestEnv;
+import ghidra.program.model.listing.Program;
+import ghidra.test.*;
 import util.CollectionUtils;
 import utilities.util.FileUtilities;
 
@@ -73,7 +75,6 @@
 
 public class DataTypeManagerPluginTest extends AbstractGhidraHeadedIntegrationTest {
 	private static final String BUILTIN_NAME = "BuiltInTypes";
-	private static final String PROGRAM_FILENAME = "sample";
 
 	private TestEnv env;
 	private PluginTool tool;
@@ -104,7 +105,7 @@ public void setUp() throws Exception {
 		jTree = (JTree) invokeInstanceMethod("getJTree", tree);
 		waitForTree();
 		ArchiveRootNode archiveRootNode = (ArchiveRootNode) tree.getModelRoot();
-		programNode = (ArchiveNode) archiveRootNode.getChild(PROGRAM_FILENAME);
+		programNode = (ArchiveNode) archiveRootNode.getChild(program.getName());
 		assertNotNull("Did not successfully wait for the program node to load", programNode);
 
 		tool.showComponentProvider(provider, true);
@@ -125,7 +126,7 @@ private void removeDistractingPlugins() {
 	}
 
 	private ProgramDB buildProgram() throws Exception {
-		builder = new ProgramBuilder("sample", ProgramBuilder._TOY, this);
+		builder = new ProgramBuilder("Program1", ProgramBuilder._TOY, this);
 
 		builder.createMemory(".text", "0x1001000", 0x100);
 		CategoryPath miscPath = new CategoryPath("/MISC");
@@ -668,7 +669,7 @@ public void testDetailedSearch() throws Exception {
 
 		toggleDetailedSearch(true);
 		assertSingleFilterMatch(
-			new String[] { "Data Types", "sample", "Category1", "Category2", "MyStruct" });
+			new String[] { "Data Types", "Program1", "Category1", "Category2", "MyStruct" });
 	}
 
 	@Test
@@ -684,6 +685,84 @@ public void testCollapseAll() throws Exception {
 		checkNodesCollapsed(rootNode);
 	}
 
+	@Test
+	public void testTreeRemembersSelectionWhenSwitchingPrograms() throws Exception {
+
+		env.open(new ClassicSampleX86ProgramBuilder().getProgram());
+
+		String p1 = "Program1";
+		String p2 = "sample";
+
+		// Open and select a path in the current program, 
+		selectPath(p2, "CoolUnion");
+
+		// Now select a path in the first program
+		switchTo(p1);
+		selectPath(p1, "MISC", "ArrayStruct");
+
+		// Switch back and forth and the selected paths should be restored
+		switchTo(p2);
+		assertSelectedPath(p2, "CoolUnion");
+
+		switchTo(p1);
+		assertSelectedPath(p1, "MISC", "ArrayStruct");
+
+		switchTo(p2);
+		assertSelectedPath(p2, "CoolUnion");
+	}
+
+	private void assertSelectedPath(String... expectedPath) {
+
+		String[] fullExpectedPath = new String[expectedPath.length + 1];
+		fullExpectedPath[0] = "Data Types";
+		System.arraycopy(expectedPath, 0, fullExpectedPath, 1, expectedPath.length);
+
+		waitForTree();
+		TreePath treePath = runSwing(() -> tree.getSelectionPath());
+		assertNotNull("No tree path selected", treePath);
+		Object[] treePathElements = treePath.getPath();
+		List<String> actualNamesList =
+			Arrays.stream(treePathElements)
+					.map(o -> o.toString())
+					.collect(Collectors.toList());
+		String[] actualPath = actualNamesList.toArray(String[]::new);
+		assertArraysEqualOrdered("Tree path not seleced", fullExpectedPath, actualPath);
+	}
+
+	private void switchTo(String programName) {
+
+		ProgramManagerPlugin pm = getPlugin(tool, ProgramManagerPlugin.class);
+		Program[] programs = pm.getAllOpenPrograms();
+		for (Program p : programs) {
+			String name = p.getName();
+			if (name.equals(programName)) {
+				pm.setCurrentProgram(p);
+				waitForBusyTool(tool);
+				return;
+			}
+		}
+		fail("Could not switch to program '%s'".formatted(programName));
+	}
+
+	private void selectPath(String... names) {
+
+		GTreeNode root = tree.getModelRoot();
+		GTreeNode node = root;
+		for (String name : names) {
+			GTreeNode child = node.getChild(name);
+			String message = "Could not find '%s' in '%s'".formatted(name, Arrays.toString(names));
+			assertNotNull(message, child);
+
+			tree.expandPath(node);
+			waitForTree();
+
+			node = child;
+		}
+
+		tree.setSelectedNode(node);
+		waitForTree();
+	}
+
 	@Test
 	public void testDataTypePreviewCopyHtmlText() throws Exception {
 
@@ -1323,7 +1402,7 @@ private void assertSingleFilterMatch(String[] path) {
 		GTreeNode node = rootNode;
 		for (int i = 0; i < path.length; i++) {
 			String nodeName = path[i];
-			assertEquals(node.getName(), nodeName);
+			assertEquals(nodeName, node.getName());
 
 			final GTreeNode finalNode = node;
 			final GTreeNode[] childBox = new GTreeNode[1];
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java
index 8e21f052053..be7fe094795 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java
@@ -520,6 +520,10 @@ public void expandAndSelectPaths(List<TreePath> paths) {
 		setSelectionPaths(paths, true, EventOrigin.API_GENERATED);
 	}
 
+	public void addSelectionPath(TreePath path) {
+		tree.addSelectionPath(path);
+	}
+
 	public void setSelectedNode(GTreeNode node) {
 		setSelectionPaths(new TreePath[] { node.getTreePath() });
 	}
@@ -1091,10 +1095,6 @@ public void setRowHeight(int rowHeight) {
 		tree.setRowHeight(rowHeight);
 	}
 
-	public void addSelectionPath(TreePath path) {
-		tree.addSelectionPath(path);
-	}
-
 	public void addTreeExpansionListener(TreeExpansionListener listener) {
 		tree.addTreeExpansionListener(listener);
 	}
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeFilterTask.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeFilterTask.java
index a4811498188..17a1db85a22 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeFilterTask.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeFilterTask.java
@@ -85,6 +85,10 @@ private void expandInSameTask(TaskMonitor monitor, GTreeNode filtered) {
 	private void restoreInSameTask(TaskMonitor monitor) {
 
 		GTreeState state = tree.getFilterRestoreState();
+		if (state == null) {
+			return; // can happen in testing
+		}
+
 		if (isOnlyRootSelected(state)) {
 			// This is a special case that allows the user to signal to not restore the tree state
 			// when the filter is cleared.   The tree will normally restore the state to either 1)
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeState.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeState.java
index 6bb1ac423e8..61e9c0446db 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeState.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeState.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -175,7 +175,7 @@ private List<TreePath> getSelectionPaths(GTreeNode node) {
 		List<TreePath> pathList = new ArrayList<>();
 		for (TreePath path : allSelectionPaths) {
 			if (nodeTreePath.isDescendant(path)) {
-				pathList.add(nodeTreePath);
+				pathList.add(path);
 			}
 		}
 		return pathList;
```
-----------------------------------
