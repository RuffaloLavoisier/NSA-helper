# Commit: f4fb210c55c651962f0862de90ca601acfb477b5
## Message: Merge remote-tracking branch 'origin/Ghidra_12.0'
## Diff:
```
diff --git a/GPL/vsconfig.gradle b/GPL/vsconfig.gradle
index 5e0d35c4aea..8a44282c495 100644
--- a/GPL/vsconfig.gradle
+++ b/GPL/vsconfig.gradle
@@ -98,17 +98,29 @@ if (!hasProperty("VISUAL_STUDIO_INSTALL_DIR") && isCurrentWindows()) {
 
 def sortVisualStudioVersions(vswhereJson) {
 
-	// Try to parse each version using Java's own version parser, marking the entries that failed
+	// Try to parse each version using Gradle's own version parser, marking the entries that failed
 	// (none should fail)
+	def validVersions = true
 	vswhereJson.each {
 		try {
-			Runtime.Version.parse(it.installationVersion)
+			GradleVersion.version(it.installationVersion)
 		}
 		catch (Exception e) {
 			it.put("unsupportedVersion", "true")
+			validVersions = false
 		}
 	}
 	
-	vswhereJson.sort { a, b -> b.instanceId <=> a.instanceId } // secondary sort
-	vswhereJson.sort { a, b -> Runtime.Version.parse(b.installationVersion) <=> Runtime.Version.parse(a.installationVersion) } // primary sort
+	// Establish a consistent ordering by first sorting by instance ID
+	vswhereJson.sort { a, b -> b.instanceId <=> a.instanceId }
+	
+	// Primary sort by installation version. If all the version numbers were parseable with the
+	// GradleVersion class, use that class to achieve the correct ordering. Otherwise, fall back to
+	// lexicographic order.
+	if (validVersions) {
+		vswhereJson.sort { a, b -> GradleVersion.version(b.installationVersion) <=> GradleVersion.version(a.installationVersion) } // primary sort
+	}
+	else {
+		vswhereJson.sort { a, b -> b.installationVersion <=> a.installationVersion } // primary sort
+	}
 }
diff --git a/Ghidra/Framework/Generic/src/main/java/generic/timer/ExpiringSwingTimer.java b/Ghidra/Framework/Generic/src/main/java/generic/timer/ExpiringSwingTimer.java
index a55f1496a5d..4d7768468c0 100644
--- a/Ghidra/Framework/Generic/src/main/java/generic/timer/ExpiringSwingTimer.java
+++ b/Ghidra/Framework/Generic/src/main/java/generic/timer/ExpiringSwingTimer.java
@@ -32,7 +32,7 @@
  */
 public class ExpiringSwingTimer extends GhidraSwingTimer {
 
-	private static int DEFAULT_EXPIRE_MS = 750;
+	private static final int DEFAULT_EXPIRE_MS = 750;
 
 	private static Set<ExpiringSwingTimer> instances = new HashSet<>();
 
diff --git a/GhidraBuild/BuildFiles/Doclets/src/main/java/ghidra/doclets/typestubs/JavadocConverter.java b/GhidraBuild/BuildFiles/Doclets/src/main/java/ghidra/doclets/typestubs/JavadocConverter.java
index 1bb859ca702..0c51f240858 100644
--- a/GhidraBuild/BuildFiles/Doclets/src/main/java/ghidra/doclets/typestubs/JavadocConverter.java
+++ b/GhidraBuild/BuildFiles/Doclets/src/main/java/ghidra/doclets/typestubs/JavadocConverter.java
@@ -15,25 +15,12 @@
  */
 package ghidra.doclets.typestubs;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.QualifiedNameable;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
+import javax.lang.model.element.*;
+import javax.lang.model.type.*;
 
 import com.sun.source.doctree.*;
 
@@ -218,9 +205,7 @@ String convertTag(Element el, DocTree tag, ListIterator<? extends DocTree> it) {
 				if (tag instanceof HtmlDocTree html) {
 					yield htmlConverter.convertHtml(html, el, it);
 				}
-				else {
-					yield tag.toString();
-				}
+				yield tag.toString();
 			}
 			case SPEC -> "";
 			case SERIAL -> "";
@@ -352,6 +337,9 @@ private String convertLinkTag(Element el, LinkTree link) {
 	 */
 	private static String getConstantValue(VariableElement el, ValueTree tag) {
 		Object value = el.getConstantValue();
+		if (value == null) {
+			return "";
+		}
 		TextTree format = tag.getFormat();
 		if (format != null) {
 			try {
```
-----------------------------------
