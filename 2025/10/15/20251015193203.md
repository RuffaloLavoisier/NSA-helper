# Commit: 15149e6b336cfe572bb79ddffebf9948a15dcc5b
## Message: Merge remote-tracking branch 'origin/Ghidra_12.0'
## Diff:
```
diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java
index 555dfec4b0c..f24230306d1 100644
--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java
+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java
@@ -111,7 +111,7 @@ public RTTIGccClassRecoverer(Program program, ServiceProvider serviceProvider,
 			TaskMonitor monitor) throws Exception {
 
 		super(program, serviceProvider, api, createBookmarks, useShortTemplates, nameVfunctions,
-			makeVfunctionsThisCalls,isDwarfLoaded, monitor);
+			makeVfunctionsThisCalls, isDwarfLoaded, monitor);
 
 		this.isDwarfLoaded = isDwarfLoaded;
 
@@ -213,6 +213,8 @@ public List<RecoveredClass> createRecoveredClasses() throws CancelledException,
 		Msg.debug(this, "Processing constructors and destructors");
 		processConstructorAndDestructors();
 
+		identifyPureVirtualFunction(recoveredClasses);
+
 		Msg.debug(this, "Creating vftable order maps");
 		createVftableOrderMap(recoveredClasses);
 
diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
index 1231e4039ba..1d32ee1009e 100644
--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
@@ -4505,7 +4505,7 @@ else if (vfunctionClass.getShortenedTemplateName() != null &&
 
 				// if the function is a purecall need to create the function definition using
 				// the equivalent child virtual function signature
-				if (nameField.contains("purecall")) {
+				if (nameField.contains("purecall") || nameField.contains("pure_virtual")) {
 
 					nameField = DEFAULT_VFUNCTION_PREFIX + vfunctionNumber;
 
@@ -4583,15 +4583,11 @@ protected void fixupPurecallFunctionDefs() throws CancelledException {
 		List<Address> processedVftables = new ArrayList<Address>();
 
 		// get references to purecall function to figure out which classes to process
-		ReferenceIterator purecallRefs =
-			program.getReferenceManager().getReferencesTo(purecall.getEntryPoint());
+		HashSet<Address> purecallRefs = getPurecallRefs();
 
-		while (purecallRefs.hasNext()) {
+		for (Address fromAddress : purecallRefs) {
 			monitor.checkCancelled();
 
-			Reference purecallRef = purecallRefs.next();
-			Address fromAddress = purecallRef.getFromAddress();
-
 			// get data containing the purecall reference to get the vftable structure
 			Data data = program.getListing().getDataContaining(fromAddress);
 
@@ -4662,6 +4658,33 @@ protected void fixupPurecallFunctionDefs() throws CancelledException {
 
 	}
 
+	// get references to purecall function to figure out which classes to process
+	HashSet<Address> getPurecallRefs() throws CancelledException {
+
+		HashSet<Address> purecalls = new HashSet<>();
+		ReferenceIterator purecallRefs =
+			program.getReferenceManager().getReferencesTo(purecall.getEntryPoint());
+
+		while (purecallRefs.hasNext()) {
+			monitor.checkCancelled();
+			purecalls.add(purecallRefs.next().getFromAddress());
+		}
+
+		Address[] functionThunkAddresses = purecall.getFunctionThunkAddresses(true);
+		if (functionThunkAddresses != null) {
+			for (Address purecallThunk : functionThunkAddresses) {
+				monitor.checkCancelled();
+				purecallRefs =
+					program.getReferenceManager().getReferencesTo(purecallThunk);
+				while (purecallRefs.hasNext()) {
+					monitor.checkCancelled();
+					purecalls.add(purecallRefs.next().getFromAddress());
+				}
+			}
+		}
+		return purecalls;
+	}
+
 	/**
 	 * Method to get a child class virtual function at the given offset into the correct virtual function table
 	 * @param recoveredClass the given class
```
-----------------------------------
