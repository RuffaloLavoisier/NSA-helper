# Commit: 404191cdaad213cd55feded6509a300ca33dc756
## Message: GP-5654 - Data Type Manager - Speed improvements for deleting data types
## Diff:
```
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/data/DBTraceDataTypeManagerTest.java b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/data/DBTraceDataTypeManagerTest.java
index 9a4ad26aa6d..fae5d7d1a87 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/data/DBTraceDataTypeManagerTest.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/data/DBTraceDataTypeManagerTest.java
@@ -132,7 +132,7 @@ public void testAddRemoveUndoThenGet() throws IOException {
 		assertEquals(mine.toString(), got.toString()); // TODO: Eww
 
 		try (Transaction tx = trace.openTransaction("To Undo")) {
-			dtm.remove(got, new ConsoleTaskMonitor());
+			dtm.remove(got);
 		}
 
 		assertNull(got = dtm.getDataType(minePath));
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/merge/datatypes/DataTypeMergeManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/merge/datatypes/DataTypeMergeManager.java
index 32bf15ef7cc..360ce0ee97f 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/merge/datatypes/DataTypeMergeManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/merge/datatypes/DataTypeMergeManager.java
@@ -688,7 +688,7 @@ private void setSourceDataType(long myID) {
 				// remove the Latest that was added.
 				DataType latestDt3 = dtms[RESULT].getDataType(sourceArchive, dataTypeID);
 				long resultId3 = dtms[RESULT].getID(latestDt3);
-				if (dtms[RESULT].remove(latestDt3, currentMonitor)) {
+				if (dtms[RESULT].remove(latestDt3)) {
 					latestResolvedDts.put(resultId3, null);
 				}
 				break;
@@ -807,7 +807,7 @@ private void dataTypeDeleted(long id) {
 						// remove the data type if it was already added
 						DataType dt = myResolvedDts.get(id);
 						if (dt != null) {
-							dtms[RESULT].remove(dt, currentMonitor);
+							dtms[RESULT].remove(dt);
 							origResolvedDts.remove(id);
 							myResolvedDts.remove(id);
 						}
@@ -818,7 +818,7 @@ private void dataTypeDeleted(long id) {
 			case OPTION_MY:
 				if (myDt == null) {
 					if (latestDt != null) {
-						dtms[RESULT].remove(latestDt, currentMonitor);
+						dtms[RESULT].remove(latestDt);
 					}
 				}
 				else {
@@ -3003,7 +3003,7 @@ private void processDataTypeDeleted(long myDtID) {
 			// My deleted data types will be in the result unless the latest already deleted it.
 			if (myDt != null) {
 				// If it's still in the result remove it.
-				dtms[RESULT].remove(myDt, currentMonitor);
+				dtms[RESULT].remove(myDt);
 			}
 		}
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java
index 3aca92c6cf3..41afffd6014 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java
@@ -88,13 +88,13 @@ protected ClearCmd(AddressSetView view, ClearOptions options, boolean sendIndivi
 	public boolean applyTo(Program p, TaskMonitor taskMonitor) {
 		this.monitor = taskMonitor;
 		this.program = p;
-		boolean wasEabled = program.isSendingEvents();
+		boolean wasEnabled = program.isSendingEvents();
 		try {
 			program.setEventsEnabled(sendIndividualEvents);
 			return doApplyTo();
 		}
 		finally {
-			program.setEventsEnabled(wasEabled);
+			program.setEventsEnabled(wasEnabled);
 			program = null;
 			monitor = null;
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
index 8e783107602..a78576d1307 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
@@ -1329,7 +1329,7 @@ public void dataTypeRemoved(DataTypeManager dtm, DataTypePath path) {
 			}
 			viewDTM.withTransaction("Removed Dependency", () -> {
 				viewDTM.clearUndoOnChange();
-				viewDTM.remove(dataType, TaskMonitor.DUMMY);
+				viewDTM.remove(dataType);
 			});
 			fireTableDataChanged();
 			componentDataChanged();
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeViewerDataTypeManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeViewerDataTypeManager.java
index b469cf8ff9d..1d8b8d1a627 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeViewerDataTypeManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeViewerDataTypeManager.java
@@ -265,7 +265,7 @@ public DataType replaceDataType(DataType existingViewDt, DataType replacementDt,
 	}
 
 	@Override
-	public boolean remove(DataType existingViewDt, TaskMonitor monitor) {
+	public boolean remove(DataType existingViewDt) {
 
 		if (existingViewDt.getDataTypeManager() != this) {
 			throw new IllegalArgumentException("datatype is not from this manager");
@@ -275,7 +275,7 @@ public boolean remove(DataType existingViewDt, TaskMonitor monitor) {
 			dataTypeIDMap.remove(getID(existingViewDt));
 		}
 
-		return super.remove(existingViewDt, monitor);
+		return super.remove(existingViewDt);
 	}
 
 	/**
@@ -311,7 +311,7 @@ public boolean refreshDBTypesFromOriginal() {
 					DataType originalDt = originalDTM.getDataType(originalId);
 					if (originalDt == null) {
 						changed = true;
-						remove(dt, TaskMonitor.DUMMY);
+						remove(dt);
 						continue;
 					}
 
@@ -406,7 +406,7 @@ private void checkOrphansForRemoval(boolean cleanupIdMaps) {
 					orphanIds.addAll(getChildIds(id));
 
 					// Remove orphan DB datatype
-					remove(dt, TaskMonitor.DUMMY);
+					remove(dt);
 
 					if (cleanupIdMaps) {
 						dataTypeIDMap.remove(id);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveNode.java
index 2ad9e21eda3..7858666e85e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveNode.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveNode.java
@@ -309,6 +309,10 @@ private class ArchiveNodeCategoryChangeListener implements DataTypeManagerChange
 
 		@Override
 		public void categoryAdded(DataTypeManager dtm, CategoryPath path) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category newCategory = dtm.getCategory(path);
 			if (newCategory == null) {
 				return;
@@ -326,6 +330,10 @@ void dispose() {
 
 		@Override
 		public void categoryMoved(DataTypeManager dtm, CategoryPath oldPath, CategoryPath newPath) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category newCategory = dtm.getCategory(newPath);
 			Category oldParent = dtm.getCategory(oldPath.getParent());
 			CategoryNode categoryNode = findCategoryNode(oldParent);
@@ -340,6 +348,10 @@ public void categoryMoved(DataTypeManager dtm, CategoryPath oldPath, CategoryPat
 
 		@Override
 		public void categoryRemoved(DataTypeManager dtm, CategoryPath path) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category parentCategory = dtm.getCategory(path.getParent());
 			CategoryNode categoryNode = findCategoryNode(parentCategory);
 			if (categoryNode != null) {
@@ -350,6 +362,10 @@ public void categoryRemoved(DataTypeManager dtm, CategoryPath path) {
 		@Override
 		public void categoryRenamed(DataTypeManager dtm, CategoryPath oldPath,
 				CategoryPath newPath) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			if (oldPath.getParent() == null) { // root has no parent
 				ArchiveNode.this.fireNodeChanged(); // fire that the root changed
 				return;
@@ -365,6 +381,10 @@ public void categoryRenamed(DataTypeManager dtm, CategoryPath oldPath,
 
 		@Override
 		public void dataTypeAdded(DataTypeManager dtm, DataTypePath path) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category parentCategory = dtm.getCategory(path.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(parentCategory);
 			if (categoryNode != null) {
@@ -379,6 +399,10 @@ public void dataTypeAdded(DataTypeManager dtm, DataTypePath path) {
 
 		@Override
 		public void favoritesChanged(DataTypeManager dtm, DataTypePath path, boolean isFavorite) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			DataType dataType = dtm.getDataType(path);
 			Category category = dtm.getCategory(path.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(category);
@@ -399,6 +423,10 @@ public void favoritesChanged(DataTypeManager dtm, DataTypePath path, boolean isF
 
 		@Override
 		public void dataTypeChanged(DataTypeManager dtm, DataTypePath path) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category dtmCategory = dtm.getCategory(path.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(dtmCategory);
 			if (categoryNode != null) {
@@ -413,6 +441,10 @@ public void dataTypeChanged(DataTypeManager dtm, DataTypePath path) {
 
 		@Override
 		public void dataTypeMoved(DataTypeManager dtm, DataTypePath oldPath, DataTypePath newPath) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category oldParent = dtm.getCategory(oldPath.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(oldParent);
 			if (categoryNode != null) {
@@ -433,6 +465,10 @@ public void dataTypeMoved(DataTypeManager dtm, DataTypePath oldPath, DataTypePat
 
 		@Override
 		public void dataTypeRemoved(DataTypeManager dtm, DataTypePath path) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category oldParent = dtm.getCategory(path.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(oldParent);
 			if (categoryNode != null) {
@@ -443,6 +479,10 @@ public void dataTypeRemoved(DataTypeManager dtm, DataTypePath path) {
 		@Override
 		public void dataTypeRenamed(DataTypeManager dtm, DataTypePath oldPath,
 				DataTypePath newPath) {
+			if (!isLoaded()) {
+				return;
+			}
+
 			Category dtmCategory = dtm.getCategory(newPath.getCategoryPath());
 			CategoryNode categoryNode = findCategoryNode(dtmCategory);
 			if (categoryNode != null) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/CategoryNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/CategoryNode.java
index 6b143335923..9420af33dab 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/CategoryNode.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/CategoryNode.java
@@ -51,6 +51,7 @@ protected List<GTreeNode> generateChildren() {
 		if (category == null) {
 			return Collections.emptyList();
 		}
+
 		Category[] subCategories = category.getCategories();
 		DataType[] dataTypes = category.getDataTypes();
 		List<GTreeNode> list = new ArrayList<>(subCategories.length + dataTypes.length);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
index f0aaef5073a..19d0b2f419e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -156,6 +156,10 @@ private void reportErrors() {
 		int n = errors.size();
 		if (n > 1) {
 			message = "Encountered " + n + " errors copying/moving.  See the log for details";
+
+			for (int i = 0; i < 10; i++) {
+				Msg.error(this, errors.get(i));
+			}
 		}
 
 		Msg.showError(this, gTree, "Encountered Errors Copying/Moving", message);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeDeleteTask.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeDeleteTask.java
index ad661282596..f9441689ad6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeDeleteTask.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeDeleteTask.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,6 +25,8 @@
 import ghidra.app.plugin.core.datamgr.archive.Archive;
 import ghidra.app.plugin.core.datamgr.tree.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.util.Swing;
 import ghidra.util.exception.CancelledException;
 import ghidra.util.task.Task;
 import ghidra.util.task.TaskMonitor;
@@ -38,6 +40,8 @@ public class DataTypeTreeDeleteTask extends Task {
 	private DataTypeManagerPlugin plugin;
 	private int nodeCount;
 
+	private boolean hasClosedCategories = false;
+
 	public DataTypeTreeDeleteTask(DataTypeManagerPlugin plugin, List<GTreeNode> nodes) {
 		super("Delete Nodes", true, true, true);
 		this.plugin = plugin;
@@ -48,15 +52,19 @@ public DataTypeTreeDeleteTask(DataTypeManagerPlugin plugin, List<GTreeNode> node
 	}
 
 	private Map<ArchiveNode, List<GTreeNode>> groupNodeByArchive(List<GTreeNode> nodes) {
-		Map<ArchiveNode, List<GTreeNode>> archiveNodeMap = new HashMap<>();
 
+		Map<ArchiveNode, List<GTreeNode>> archiveNodeMap = new HashMap<>();
 		for (GTreeNode node : nodes) {
 			ArchiveNode archiveNode = ((DataTypeTreeNode) node).getArchiveNode();
-			List<GTreeNode> archiveNodeList = archiveNodeMap.get(archiveNode);
-			if (archiveNodeList == null) {
-				archiveNodeList = new ArrayList<>();
-				archiveNodeMap.put(archiveNode, archiveNodeList);
+			List<GTreeNode> archiveNodeList = archiveNodeMap.computeIfAbsent(archiveNode,
+				n -> new ArrayList<>());
+
+			if (node instanceof CategoryNode) {
+				if (!node.isLoaded()) {
+					hasClosedCategories = true;
+				}
 			}
+
 			archiveNodeList.add(node);
 		}
 		return archiveNodeMap;
@@ -95,6 +103,7 @@ public void run(TaskMonitor monitor) {
 		for (List<GTreeNode> list : nodesByArchive.values()) {
 			total += list.size();
 		}
+
 		monitor.initialize(total);
 
 		//
@@ -108,8 +117,14 @@ public void run(TaskMonitor monitor) {
 		DataTypesProvider provider = plugin.getProvider();
 		DataTypeArchiveGTree tree = provider.getGTree();
 		GTreeState treeState = tree.getTreeState();
+		boolean collapseTree = nodeCount > NODE_COUNT_FOR_COLLAPSING_TREE || hasClosedCategories;
+		Program program = plugin.getProgram();
+		boolean wereEventsEnabled = program.isSendingEvents();
 		try {
-			if (nodeCount > NODE_COUNT_FOR_COLLAPSING_TREE) {
+			program.setEventsEnabled(false);
+
+			if (collapseTree) {
+				monitor.setIndeterminate(true);
 				collapseArchives(tree);
 			}
 
@@ -124,7 +139,16 @@ public void run(TaskMonitor monitor) {
 			// nothing to report
 		}
 		finally {
-			tree.restoreTreeState(treeState);
+
+			// Allow any events to go out before we restore the tree state so that the tree does 
+			// not have to process any events it is not concerned with.
+			program.flushEvents();
+			program.getDataTypeManager().flushEvents();
+			program.setEventsEnabled(wereEventsEnabled);
+			if (collapseTree) {
+				Swing.allowSwingToProcessEvents();
+				tree.restoreTreeState(treeState);
+			}
 		}
 	}
 
@@ -140,18 +164,14 @@ private void deleteNodes(ArchiveNode archiveNode, List<GTreeNode> list, TaskMoni
 			throws CancelledException {
 
 		Archive archive = archiveNode.getArchive();
-		DataTypeManager dataTypeManager = archive.getDataTypeManager();
-		int transactionID = dataTypeManager.startTransaction("Delete Category/DataType");
-		try {
+		DataTypeManager dtm = archive.getDataTypeManager();
+		dtm.withTransaction("Delete Category/DataType", () -> {
 			for (GTreeNode node : list) {
 				monitor.checkCancelled();
 				removeNode(node, monitor);
 				monitor.incrementProgress(1);
 			}
-		}
-		finally {
-			dataTypeManager.endTransaction(transactionID, true);
-		}
+		});
 	}
 
 	private void removeNode(GTreeNode node, TaskMonitor monitor) {
@@ -159,7 +179,7 @@ private void removeNode(GTreeNode node, TaskMonitor monitor) {
 			DataTypeNode dataTypeNode = (DataTypeNode) node;
 			DataType dataType = dataTypeNode.getDataType();
 			DataTypeManager dataTypeManager = dataType.getDataTypeManager();
-			dataTypeManager.remove(dataType, monitor);
+			dataTypeManager.remove(dataType);
 		}
 		else {
 			CategoryNode categoryNode = (CategoryNode) node;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/stackeditor/StackEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/stackeditor/StackEditorModel.java
index a4faae02349..8b11872c9b7 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/stackeditor/StackEditorModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/stackeditor/StackEditorModel.java
@@ -1099,7 +1099,7 @@ public void dataTypeRemoved(DataTypeManager dataTypeManager, DataTypePath path)
 		}
 
 		OffsetPairs offsetSelection = getRelOffsetSelection();
-		viewDTM.remove(dataType, TaskMonitor.DUMMY);
+		viewDTM.remove(dataType);
 		fireTableDataChanged();
 		componentDataChanged();
 		setRelOffsetSelection(offsetSelection);
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge1Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge1Test.java
index 0fb87b2b2c7..173031997fc 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge1Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge1Test.java
@@ -379,7 +379,7 @@ public void modifyPrivate(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(-1);
@@ -409,7 +409,7 @@ public void modifyPrivate(ProgramDB program) {
 				CategoryPath path = new CategoryPath("/Category1/Category2/Category3");
 				Structure s = new StructureDataType(path, "my_struct", 5);
 				DataType dt = dtm.addDataType(s, DataTypeConflictHandler.DEFAULT_HANDLER);
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(-1);
@@ -442,7 +442,7 @@ public void modifyPrivate(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(DataTypeMergeManager.OPTION_MY);
@@ -475,7 +475,7 @@ public void modifyPrivate(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category5"),
 					"FloatStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(DataTypeMergeManager.OPTION_LATEST);
@@ -496,7 +496,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -526,7 +526,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -578,7 +578,7 @@ public void modifyLatest(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -588,7 +588,7 @@ public void modifyPrivate(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(-1);
@@ -772,7 +772,7 @@ public void modifyPrivate(ProgramDB program) {
 				// /Category1/Category2/Category3
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 		});
 		executeMerge(DataTypeMergeManager.OPTION_MY);
@@ -792,7 +792,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 					"IntStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge2Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge2Test.java
index 80607bb0c26..dfe78e853d8 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge2Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge2Test.java
@@ -32,7 +32,6 @@
 import ghidra.program.model.symbol.Symbol;
 import ghidra.util.InvalidNameException;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * Tests for merging data types.
@@ -1010,7 +1009,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1105,11 +1104,11 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 				DataType word = dtm.getDataType(new CategoryPath("/"), "word");
 				// remove Bar and word from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
-				dtm.remove(word, TaskMonitor.DUMMY);
+				dtm.remove(bar);
+				dtm.remove(word);
 			}
 
 			@Override
@@ -1220,7 +1219,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 						.getDataType(new CategoryPath("/MISC"), "MyFunctionDef");
 				fd.setReturnType(bar);
 				Structure foo = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 			}
 
 			@Override
@@ -1273,7 +1272,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				fd.setVarArgs(true);
 				fd.setNoReturn(true);
 				Structure foo = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 			}
 
 			@Override
@@ -1328,7 +1327,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				fd.setVarArgs(true);
 				fd.setNoReturn(true);
 				Structure foo = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 			}
 
 			@Override
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java
index fb2c459b0ca..4c147c79b6b 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java
@@ -24,7 +24,6 @@
 import ghidra.program.model.data.*;
 import ghidra.program.model.data.Enum;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * More data type merge tests.
@@ -41,7 +40,7 @@ public void testDeleteUnionComponent() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				// 2 components should get removed from CoolUnion
 			}
 
@@ -113,7 +112,7 @@ public void testDeleteUnionComponent2() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				// 2 components should be bad in CoolUnion
 			}
 
@@ -181,7 +180,7 @@ public void testDeleteUnionComponent3() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				// 2 components should get removed from CoolUnion
 			}
 
@@ -502,7 +501,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "Structure_1");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -562,7 +561,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "Structure_1");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 				// causes Bar to be marked as changed
 			}
 
@@ -621,7 +620,7 @@ public void modifyLatest(ProgramDB program) {
 
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "Structure_1");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 				// causes Bar to be marked as changed
 			}
 
@@ -700,7 +699,7 @@ public void modifyLatest(ProgramDB program) {
 				Structure a = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "ArrayStruct");
 				Structure ms = (Structure) dtm.getDataType(new CategoryPath("/Category1/Category2"),
 					"MyStruct");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 				Structure s1 = new StructureDataType(
 					new CategoryPath("/Category1/Category2/Category5"), "s1", 0);
 				s1.add(ms);
@@ -811,7 +810,7 @@ public void modifyOriginal(ProgramDB program) throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				DataType dt = dtm.getDataType(new CategoryPath("/Category1/Category2"), "BF");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1127,7 +1126,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				dtm.replaceDataType(td, new TypedefDataType("NewBF", IntegerDataType.dataType),
 					true);
 				DataType dt = dtm.getDataType("/MISC/FooTypedef");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				DataType dt1 = dtm.getDataType("/BF");
 				assertNull(dt1);
@@ -1200,7 +1199,7 @@ public void testEditUnions() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				// 2 components should get removed from CoolUnion
 			}
 
@@ -1278,7 +1277,7 @@ public void testEditUnions2() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				// 2 components should get removed from CoolUnion
 			}
 
@@ -1364,10 +1363,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1436,10 +1435,10 @@ public void testEditUnions4() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1518,10 +1517,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1590,10 +1589,10 @@ public void testEditUnions6() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1693,10 +1692,10 @@ public void testEditUnions7() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1779,10 +1778,10 @@ public void testEditUnions8() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -1888,7 +1887,7 @@ public void modifyLatest(ProgramDB program) {
 
 				try {
 					DataType enumm = dtm.getDataType(new CategoryPath("/Category1"), "XYZ");
-					dtm.remove(enumm, TaskMonitor.DUMMY);
+					dtm.remove(enumm);
 
 					Union union = (Union) dtm.getDataType(new CategoryPath("/Category1/Category2"),
 						"CoolUnion");
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge4Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge4Test.java
index ca667825093..d8177882178 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge4Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge4Test.java
@@ -29,7 +29,6 @@
 import ghidra.program.model.data.*;
 import ghidra.util.InvalidNameException;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * More data type merge tests.
@@ -425,7 +424,7 @@ public void modifyLatest(ProgramDB program) {
 				// change ArrayStruct
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure foo = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 			}
 
 			@Override
@@ -617,7 +616,7 @@ public void modifyLatest(ProgramDB program) {
 				// delete Bar from Foo
 				fs.delete(3);
 				// add Foo to Bar
-				dtm.remove(bs, TaskMonitor.DUMMY);
+				dtm.remove(bs);
 
 				// Add s1, s2, s3
 				Structure s1 = new StructureDataType(new CategoryPath("/MISC"), "S1", 0);
@@ -705,7 +704,7 @@ public void modifyLatest(ProgramDB program) {
 				// delete Bar from Foo
 				foo.delete(3);
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 
 				// Add s1, s2, s3
 				Structure s1 = new StructureDataType(new CategoryPath("/MISC"), "S1", 0);
@@ -801,7 +800,7 @@ public void modifyLatest(ProgramDB program) {
 				// delete Bar from Foo
 				fs.delete(3);
 				// remove Bar from the data type manager
-				dtm.remove(bs, TaskMonitor.DUMMY);
+				dtm.remove(bs);
 
 				// Add s1, s2, s3
 				Structure s1 = new StructureDataType(new CategoryPath("/MISC"), "S1", 0);
@@ -945,7 +944,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure fs = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
 				// delete Foo from the data type manager
-				dtm.remove(fs, TaskMonitor.DUMMY);
+				dtm.remove(fs);
 			}
 
 			@Override
@@ -954,7 +953,7 @@ public void modifyPrivate(ProgramDB program) {
 				Structure foo = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
 				dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// delete Foo from the data type manager
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 
 				// Add s1, s2, s3
 				Structure s1 = new StructureDataType(new CategoryPath("/MISC"), "S1", 0);
@@ -1023,7 +1022,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure fs = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Foo");
 				// delete Foo from the data type manager
-				dtm.remove(fs, TaskMonitor.DUMMY);
+				dtm.remove(fs);
 			}
 
 			@Override
@@ -1033,7 +1032,7 @@ public void modifyPrivate(ProgramDB program) {
 				dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 
 				// delete Foo from the data type manager
-				dtm.remove(foo, TaskMonitor.DUMMY);
+				dtm.remove(foo);
 
 				// Add s1, s2, s3
 				Structure s1 = new StructureDataType(new CategoryPath("/MISC"), "S1", 0);
@@ -1181,7 +1180,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1296,7 +1295,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1409,7 +1408,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1482,7 +1481,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1579,7 +1578,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1670,7 +1669,7 @@ public void modifyLatest(ProgramDB program) {
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1756,7 +1755,7 @@ public void modifyLatest(ProgramDB program) {
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
@@ -1838,7 +1837,7 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure bar = (Structure) dtm.getDataType(new CategoryPath("/MISC"), "Bar");
 				// remove Bar from the data type manager
-				dtm.remove(bar, TaskMonitor.DUMMY);
+				dtm.remove(bar);
 			}
 
 			@Override
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge5Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge5Test.java
index e4f1096daa0..85d032d1b97 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge5Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge5Test.java
@@ -29,7 +29,6 @@
 import ghidra.program.model.data.Enum;
 import ghidra.util.InvalidNameException;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
 
 /**
  *
@@ -48,10 +47,10 @@ public void testTypeDefUndefined() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -126,10 +125,10 @@ public void testTypeDefs() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -227,10 +226,10 @@ public void testTypeDefs2() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 			}
 
 			@Override
@@ -336,10 +335,10 @@ public void testTypeDefs3() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// edit FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
@@ -459,14 +458,14 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// delete FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
-				dtm.remove(enumm, TaskMonitor.DUMMY);
+				dtm.remove(enumm);
 			}
 
 			@Override
@@ -579,14 +578,14 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// delete FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
-				dtm.remove(enumm, TaskMonitor.DUMMY);
+				dtm.remove(enumm);
 			}
 
 			@Override
@@ -710,10 +709,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// edit FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
@@ -834,10 +833,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// edit FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
@@ -968,10 +967,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// edit FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
@@ -1479,10 +1478,10 @@ public void modifyLatest(ProgramDB program) {
 				DataTypeManager dtm = program.getDataTypeManager();
 
 				Structure s = (Structure) dtm.getDataType(CategoryPath.ROOT, "DLL_Table");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 				DataType dt =
 					dtm.getDataType(new CategoryPath("/Category1/Category2"), "CoolUnion");
-				dtm.remove(dt, TaskMonitor.DUMMY);
+				dtm.remove(dt);
 
 				// edit FavoriteColors
 				Enum enumm = (Enum) dtm.getDataType(new CategoryPath("/MISC"), "FavoriteColors");
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge6Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge6Test.java
index 0fda70521ba..46db28f652b 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge6Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge6Test.java
@@ -21,7 +21,6 @@
 
 import ghidra.program.database.*;
 import ghidra.program.model.data.*;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * Data type merge tests for aligned data types.
@@ -654,7 +653,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				Structure s =
 					(Structure) dtm.getDataType(new CategoryPath("/Category1/Category2/Category3"),
 						"IntStruct");
-				dtm.remove(s, TaskMonitor.DUMMY);
+				dtm.remove(s);
 
 				// Offsets change to 0,2,4,8.
 				Structure intStruct =
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java
index ac72c717c67..73375c6f915 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,6 @@
 import ghidra.program.database.OriginalProgramModifierListener;
 import ghidra.program.database.ProgramDB;
 import ghidra.program.model.data.*;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * More data type merge tests.
@@ -90,7 +89,7 @@ public void modifyLatest(ProgramDB program) {
 				abc.replace(0, new CharDataType(), 1);
 
 				// Remove the XYZ data type.
-				dtm.remove(xyz, TaskMonitor.DUMMY);
+				dtm.remove(xyz);
 			}
 
 			@Override
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeFixupTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeFixupTest.java
index 2716e939a5c..12a0cae1d36 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeFixupTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeFixupTest.java
@@ -22,7 +22,6 @@
 import ghidra.program.database.OriginalProgramModifierListener;
 import ghidra.program.database.ProgramDB;
 import ghidra.program.model.data.*;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * Data type merge tests with fixup for data types added in My program.
@@ -73,7 +72,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				Structure inner = (Structure) dtm.getDataType(rootPath, "inner");
 
 				// Remove inner struct
-				dtm.remove(inner, TaskMonitor.DUMMY);
+				dtm.remove(inner);
 			}
 
 			@Override
@@ -211,7 +210,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				Structure inner = (Structure) dtm.getDataType(rootPath, "inner");
 
 				// Remove inner struct
-				dtm.remove(inner, TaskMonitor.DUMMY);
+				dtm.remove(inner);
 			}
 
 			@Override
@@ -303,7 +302,7 @@ public void modifyLatest(ProgramDB program) throws Exception {
 				Structure inner = (Structure) dtm.getDataType(rootPath, "inner");
 
 				// Remove inner struct
-				dtm.remove(inner, TaskMonitor.DUMMY);
+				dtm.remove(inner);
 			}
 
 			@Override
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeUseForAllTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeUseForAllTest.java
index 8a536954861..4698bd09fd6 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeUseForAllTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMergeUseForAllTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,6 @@
 import ghidra.program.database.ProgramDB;
 import ghidra.program.database.ProgramModifierListener;
 import ghidra.program.model.data.*;
-import ghidra.util.task.TaskMonitor;
 
 /**
  * Tests for merging data types.
@@ -88,7 +87,7 @@ public void modifyLatest(ProgramDB program) {
 						"CharStruct");
 
 				intStruct.add(new ByteDataType());// Change data type.
-				dtm.remove(coolUnion, TaskMonitor.DUMMY);// Remove the data type.
+				dtm.remove(coolUnion);// Remove the data type.
 				charStruct.add(new FloatDataType());
 			}
 
@@ -106,7 +105,7 @@ public void modifyPrivate(ProgramDB program) {
 					(Structure) dtm.getDataType(new CategoryPath("/Category1/Category2/Category4"),
 						"CharStruct");
 
-				dtm.remove(intStruct, TaskMonitor.DUMMY);// Remove the data type.
+				dtm.remove(intStruct);// Remove the data type.
 				coolUnion.delete(2);
 				charStruct.add(new CharDataType());
 			}
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorLockedEnablementTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorLockedEnablementTest.java
index a5c824d6417..c699438b487 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorLockedEnablementTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorLockedEnablementTest.java
@@ -23,7 +23,6 @@
 import ghidra.program.model.data.DataTypeManager;
 import ghidra.program.model.data.Structure;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
 
 public class StructureEditorLockedEnablementTest extends AbstractStructureEditorTest {
 
@@ -33,7 +32,7 @@ public void testEmptyStructureEditorState() {
 		Structure desiredEmptyStructure = emptyStructure;
 		int txID = program.startTransaction("Removing emptyStruct from DTM.");
 		try {
-			programDTM.remove(emptyStructure, TaskMonitor.DUMMY);
+			programDTM.remove(emptyStructure);
 			if (emptyStructure.getDataTypeManager() != catDTM) {
 				desiredEmptyStructure = (Structure) emptyStructure.copy(catDTM);
 				desiredEmptyStructure.setCategoryPath(pgmTestCat.getCategoryPath());
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
index a399db5c18c..04c33ae726b 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
@@ -36,7 +36,7 @@ public class StructureEditorNotifiedTest extends AbstractStructureEditorTest {
 	public void setUp() throws Exception {
 		super.setUp();
 
-		// Create overlapping trasnaction to handle all changes
+		// Create overlapping transaction to handle all changes
 		persistentTxId = program.startTransaction("Modify Program");
 	}
 
@@ -88,7 +88,7 @@ public void testEditedDataTypeRemoved() throws Exception {
 		assertEquals("complexStructure *", dataType10.getDisplayName());
 		assertEquals(4, getLength(10));
 
-		programDTM.remove(complexStructure, TaskMonitor.DUMMY);
+		programDTM.remove(complexStructure);
 		programDTM.getCategory(pgmRootCat.getCategoryPath())
 				.removeCategory("Temp", TaskMonitor.DUMMY);
 
@@ -505,7 +505,7 @@ public void testComponentDataTypeRemoved() {
 		assertEquals(0x145, model.getLength());
 
 		runSwing(
-			() -> complexStructure.getDataTypeManager().remove(simpleUnion, TaskMonitor.DUMMY));
+			() -> complexStructure.getDataTypeManager().remove(simpleUnion));
 		waitForSwing();
 		assertEquals(23, model.getNumComponents());
 		assertTrue(dt3.isEquivalent(getDataType(3)));
@@ -536,7 +536,7 @@ public void testOnlyComponentDataTypeRemoved() throws Exception {
 		assertTrue(simpleStructure.isEquivalent(getDataType(0)));
 
 		runSwing(
-			() -> simpleStructure.getDataTypeManager().remove(simpleStructure, TaskMonitor.DUMMY));
+			() -> simpleStructure.getDataTypeManager().remove(simpleStructure));
 		waitForSwing();
 
 		assertEquals(1, model.getNumComponents());// component becomes BadDataType
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/UnionEditorNotifiedTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/UnionEditorNotifiedTest.java
index ac037ffa765..8d257262fc8 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/UnionEditorNotifiedTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/UnionEditorNotifiedTest.java
@@ -115,7 +115,7 @@ public void testEditedDtCategoryRemoved() throws Exception {
 		DataType dt18 = getDataType(18).clone(programDTM);
 		DataType dt20 = getDataType(20).clone(programDTM);
 		SwingUtilities.invokeLater(() -> {
-			programDTM.remove(complexUnion, TaskMonitor.DUMMY);
+			programDTM.remove(complexUnion);
 			programDTM.getCategory(pgmRootCat.getCategoryPath())
 					.removeCategory("Temp", TaskMonitor.DUMMY);
 		});
@@ -319,7 +319,7 @@ public void testComponentDataTypeRemoved() {
 		assertEquals(0x57, model.getLength());
 
 		SwingUtilities.invokeLater(
-			() -> complexUnion.getDataTypeManager().remove(simpleStructure, TaskMonitor.DUMMY));
+			() -> complexUnion.getDataTypeManager().remove(simpleStructure));
 		waitForSwing();
 
 		assertEquals(21, model.getNumComponents());
@@ -362,7 +362,7 @@ public void testOnlyComponentDataTypeRemoved() throws Exception {
 		assertEquals(8, model.getLength());
 
 		SwingUtilities.invokeLater(
-			() -> simpleUnion.getDataTypeManager().remove(simpleUnion, TaskMonitor.DUMMY));
+			() -> simpleUnion.getDataTypeManager().remove(simpleUnion));
 		waitForSwing();
 
 		assertEquals(1, model.getNumComponents());
@@ -387,7 +387,7 @@ public void testEditedDataTypeRemoved() {
 		Union refUnion = (Union) dtm.getDataType("/testCat/refUnion");
 		assertNotNull(refUnion);
 
-		SwingUtilities.invokeLater(() -> dtm.remove(refUnion, TaskMonitor.DUMMY)); // remove refUnion
+		SwingUtilities.invokeLater(() -> dtm.remove(refUnion)); // remove refUnion
 		waitForSwing();
 
 		// refUnion* gets removed
@@ -403,7 +403,7 @@ public void testEditedDataTypeRemoved() {
 		assertTrue(dt20.isEquivalent(getDataType(20)));
 
 		SwingUtilities.invokeLater(
-			() -> simpleUnion.getDataTypeManager().remove(simpleUnion, TaskMonitor.DUMMY));
+			() -> simpleUnion.getDataTypeManager().remove(simpleUnion));
 		waitForSwing();
 
 		assertEquals(len, model.getLength());
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/editor/EnumEditor1Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/editor/EnumEditor1Test.java
index aeb9d70331d..5dafb35c159 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/editor/EnumEditor1Test.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/editor/EnumEditor1Test.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -607,7 +607,7 @@ public void testExternalRemove() throws Exception {
 
 		DataTypeManager dtm = program.getDataTypeManager();
 		int transactionID = program.startTransaction("Test");
-		dtm.remove(enummDt, TaskMonitor.DUMMY);
+		dtm.remove(enummDt);
 		program.endTransaction(transactionID, true);
 		program.flushEvents();
 		waitForSwing();
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/ArrayTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/ArrayTest.java
index 82a3b438a45..b58b9346203 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/ArrayTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/ArrayTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -117,7 +117,7 @@ public void testDeleteArray() throws Exception {
 		listing.getDataAt(addr(0x100));
 		CategoryPath path = dt.getCategoryPath();
 		assertNotNull(path);
-		dt.getDataTypeManager().remove(dt, TaskMonitor.DUMMY);
+		dt.getDataTypeManager().remove(dt);
 
 		assertTrue(array.isDeleted());
 		assertNull(dt.getDataTypeManager().getDataType(path, name));
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/DataManagerTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/DataManagerTest.java
index edac7529e77..883c4980c3c 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/DataManagerTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/DataManagerTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,8 +17,7 @@
 
 import static org.junit.Assert.*;
 
-import java.util.ArrayList;
-import java.util.Iterator;
+import java.util.*;
 
 import org.junit.*;
 
@@ -28,7 +27,6 @@
 import ghidra.test.AbstractGhidraHeadedIntegrationTest;
 import ghidra.util.InvalidNameException;
 import ghidra.util.task.TaskMonitor;
-import ghidra.util.task.TaskMonitorAdapter;
 
 public class DataManagerTest extends AbstractGhidraHeadedIntegrationTest {
 	private ProgramDB program;
@@ -274,7 +272,7 @@ public void testRemoveDataType() throws Exception {
 		assertTrue(p.isEquivalent(dataMgr.getDataType("/ByteTypedef *32")));
 		assertTrue(ptr.isEquivalent(dataMgr.getDataType("/ByteTypedef *32 *32")));
 		DataType bdt = dataMgr.getDataType("/byte");
-		dataMgr.remove(bdt, new TaskMonitorAdapter());
+		dataMgr.remove(bdt);
 		assertNull(dataMgr.getDataType("/byte"));
 		assertNull(dataMgr.getDataType("/byte[5]"));
 		assertNull(dataMgr.getDataType("/ByteTypedef"));
@@ -294,11 +292,31 @@ public void testRemoveDataType2() throws Exception {
 		DataType bdt = td.getDataType();
 		long byteID = dataMgr.getResolvedID(bdt);
 
-		dataMgr.remove(td, new TaskMonitorAdapter());
+		dataMgr.remove(td);
 		assertNull(ptr.getDataType());
 		assertNotNull(dataMgr.getDataType(byteID));
 	}
 
+	@Test
+	public void testRemoveDataTypes() throws Exception {
+		Array array = new ArrayDataType(new ByteDataType(), 5, 1);
+
+		List<DataType> toDelete = new ArrayList<>();
+
+		// Use a number that will trigger the 'chunking' behavior of the DataTypeManagerDB
+		for (int i = 0; i < 2500; i++) {
+			TypeDef td = new TypedefDataType("ByteTypedef" + (i + 1), array);
+			DataType dt = dataMgr.resolve(td, null);
+			toDelete.add(dt);
+		}
+
+		dataMgr.remove(toDelete, TaskMonitor.DUMMY);
+
+		for (DataType dt : toDelete) {
+			assertFalse(dataMgr.contains(dt));
+		}
+	}
+
 //	public void testSave() throws Exception {
 //		
 //		Array array = new ArrayDataType(new ByteDataType(), 5);
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/SettingsTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/SettingsTest.java
index 2cc58aed914..2261bf56828 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/SettingsTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/data/SettingsTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -517,7 +517,7 @@ public void testDefaultSettingsOnDeletedTypdef() throws Exception {
 		endTransaction();
 
 		startTransaction();
-		dataMgr.remove(td, TaskMonitor.DUMMY);
+		dataMgr.remove(td);
 		endTransaction();
 		// make sure accessing the settings does not blow up
 		assertTrue(td.isDeleted());
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/function/FunctionDBTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/function/FunctionDBTest.java
index c7e3595055c..bf2ad9802b2 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/function/FunctionDBTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/function/FunctionDBTest.java
@@ -1296,7 +1296,7 @@ public void testDataTypeOnRegisterVariable() throws Exception {
 		// delete the typedef data type
 		localTransactionID = program.startTransaction("test");
 		try {
-			program.getDataTypeManager().remove(td, TaskMonitor.DUMMY);
+			program.getDataTypeManager().remove(td);
 		}
 		finally {
 			program.endTransaction(localTransactionID, true);
diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
index 4b6a9d907d2..6e9e713b824 100644
--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java
@@ -4251,7 +4251,7 @@ private void removeEmptyStructure(CategoryPath folderPath, String structureName)
 		DataType dataType = dataTypeManager.getDataType(folderPath, structureName);
 		if (extendedFlatAPI.isEmptyStructure(dataType)) {
 
-			dataTypeManager.remove(dataType, monitor);
+			dataTypeManager.remove(dataType);
 			Category classCategory = dataTypeManager.getCategory(folderPath);
 			Category parentCategory = classCategory.getParent();
 			boolean tryToRemove = true;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProjectDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProjectDataTypeManager.java
index d17330f2c7d..2d26cb59504 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProjectDataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProjectDataTypeManager.java
@@ -314,7 +314,7 @@ public void archiveReady(OpenMode openMode, TaskMonitor monitor)
 	}
 
 	@Override
-	public void close() {
+	public synchronized void close() {
 		// do nothing - cannot close a project data type manager
 		// dispose should be invoked by the owner of the instance
 	}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
index 3f5b0517880..eb0dcbee04b 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
@@ -2707,20 +2707,18 @@ protected boolean isUndefined(Address address, long addr) {
 	public void clearData(Set<Long> dataTypeIDs, TaskMonitor monitor) throws CancelledException {
 		lock.acquire();
 		try {
-			List<Address> addrs = new ArrayList<>();
+			List<Address> toClear = new ArrayList<>();
 			RecordIterator it = dataAdapter.getRecords();
 			while (it.hasNext()) {
 				monitor.checkCancelled();
 				DBRecord rec = it.next();
 				long id = rec.getLongValue(DataDBAdapter.DATA_TYPE_ID_COL);
-				for (long dataTypeID : dataTypeIDs) {
-					if (id == dataTypeID) {
-						addrs.add(addrMap.decodeAddress(rec.getKey()));
-						break;
-					}
+				if (dataTypeIDs.contains(id)) {
+					toClear.add(addrMap.decodeAddress(rec.getKey()));
 				}
 			}
-			for (Address addr : addrs) {
+
+			for (Address addr : toClear) {
 				monitor.checkCancelled();
 				clearCodeUnits(addr, addr, false, monitor);
 			}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CategoryDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CategoryDB.java
index e10c7857b12..f85b3bd8f7c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CategoryDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CategoryDB.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,8 +27,7 @@
 import ghidra.program.model.data.DataTypeConflictHandler.ConflictResult;
 import ghidra.util.InvalidNameException;
 import ghidra.util.Lock;
-import ghidra.util.exception.AssertException;
-import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.*;
 import ghidra.util.task.TaskMonitor;
 
 /**
@@ -308,9 +307,6 @@ public Category createCategory(String categoryName) throws InvalidNameException
 		return null;
 	}
 
-	/**
-	 * @see ghidra.program.model.data.Category#removeCategory(java.lang.String, ghidra.util.task.TaskMonitor)
-	 */
 	@Override
 	public boolean removeCategory(String categoryName, TaskMonitor monitor) {
 		mgr.lock.acquire();
@@ -320,6 +316,7 @@ public boolean removeCategory(String categoryName, TaskMonitor monitor) {
 			if (c == null) {
 				return false;
 			}
+
 			Category[] cats = c.getCategories();
 			for (Category cat : cats) {
 				if (monitor.isCancelled()) {
@@ -327,13 +324,16 @@ public boolean removeCategory(String categoryName, TaskMonitor monitor) {
 				}
 				c.removeCategory(cat.getName(), monitor);
 			}
+
 			DataType[] dts = c.getDataTypes();
-			for (DataType dt : dts) {
-				if (monitor.isCancelled()) {
-					return false;
-				}
-				mgr.remove(dt, monitor);
+			List<DataType> dtList = Arrays.asList(dts);
+			try {
+				mgr.remove(dtList, monitor);
 			}
+			catch (CancelledException e) {
+				return false;
+			}
+
 			try {
 				mgr.getCategoryDBAdapter().removeCategory(c.getKey());
 				subcategoryMap.remove(categoryName);
@@ -565,7 +565,7 @@ public boolean remove(DataType type, TaskMonitor monitor) {
 			throw new IllegalArgumentException(
 				"can't remove dataType from category that its not a member of!");
 		}
-		return mgr.remove(type, monitor);
+		return mgr.remove(type);
 	}
 
 	/**
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
index de02ba55a91..81127cc1f07 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
@@ -164,7 +164,7 @@ abstract public class DataTypeManagerDB implements DataTypeManager {
 	 */
 	private Set<Long> blockedRemovalsByID;
 
-	// TODO: idsToDataTypeMap may have issue since there could be a one to many mapping
+	// Note: idsToDataTypeMap may have issue since there could be a one to many mapping
 	// (e.g., type with same UniversalID could be in multiple categories unless specifically 
 	// prevented during resolve)
 	private IdsToDataTypeMap idsToDataTypeMap = new IdsToDataTypeMap();
@@ -172,7 +172,7 @@ abstract public class DataTypeManagerDB implements DataTypeManager {
 	private ThreadLocal<EquivalenceCache> equivalenceCache = new ThreadLocal<>();
 
 	private IdentityHashMap<DataType, DataType> resolveCache;
-	private TreeSet<ResolvePair> resolveQueue; // TODO: is TreeSet really needed?
+	private TreeSet<ResolvePair> resolveQueue; // Note: is TreeSet really needed?
 	private LinkedList<DataType> conflictQueue = new LinkedList<>();
 
 	private boolean isBulkRemoving;
@@ -1421,14 +1421,14 @@ else if (existingDataType instanceof EnumDB) {
 				if (!(dataType instanceof Enum)) {
 					return false;
 				}
-				// TODO: implement doReplaceWith
+				// DT: implement doReplaceWith
 				existingDataType.replaceWith(dataType);
 			}
 			else if (existingDataType instanceof TypedefDB) {
 				if (!(dataType instanceof TypeDef)) {
 					return false;
 				}
-				// TODO: implement doReplaceWith
+				// DT: implement doReplaceWith
 				existingDataType.replaceWith(dataType);
 			}
 			else {
@@ -1733,7 +1733,6 @@ private DataType resolveNoEquivalentFound(DataType dataType, SourceArchive sourc
 				}
 				catch (DataTypeDependencyException e) {
 					// new type refers to old type - fallthrough to RENAME_AND_ADD
-					// TODO: alternatively we could throw an exception
 				}
 
 			case RENAME_AND_ADD: // default handler behavior
@@ -1760,7 +1759,6 @@ private DataType createConflictDataType(DataType dataType, SourceArchive sourceA
 	private void replaceEquivalentLocalWithSourceDataType(DataType dataType,
 			SourceArchive sourceArchive, DataType existingDataType) {
 		// Since it's equivalent, set its source, ID, and replace its components.
-		// TODO: Need a better way to do this.
 		existingDataType.setSourceArchive(sourceArchive);
 		((DataTypeDB) existingDataType).setUniversalID(dataType.getUniversalID());
 		existingDataType.replaceWith(dataType);
@@ -1786,9 +1784,9 @@ public void addDataTypes(Collection<DataType> dataTypes, DataTypeConflictHandler
 		lock.acquire();
 		boolean isEquivalenceCacheOwner = activateEquivalenceCache();
 		boolean isResolveCacheOwner = activateResolveCache();
-		// TODO: extended hold time on lock may cause the GUI to become
-		// unresponsive.  Consider releasing lock between resolves, although
-		// this exposes risk of having active resolve queue/cache without lock
+		// Note: extended hold time on lock may cause the GUI to become unresponsive.  Consider 
+		// releasing lock between resolves, although this exposes risk of having active resolve 
+		// queue/cache without lock.
 		try {
 			monitor.setMessage("Adding datatypes...");
 			monitor.setMaximum(dataTypes.size());
@@ -1879,7 +1877,7 @@ private void disassociateAllDataTypes(UniversalID sourceArchiveID) {
 	@Override
 	public DataType replaceDataType(DataType existingDt, DataType replacementDt,
 			boolean updateCategoryPath) throws DataTypeDependencyException {
-		// TODO: we should probably disallow replacementDt to be an instanceof
+		// Note: we should probably disallow replacementDt to be an instanceof
 		// Dynamic or FactoryDataType
 		lock.acquire();
 		try {
@@ -2342,11 +2340,30 @@ private boolean removeInternal(DataType dataType) {
 		if (id <= 0) { // removal of certain special types not permitted
 			return false;
 		}
+
 		idsToDelete.add(id);
 		removeQueuedDataTypes();
 		return true;
 	}
 
+	private void removeInternal(List<DataType> dataTypes) {
+		for (DataType dt : dataTypes) {
+
+			if (!contains(dt)) {
+				continue;
+			}
+
+			long id = getID(dt);
+			if (id <= 0) { // removal of certain special types not permitted
+				continue;
+			}
+
+			idsToDelete.add(id);
+		}
+
+		removeQueuedDataTypes();
+	}
+
 	private void removeQueuedDataTypes() {
 
 		// collect all datatype to be removed and notify children which may also get queued
@@ -2358,7 +2375,7 @@ private void removeQueuedDataTypes() {
 			deletedIds.add(id);
 		}
 
-		// perform any neccessary external use removals
+		// perform any necessary external use removals
 		deleteDataTypesUsed(deletedIds);
 
 		// perform actual database updates (e.g., record removal, change notifications, etc.)
@@ -2375,7 +2392,7 @@ private void removeQueuedDataTypes() {
 	}
 
 	/**
-	 * Allow extensions to perform any neccessary fixups for all datatype removals listed.
+	 * Allow extensions to perform any necessary fixups for all datatype removals listed.
 	 * @param deletedIds list of IDs for all datatypes which are getting removed.
 	 */
 	protected abstract void deleteDataTypesUsed(Set<Long> deletedIds);
@@ -2399,7 +2416,7 @@ private void removeUseOfDataType(long id) {
 	}
 
 	@Override
-	public boolean remove(DataType dataType, TaskMonitor monitor) {
+	public boolean remove(DataType dataType) {
 		lock.acquire();
 		try {
 			return removeInternal(dataType);
@@ -2409,6 +2426,32 @@ public boolean remove(DataType dataType, TaskMonitor monitor) {
 		}
 	}
 
+	@Override
+	public void remove(List<DataType> dataTypes, TaskMonitor monitor) throws CancelledException {
+
+		lock.acquire();
+		try {
+
+			// perform the delete in chunks so an excessively large list will still be cancellable
+			int n = dataTypes.size();
+			int chunk = 1000;
+			int chunkEnd = n < chunk ? n : chunk;
+			int start = 0;
+			while (start < chunkEnd) {
+				monitor.checkCancelled();
+				List<DataType> subList = dataTypes.subList(start, chunkEnd);
+				removeInternal(subList);
+
+				start = chunkEnd;
+				int nextChunk = chunkEnd + chunk;
+				chunkEnd = n < nextChunk ? n : nextChunk;
+			}
+		}
+		finally {
+			lock.release();
+		}
+	}
+
 	@Override
 	public void associateDataTypeWithArchive(DataType datatype, SourceArchive archive) {
 		if (!contains(datatype)) {
@@ -2846,7 +2889,7 @@ record = builtinAdapter.getRecord(dataTypeID);
 			CategoryPath catPath = catDB.getCategoryPath();
 			String classPath = record.getString(BuiltinDBAdapter.BUILT_IN_CLASSNAME_COL);
 			String name = record.getString(BuiltinDBAdapter.BUILT_IN_NAME_COL);
-			try { // TODO: !! Can we look for alternate constructor which takes DTM argument
+			try {
 				Class<?> c;
 				try {
 					c = Class.forName(classPath);
@@ -4110,7 +4153,7 @@ public final DataOrganization getDataOrganization() {
 			try {
 				// Initialization of dataOrganization may never have been established
 				// if either an architecture has never been specified or a language
-				// error occured during initializtion.  In such cases the stored
+				// error occurred during initialization.  In such cases the stored
 				// data organization should be used if available.
 				dataOrganization = readDataOrganization();
 			}
@@ -4212,7 +4255,7 @@ private Set<String> getDefinedCallingConventionSet() {
 
 	private TreeSet<String> buildDefinedCallingConventionSet() {
 
-		// Include all calling conventions defined by associated architecure compiler spec
+		// Include all calling conventions defined by associated architecture compiler spec
 		TreeSet<String> nameSet = new TreeSet<>();
 		ProgramArchitecture arch = getProgramArchitecture();
 		if (arch != null) {
@@ -4536,8 +4579,7 @@ public boolean dedupeConflicts(DataType dataType) {
 		}
 	}
 
-	private record DedupedConflicts(int processCnt, int replaceCnt) {
-	}
+	private record DedupedConflicts(int processCnt, int replaceCnt) {}
 
 	private DedupedConflicts doDedupeConflicts(DataType dataType) {
 
@@ -4761,7 +4803,6 @@ private DataType processResolveQueue(boolean deactivateCache, DataType dataType)
 							resolvedDt.postPointerResolve(resolvePair.definitionDt, handler);
 						}
 					}
-					// TODO: catch exceptions if needed
 					finally {
 						resolvedDt.resolving = false;
 						resolvedDt.pointerPostResolveRequired = false;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramBasedDataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramBasedDataTypeManagerDB.java
index 0435f42ef39..8f9ab864eca 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramBasedDataTypeManagerDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramBasedDataTypeManagerDB.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -435,7 +435,7 @@ public static Address getDataSettingsAddress(Data data) {
 		Address addr = data.getAddress();
 		for (Data parent = data.getParent(); parent != null; parent = parent.getParent()) {
 			DataType dataType = parent.getDataType();
-			if (!(dataType instanceof Array a)) {
+			if (!(dataType instanceof Array)) {
 				break;
 			}
 			addr = parent.getAddress();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramDataTypeManager.java
index 631f1663365..c8c922cc820 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramDataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ProgramDataTypeManager.java
@@ -266,6 +266,10 @@ protected void deleteDataTypesUsed(Set<Long> deletedIds) {
 		// use could be an issue.
 		try {
 			// TODO: Should use replacement type instead of clearing
+
+			// Note: use of DUMMY here is intentional, since we do not want to interrupt the 
+			// deleting of these types, as they may have a relationship that we wish to preserve.
+			// All need to be deleted to remain in a consistent state.
 			program.getCodeManager().clearData(deletedIds, TaskMonitor.DUMMY);
 		}
 		catch (CancelledException e) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/BuiltInDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/BuiltInDataTypeManager.java
index 6d0e6c08062..b9c878d0599 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/BuiltInDataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/BuiltInDataTypeManager.java
@@ -210,7 +210,7 @@ public void associateDataTypeWithArchive(DataType datatype, SourceArchive archiv
 	}
 
 	@Override
-	public boolean remove(DataType dataType, TaskMonitor monitor) {
+	public boolean remove(DataType dataType) {
 		throw new UnsupportedOperationException();
 	}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
index af2a4246857..79311bd1e76 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
@@ -75,7 +75,7 @@ public interface DataTypeManager {
 
 	/**
 	 * Get the program architecture information which has been associated with this 
-	 * datatype manager.  If {@link #getProgramArchitecture()} returns null this method
+	 * data type manager.  If {@link #getProgramArchitecture()} returns null this method
 	 * may still return information if the program architecture was set on an archive but unable
 	 * to properly instantiate.
 	 * @return program architecture summary if it has been set
@@ -83,16 +83,16 @@ public interface DataTypeManager {
 	public String getProgramArchitectureSummary();
 
 	/**
-	 * Returns true if the given category path exists in this datatype manager
+	 * Returns true if the given category path exists in this data type manager
 	 * @param path the path
-	 * @return true if the given category path exists in this datatype manager
+	 * @return true if the given category path exists in this data type manager
 	 */
 	public boolean containsCategory(CategoryPath path);
 
 	/**
-	 * Returns a unique name not currently used by any other dataType or category
+	 * Returns a unique name not currently used by any other data type or category
 	 * with the same baseName.  This does not produce a conflict name and is intended 
-	 * to be used when generating an artifical datatype name only (e.g., {@code temp_1},
+	 * to be used when generating an artificial data type name only (e.g., {@code temp_1},
 	 * {@code temp_2}; for {@code baseName="temp"}.
 	 *
 	 * @param path the path of the name
@@ -102,12 +102,11 @@ public interface DataTypeManager {
 	public String getUniqueName(CategoryPath path, String baseName);
 
 	/**
-	 * Returns a dataType that is "in" (ie suitable implementation) this
-	 * Manager, creating a new one if necessary.  Also the returned dataType
-	 * will be in a category in this dataTypeManager that is equivalent to the
-	 * category of the passed in dataType.
+	 * Returns a data type that is "in" this Manager, creating a new one if necessary.  Also the 
+	 * returned data type will be in a category in this manager that is equivalent to the
+	 * category of the passed in data type.
 	 * @param dataType the dataType to be resolved.
-	 * @param handler used to resolve conflicts with existing dataTypes.
+	 * @param handler used to resolve conflicts with existing data types.
 	 * @return an equivalent dataType that "belongs" to this dataTypeManager.
 	 */
 	public DataType resolve(DataType dataType, DataTypeConflictHandler handler);
@@ -309,22 +308,48 @@ public DataType replaceDataType(DataType existingDt, DataType replacementDt,
 	public void removeInvalidatedListener(InvalidatedListener listener);
 
 	/**
-	 * Remove the given datatype from this manager.
+	 * Remove the given data type from this manager.
 	 * <br>
 	 * NOTE: Any use of the specified datatype within a {@link FunctionDefinition} will be 
 	 * converted to the {@link DataType#DEFAULT default 'undefined' datatype}.  Any use within
 	 * a {@link Structure} or {@link Union} will be converted to the {@link BadDataType} as
 	 * a placeholder to retain the component's field name and length (the comment will be prefixed
-	 * with a message indicating the remval of the old datatype.
+	 * with a message indicating the removal of the old datatype.
 	 * 
-	 * @param dataType the dataType to be removed
-	 * @param monitor the task monitor
+	 * @param dataType the data type to be removed
+	 * @return true if the data type existed and was removed
+	 */
+	public boolean remove(DataType dataType);
+
+	/**
+	 * Deprecated.  Use {@link #remove(DataType)}.
+	 * @param dataType the data type
+	 * @param monitor the monitor
 	 * @return true if the data type existed and was removed
+	 * @deprecated use {@link #remove(DataType)}
+	 */
+	@Deprecated(since = "10.4", forRemoval = true)
+	public default boolean remove(DataType dataType, TaskMonitor monitor) {
+		return remove(dataType);
+	}
+
+	/**
+	 * Remove the given data types from this manager.
+	 * <br>
+	 * NOTE: Any use of the specified data types within a {@link FunctionDefinition} will be 
+	 * converted to the {@link DataType#DEFAULT default 'undefined' datatype}.  Any use within
+	 * a {@link Structure} or {@link Union} will be converted to the {@link BadDataType} as
+	 * a placeholder to retain the component's field name and length (the comment will be prefixed
+	 * with a message indicating the removal of the old datatype.
+	 * 
+	 * @param dataTypes the data types to be removed
+	 * @param monitor the monitor
+	 * @throws CancelledException if the user cancels
 	 */
-	public boolean remove(DataType dataType, TaskMonitor monitor);
+	public void remove(List<DataType> dataTypes, TaskMonitor monitor) throws CancelledException;
 
 	/**
-	 * Return true if the given dataType exists in this data type manager
+	 * Return true if the given data type exists in this data type manager
 	 *
 	 * @param dataType the type
 	 * @return true if the type is in this manager
@@ -727,7 +752,7 @@ public default <E extends Exception, T> T withTransaction(String description,
 	public Collection<String> getDefinedCallingConventionNames();
 
 	/**
-	 * Get the default calling convention's prototype model in this datatype manager if known.
+	 * Get the default calling convention's prototype model in this data type manager if known.
 	 *
 	 * @return the default calling convention prototype model or null.
 	 */
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DataTypeSymbol.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DataTypeSymbol.java
index 8564546cb75..57fc4bc0053 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DataTypeSymbol.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DataTypeSymbol.java
@@ -26,7 +26,6 @@
 import ghidra.util.InvalidNameException;
 import ghidra.util.exception.DuplicateNameException;
 import ghidra.util.exception.InvalidInputException;
-import ghidra.util.task.TaskMonitor;
 
 public class DataTypeSymbol {
 	private Symbol sym;			// Traditional symbol object
@@ -151,7 +150,7 @@ public void cleanupUnusedOverride() {
 		}
 
 		// remove unused override signature
-		program.getDataTypeManager().remove(getDataType(), TaskMonitor.DUMMY);
+		program.getDataTypeManager().remove(getDataType());
 	}
 
 	public static DataTypeSymbol readSymbol(String cat, Symbol s) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/StructureDBTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/StructureDBTest.java
index 822641d21f6..ca0eb92a0e3 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/StructureDBTest.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/StructureDBTest.java
@@ -27,8 +27,6 @@
 import ghidra.program.model.data.*;
 import ghidra.util.InvalidNameException;
 import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.task.TaskMonitor;
-import ghidra.util.task.TaskMonitorAdapter;
 
 public class StructureDBTest extends AbstractGenericTest {
 
@@ -65,7 +63,7 @@ public void tearDown() {
 	private void transitionToBigEndian() {
 
 		Structure structClone = struct.clone(null);
-		dataMgr.remove(struct, TaskMonitor.DUMMY);
+		dataMgr.remove(struct);
 
 		DataOrganizationImpl dataOrg = (DataOrganizationImpl) dataMgr.getDataOrganization();
 		dataOrg.setBigEndian(true);
@@ -1167,7 +1165,7 @@ public void testDeleteFlexArrayDependency() {
 			"Length: 8 Alignment: 1", struct);
 		//@formatter:on
 
-		dataMgr.remove(dataMgr.resolve(IntegerDataType.dataType, null), TaskMonitor.DUMMY);
+		dataMgr.remove(dataMgr.resolve(IntegerDataType.dataType, null));
 
 		//@formatter:off
 		CompositeTestUtils.assertExpectedComposite(this, "/Test\n" + 
@@ -1208,7 +1206,7 @@ public void testDeleteBitFieldDependency() throws InvalidDataTypeException {
 			"Length: 11 Alignment: 1", struct);
 		//@formatter:on
 
-		dataMgr.remove(td, TaskMonitor.DUMMY);
+		dataMgr.remove(td);
 
 		//@formatter:off
 		CompositeTestUtils.assertExpectedComposite(this, "/Test\n" + 
@@ -1841,7 +1839,7 @@ public void testDeleteComponent() {
 			"Length: 13 Alignment: 1", struct);
 		//@formatter:on
 
-		dt.getDataTypeManager().remove(dt, new TaskMonitorAdapter());
+		dt.getDataTypeManager().remove(dt);
 
 		//@formatter:off
 		CompositeTestUtils.assertExpectedComposite(this, "/Test\n" + 
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/UnionDBTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/UnionDBTest.java
index 279e280b56c..393993e4aeb 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/UnionDBTest.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/data/UnionDBTest.java
@@ -23,7 +23,6 @@
 
 import generic.test.AbstractGenericTest;
 import ghidra.program.model.data.*;
-import ghidra.util.task.TaskMonitor;
 
 public class UnionDBTest extends AbstractGenericTest {
 
@@ -59,7 +58,7 @@ public void tearDown() {
 	private void transitionToBigEndian() {
 
 		Union unionClone = union.clone(null);
-		dataMgr.remove(union, TaskMonitor.DUMMY);
+		dataMgr.remove(union);
 
 		DataOrganizationImpl dataOrg = (DataOrganizationImpl) dataMgr.getDataOrganization();
 		dataOrg.setBigEndian(true);
@@ -272,7 +271,7 @@ public void testDeleteBitFieldDependency() throws InvalidDataTypeException {
 			"Length: 4 Alignment: 1", union);
 		//@formatter:on
 
-		dataMgr.remove(td, TaskMonitor.DUMMY);
+		dataMgr.remove(td);
 
 		//@formatter:off
 		CompositeTestUtils.assertExpectedComposite(this, "/TestUnion\n" + 
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDoubleDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDoubleDataTypeManager.java
index 78d03a9fe04..22cdd00ac1c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDoubleDataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDoubleDataTypeManager.java
@@ -191,7 +191,12 @@ public void removeInvalidatedListener(InvalidatedListener listener) {
 	}
 
 	@Override
-	public boolean remove(DataType dataType, TaskMonitor monitor) {
+	public boolean remove(DataType dataType) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public void remove(List<DataType> dataTypes, TaskMonitor monitor) throws CancelledException {
 		throw new UnsupportedOperationException();
 	}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDummyDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDummyDataTypeManager.java
index 87feb6bce5c..eababfc72a9 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDummyDataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/TestDummyDataTypeManager.java
@@ -190,11 +190,16 @@ public void removeInvalidatedListener(InvalidatedListener listener) {
 	}
 
 	@Override
-	public boolean remove(DataType dataType, TaskMonitor monitor) {
+	public boolean remove(DataType dataType) {
 		// stub
 		return false;
 	}
 
+	@Override
+	public void remove(List<DataType> dataTypes, TaskMonitor monitor) throws CancelledException {
+		// stub
+	}
+
 	@Override
 	public boolean contains(DataType dataType) {
 		// stub
```
-----------------------------------
