# Commit: a1b6084c88d8b656db15fd5faa707630b8af885b
## Message: GP-0: Adding a missing commit (cosmetic changes)
## Diff:
```
diff --git a/Ghidra/Features/DecompilerDependent/ghidra_scripts/ExportPCodeForCTADL.java b/Ghidra/Features/DecompilerDependent/ghidra_scripts/ExportPCodeForCTADL.java
index 70a680a29a4..345fe10790e 100644
--- a/Ghidra/Features/DecompilerDependent/ghidra_scripts/ExportPCodeForCTADL.java
+++ b/Ghidra/Features/DecompilerDependent/ghidra_scripts/ExportPCodeForCTADL.java
@@ -16,70 +16,27 @@
 //Decompile the function at the cursor and its callees, then output facts files corresponding to the pcodes
 //@category PCode
 
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.Writer;
+import java.io.*;
+import java.lang.Enum;
 import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-
-import ghidra.app.decompiler.DecompInterface;
-import ghidra.app.decompiler.DecompileOptions;
-import ghidra.app.decompiler.DecompileResults;
-import ghidra.app.decompiler.parallel.DecompileConfigurer;
-import ghidra.app.decompiler.parallel.DecompilerCallback;
-import ghidra.app.decompiler.parallel.ParallelDecompiler;
+
+import ghidra.app.decompiler.*;
+import ghidra.app.decompiler.parallel.*;
 import ghidra.app.script.GhidraScript;
 import ghidra.framework.plugintool.PluginTool;
-import ghidra.graph.GDirectedGraph;
-import ghidra.graph.GEdge;
-import ghidra.graph.GVertex;
-import ghidra.graph.GraphFactory;
+import ghidra.graph.*;
 import ghidra.graph.algo.DepthFirstSorter;
 import ghidra.program.database.symbol.FunctionSymbol;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressFactory;
-import ghidra.program.model.data.AbstractFloatDataType;
-import ghidra.program.model.data.AbstractIntegerDataType;
-import ghidra.program.model.data.Array;
-import ghidra.program.model.data.BooleanDataType;
-import ghidra.program.model.data.DataType;
-import ghidra.program.model.data.DataTypeComponent;
-import ghidra.program.model.data.FunctionDefinition;
-import ghidra.program.model.data.ParameterDefinition;
-import ghidra.program.model.data.Pointer;
-import ghidra.program.model.data.Structure;
-import ghidra.program.model.data.TypeDef;
-import ghidra.program.model.data.Union;
-import ghidra.program.model.listing.Data;
-import ghidra.program.model.listing.DataIterator;
-import ghidra.program.model.listing.Function;
-import ghidra.program.model.listing.Program;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.*;
 import ghidra.program.model.mem.MemoryAccessException;
 import ghidra.program.model.pcode.*;
-import ghidra.program.model.symbol.ExternalReference;
-import ghidra.program.model.symbol.Reference;
-import ghidra.program.model.symbol.Symbol;
-import ghidra.program.model.symbol.SymbolIterator;
-import ghidra.program.model.symbol.SymbolTable;
-import ghidra.program.model.symbol.ThunkReference;
+import ghidra.program.model.symbol.*;
 import ghidra.util.task.TaskMonitor;
 
 class PcodeBlockBasicVertex implements GVertex {
@@ -366,7 +323,7 @@ public void processFunction(DecompileResults res, Function f, DecompInterface de
 		varnodes = new HashSet<String>();
 		extraGlobals = new HashMap<HighVariable, VarnodeAST>();
 
-// TODO: This should only be done once if dumping the entire program
+		// NOTE: This should only be done once if dumping the entire program
 		SymbolIterator externalSymbols = f.getProgram().getSymbolTable().getSymbols(f.getName());
 		while (externalSymbols.hasNext()) {
 			Symbol next = externalSymbols.next();
@@ -434,8 +391,6 @@ public void processFunction(DecompileResults res, Function f, DecompInterface de
 	}
 
 	private BigInteger readInteger(Program program, Address addr, int size) {
-		//AddressFactory addrFactory = program.getAddressFactory();
-		//int spaceID = addr.getAddressSpace().getSpaceID();
 		try {
 			byte[] dest = new byte[size];
 			program.getMemory().getBytes(addr, dest, 0, size);
@@ -524,15 +479,6 @@ public void processVTables(Program program) {
 		}
 	}
 
-//	private void initializeSet(SymbolTable table) {
-//		vtables.clear();
-//		SymbolIterator iter = table.getSymbols("vtable");
-//		while (iter.hasNext()) {
-//			Symbol sym2 = iter.next();
-//			vtables.add(sym2.getAddress());
-//		}
-//	}
-
 	private HighFunction getHighFunction(DecompileResults res, Function func, DecompInterface decompiler) {
 		HighFunction high = res.getHighFunction();
 		if (high == null) {
@@ -701,10 +647,6 @@ private void exportHighVariable(HighFunction hfn, HighVariable hv, boolean dontD
 		if (hv.getSymbol() != null) {
 			String hsid = hsID(hfn, hv.getSymbol());
 			export(PredicateFile.SYMBOL_HVAR, hsid, hvarID(hfn, hv));
-//			HighSymbol hs = hv.getSymbol();
-//			if (hs != null) {
-//				export(PredicateFile.HVAR_NAME, id, hs.getName());
-//			}
 		}
 		if (!dontDescend) {
 			VarnodeAST representative = (VarnodeAST) hv.getRepresentative();
@@ -1060,50 +1002,6 @@ private void debug(String s) {
 	}
 }
 
-//class ResultWriter implements Runnable {
-//	BlockingQueue<DecompileResults> q = new ArrayBlockingQueue<>(50);
-//	
-//	HighFunctionExporter ex;
-//	DecompilerConfigurer configurer;
-//	
-//	boolean shutDown = false;
-//
-//	private TaskMonitor monitor;
-//	
-//	public ResultWriter(HighFunctionExporter ex, DecompilerConfigurer configurer, TaskMonitor tMonitor) {
-//		this.ex = ex;
-//		this.configurer = configurer;
-//		this.monitor = tMonitor;
-//	}
-//	
-//	BlockingQueue<DecompileResults> getQueue() {
-//		return q;
-//	}
-//
-//	@Override
-//	public void run() {
-//        try {
-//        	int count = 0;
-//            while(!(shutDown && q.isEmpty())){
-//            	monitor.checkCancelled();
-//            	DecompileResults results = q.take();
-//
-//            	ex.processFunction(results, results.getFunction(), configurer.getInteface());
-//            	
-//            	count++;
-//            	if (count > 50) {
-//                  ex.writeFacts();
-//            		count = 0;
-//            	}
-//            }
-//        } catch (InterruptedException | IOException | CancelledException e) {}
-//	}
-//	
-//	public void done() {
-//		shutDown = true;
-//	}
-//}
-
 public class ExportPCodeForCTADL extends GhidraScript {
 
 	File outputDirectory;
diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/TaintQueryResult.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/TaintQueryResult.java
index 22a7949a360..22724c9bc75 100644
--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/TaintQueryResult.java
+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/TaintQueryResult.java
@@ -29,7 +29,7 @@
 public record TaintQueryResult(String name,String fqname, Address iaddr, Address faddr, List<String> labels, boolean functionLevelResult) {
 
 	// NB: The constructors that follow depend on data generated at different phases in the processing.
-	//   At first blush, it seems obvious that you could combine then by using the location data, accessed
+	//   At first blush, it seems obvious that you could combine them by using the location data, accessed
 	//   in the first to derive the LogicalLocation via llocs in SarifUtils.  llocs, however, is likely to
 	//   be stale when applying the SARIF results.
 	
diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/ctadl/CTADLTaintState.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/ctadl/CTADLTaintState.java
index ee47ddecc54..89f78d8a517 100644
--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/ctadl/CTADLTaintState.java
+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/ctadl/CTADLTaintState.java
@@ -52,12 +52,9 @@ public void buildQuery(List<String> paramList, Path engine, File indexDBFile,
 		if (!direction.equals(TaintDirection.DEFAULT)) {
 			paramList.add("--compute-slices");
 			switch (taintOptions.getTaintDirection()) {
-				case TaintDirection.BOTH ->
-					paramList.add("all");
-				case TaintDirection.FORWARD ->
-					paramList.add("fwd");
-				case TaintDirection.BACKWARD ->
-					paramList.add("bwd");
+				case TaintDirection.BOTH -> paramList.add("all");
+				case TaintDirection.FORWARD -> paramList.add("fwd");
+				case TaintDirection.BACKWARD -> paramList.add("bwd");
 				default -> {
 					// No action
 				}
@@ -106,12 +103,11 @@ protected String getScriptName(boolean perFunction) {
 		return perFunction ? "ExportPCodeForSingleFunction.java" : "ExportPCodeForCTADL.java";
 	}
 
-
 	@Override
 	protected void writeHeader(PrintWriter writer) {
 		writer.println("#include \"pcode/taintquery.dl\"");
 	}
-	
+
 	/*
 	 * NOTE: This is the only method used now for Sources and Sinks.
 	 */
@@ -161,8 +157,9 @@ protected void writeRule(PrintWriter writer, TaintLabel mark, boolean isSource)
 				// Note this is an OR
 				writer.println("\tVNODE_HVAR(vn, hv));");
 				writer.println("\tCVar_SourceInfo(vn, SOURCE_INFO_NAME_KEY, \"" +
-				TaintState.varName(token, false) + "\")),");
-			} else if (mark.bySymbol()) {
+					TaintState.varName(token, false) + "\")),");
+			}
+			else if (mark.bySymbol()) {
 				writer.println("\tSYMBOL_NAME(sym, \"" + token.getText() + "\"),");
 				writer.println("\tSYMBOL_HVAR(sym, hv),");
 				writer.println("\tVNODE_HVAR(vn, hv),");
@@ -173,10 +170,10 @@ else if (hv != null) {
 			}
 			else {
 				writer.println("\t(CVar_SourceInfo(vn, SOURCE_INFO_NAME_KEY, \"" +
-				TaintState.varName(token, false) + "\");");
+					TaintState.varName(token, false) + "\");");
 			}
 			if (pathConstraint != null) {
-				writer.println("\tp = \"."+pathConstraint+"\",");
+				writer.println("\tp = \"." + pathConstraint + "\",");
 			}
 			if (!allAccess) {
 				writer.println("\tp = \"\",");
@@ -191,7 +188,7 @@ public void writeGate(PrintWriter writer, TaintLabel mark) {
 		Boolean allAccess = taintOptions.getTaintUseAllAccess();
 		String method = "TaintSanitizeAll";
 		Address addr = mark.getAddress();
-		// TODO: verify setting entryPoint as addr doesn't break things
+		// NOTE: verify setting entryPoint as addr doesn't break things
 
 		if (mark.getFunctionName() == null) {
 			return;
diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/sarif/SarifTaintResultHandler.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/sarif/SarifTaintResultHandler.java
index 5c057c1976f..ea5e94e8bfe 100644
--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/sarif/SarifTaintResultHandler.java
+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/sarif/SarifTaintResultHandler.java
@@ -120,10 +120,6 @@ private void populate(Map<String, Object> map, List<Location> locs) {
 				map.put("entry", faddr);
 				map.put("Address", faddr);
 			}
-//			Address addr = SarifUtils.getLocAddress(program, fqname);
-//			if (addr != null) {
-//				map.put("Address", addr);
-//			}
 			map.put("location", fqname);
 			map.put("kind", ll.getKind());
 			map.put("function", SarifUtils.extractFQNameFunction(fqname));
diff --git a/Ghidra/Features/DecompilerDependent/src/test/java/ghidra/app/plugin/core/decompiler/taint/DecompilerTaintTest.java b/Ghidra/Features/DecompilerDependent/src/test/java/ghidra/app/plugin/core/decompiler/taint/DecompilerTaintTest.java
index 4832444d1a5..79e630fec83 100644
--- a/Ghidra/Features/DecompilerDependent/src/test/java/ghidra/app/plugin/core/decompiler/taint/DecompilerTaintTest.java
+++ b/Ghidra/Features/DecompilerDependent/src/test/java/ghidra/app/plugin/core/decompiler/taint/DecompilerTaintTest.java
@@ -202,11 +202,10 @@ private void processResult(Map<Address, Set<TaintQueryResult>> map, Map<String,
 
 	private void validateResult(ClangToken token, Map<Address, Set<TaintQueryResult>> map) {
 		Set<TaintQueryResult> set = map.get(functionAddr);
-		//System.err.println("VALIDATE: "+functionAddr);
 		if (set != null) {
 			int sz = taintService.getProvider().getTokenCount();
-			//assertEquals(testSizes[testIndex], sz);
-			System.err.println(testSizes[testIndex] + " vs " + sz);
+			assertEquals(testSizes[testIndex], sz);
+			//System.err.println(testSizes[testIndex] + " vs " + sz);
 		}
 		//else {
 		//	System.err.println("NULL for "+functionAddr);
@@ -280,9 +279,6 @@ private void initDatabase() throws Exception {
 		indexTask.addTaskListener(listener);
 		new TaskLauncher(indexTask, tool.getActiveWindow());
 		waitForBusyTool(tool);
-//		while (listener.executing) {
-//			Thread.sleep(100);
-//		}
 
 		for (String f : functionLabels) {
 			decompilerProvider = taintService.getDecompilerProvider();
```
-----------------------------------
