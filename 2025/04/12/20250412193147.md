# Commit: 30008b6715aeadc478c5861846d502804aa74003
## Message: GP-5030 improved x87 operand display
## Diff:
```
diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index cca90b61329..2a330fe2662 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -1105,16 +1105,14 @@ m8:   "byte ptr" Mem   	is Mem      { export *:1 Mem; }
 m16:  "word ptr" Mem  	is Mem      { export *:2 Mem; }
 m32:  "dword ptr" Mem  	is Mem      { export *:4 Mem; }
 m64:  "qword ptr" Mem  	is Mem      { export *:8 Mem; }
+m80:  "tword ptr" Mem   is Mem      { export *:10 Mem; }
 m128: "xmmword ptr" Mem	is Mem      { export *:16 Mem; }
 m256: "ymmword ptr" Mem	is Mem      { export *:32 Mem; }
 m512: "zmmword ptr" Mem is Mem      { export *:64 Mem; }
 
-# spec versions of the m8/m16/m32/... tables explicitly print the operand size
-spec_m8: "byte ptr "^Mem     is Mem      { export *:1 Mem; }
-spec_m16: "word ptr "^Mem    is Mem      { export *:2 Mem; }
-spec_m32: "dword ptr "^Mem    is Mem      { export *:4 Mem; }
-spec_m64: "qword ptr "^Mem    is Mem      { export *:8 Mem; }
-spec_m80: "tword ptr "^Mem    is Mem      { export *:10 Mem; }
+m32fp: "float ptr" Mem              is Mem      { export *:4 Mem; }
+m64fp: "double ptr" Mem             is Mem      { export *:8 Mem; }
+m80fp: "extended double ptr" Mem    is Mem      { export *:10 Mem; }
 
 ##
 ## VSIB
@@ -1383,27 +1381,15 @@ eseDI8: RDI   is addrsize=2 & RDI    { local tmp = RDI; RDI=RDI+8-16*zext(DF); e
 rm8: Rmr8   is mod=3 & Rmr8     { export Rmr8; }
 rm8: "byte ptr" Mem    is  Mem             { export *:1 Mem; }
 
-spec_rm8: Rmr8 				is mod=3 & Rmr8		{ export Rmr8; }
-spec_rm8: "byte ptr "^Mem 	is	Mem				{ export *:1 Mem; }
-
 rm16: Rmr16 is mod=3 & Rmr16    { export Rmr16; }
 rm16: "word ptr" Mem   is Mem              { export *:2 Mem; }
 
-spec_rm16: Rmr16				is mod=3 & Rmr16		{ export Rmr16; }
-spec_rm16: "word ptr "^Mem	is Mem				{ export *:2 Mem; }
-
 rm32: Rmr32 is mod=3 & Rmr32    { export Rmr32; }
 rm32: "dword ptr" Mem   is Mem              { export *:4 Mem; }
 
-spec_rm32: Rmr32				is mod=3 & Rmr32		{ export Rmr32; }
-spec_rm32: "dword ptr "^Mem	is Mem				{ export *:4 Mem; }
-
 @ifdef IA64
 rm64: Rmr64 is mod=3 & Rmr64    { export Rmr64; }
 rm64: "qword ptr" Mem   is Mem              { export *:8 Mem; }
-
-spec_rm64: Rmr64				is mod=3 & Rmr64		{ export Rmr64; }
-spec_rm64: "qword ptr "^Mem	is Mem				{ export *:8 Mem; }
 @endif
 
 n1: one	is epsilon			[ one = 1; ] { export *[const]:1 one; }
@@ -2964,16 +2950,16 @@ define pcodeop clzero;
 @ifdef IA64
 :CMP RAX,simm32      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x3d; RAX & simm32            { subflags(  RAX,simm32); local tmp =   RAX -  simm32; resultflags(tmp); }
 @endif
-:CMP spec_rm8,imm8       is vexMode=0 & $(BYTE_80_82); spec_rm8 & reg_opcode=7 ...; imm8        { local temp:1 = spec_rm8; subflags(temp,imm8 ); local diff = temp - imm8; resultflags(diff); }
-:CMP spec_rm16,imm16     is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=7 ...; imm16 { local temp:2 = spec_rm16; subflags(temp,imm16); local diff = temp - imm16; resultflags(diff); }
-:CMP spec_rm32,imm32     is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & reg_opcode=7 ...; imm32 { local temp:4 = spec_rm32; subflags(temp,imm32); local diff = temp - imm32; resultflags(diff); }
+:CMP rm8,imm8       is vexMode=0 & $(BYTE_80_82); rm8 & reg_opcode=7 ...; imm8        { local temp:1 = rm8; subflags(temp,imm8 ); local diff = temp - imm8; resultflags(diff); }
+:CMP rm16,imm16     is vexMode=0 & opsize=0 & byte=0x81; rm16 & reg_opcode=7 ...; imm16 { local temp:2 = rm16; subflags(temp,imm16); local diff = temp - imm16; resultflags(diff); }
+:CMP rm32,imm32     is vexMode=0 & opsize=1 & byte=0x81; rm32 & reg_opcode=7 ...; imm32 { local temp:4 = rm32; subflags(temp,imm32); local diff = temp - imm32; resultflags(diff); }
 @ifdef IA64
-:CMP spec_rm64,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; spec_rm64 & reg_opcode=7 ...; simm32 { local temp:8 = spec_rm64; subflags(temp,simm32); local diff = temp - simm32; resultflags(diff); }
+:CMP rm64,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; rm64 & reg_opcode=7 ...; simm32 { local temp:8 = rm64; subflags(temp,simm32); local diff = temp - simm32; resultflags(diff); }
 @endif
-:CMP spec_rm16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=7 ...; simm8_16	{ local temp:2 = spec_rm16; subflags(temp,simm8_16); local diff = temp - simm8_16; resultflags(diff); }
-:CMP spec_rm32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & reg_opcode=7 ...; simm8_32	{ local temp:4 = spec_rm32; subflags(temp,simm8_32); local diff = temp - simm8_32; resultflags(diff); }
+:CMP rm16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; rm16 & reg_opcode=7 ...; simm8_16	{ local temp:2 = rm16; subflags(temp,simm8_16); local diff = temp - simm8_16; resultflags(diff); }
+:CMP rm32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; rm32 & reg_opcode=7 ...; simm8_32	{ local temp:4 = rm32; subflags(temp,simm8_32); local diff = temp - simm8_32; resultflags(diff); }
 @ifdef IA64
-:CMP spec_rm64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; spec_rm64 & reg_opcode=7 ...; simm8_64	{ local temp:8 = spec_rm64; subflags(temp,simm8_64); local diff = temp - simm8_64; resultflags(diff); }
+:CMP rm64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; rm64 & reg_opcode=7 ...; simm8_64	{ local temp:8 = rm64; subflags(temp,simm8_64); local diff = temp - simm8_64; resultflags(diff); }
 @endif
 :CMP rm8,Reg8       is vexMode=0 & byte=0x38; rm8 & Reg8 ...                { local temp:1 = rm8; subflags(temp,Reg8); local diff = temp - Reg8; resultflags(diff); }
 :CMP rm16,Reg16     is vexMode=0 & opsize=0 & byte=0x39; rm16 & Reg16 ...       { local temp:2 = rm16; subflags(temp,Reg16); local diff = temp - Reg16; resultflags(diff); }
@@ -3867,37 +3853,37 @@ define pcodeop TaskRegister;
 @endif
 :MOV Rmr8,imm8 is vexMode=0 & byte=0xc6; (mod=3 & Rmr8 & reg_opcode=0); imm8 { Rmr8 = imm8; }
 
-:MOV^xrelease spec_m8,imm8       is vexMode=0 & xrelease & byte=0xc6; spec_m8 & reg_opcode=0 ...; imm8        
+:MOV^xrelease m8,imm8       is vexMode=0 & xrelease & byte=0xc6; m8 & reg_opcode=0 ...; imm8        
 { 
     build xrelease; 
-    build spec_m8; 
-    spec_m8 = imm8;
+    build m8; 
+    m8 = imm8;
 }
 :MOV Rmr16,imm16 is vexMode=0 & opsize=0 & byte=0xc7; (mod=3 & Rmr16 & reg_opcode=0); imm16 { Rmr16 = imm16; }
 
-:MOV^xrelease spec_m16,imm16     is vexMode=0 & xrelease & opsize=0 & byte=0xc7; spec_m16 & reg_opcode=0 ...; imm16 
+:MOV^xrelease m16,imm16     is vexMode=0 & xrelease & opsize=0 & byte=0xc7; m16 & reg_opcode=0 ...; imm16 
 { 
     build xrelease; 
-    build spec_m16; 
-    spec_m16 = imm16;
+    build m16; 
+    m16 = imm16;
 }
 
 :MOV Rmr32,imm32     is vexMode=0 & opsize=1 & byte=0xc7; (mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=0); imm32 { Rmr32 = imm32; build check_Rmr32_dest; }
 
-:MOV^xrelease spec_m32,imm32     is vexMode=0 & xrelease & opsize=1 & byte=0xc7; (spec_m32 & reg_opcode=0 ...); imm32 
+:MOV^xrelease m32,imm32     is vexMode=0 & xrelease & opsize=1 & byte=0xc7; (m32 & reg_opcode=0 ...); imm32 
 { 
     build xrelease; 
-    build spec_m32;
-    spec_m32 = imm32;
+    build m32;
+    m32 = imm32;
 }
 @ifdef IA64
 :MOV Rmr64,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xc7; (mod=3 & Rmr64 & reg_opcode=0); simm32 { Rmr64 = simm32; }
 
-:MOV^xrelease spec_m64,simm32     is $(LONGMODE_ON) & vexMode=0 & xrelease & opsize=2 & byte=0xc7; (spec_m64 & reg_opcode=0 ...); simm32 
+:MOV^xrelease m64,simm32     is $(LONGMODE_ON) & vexMode=0 & xrelease & opsize=2 & byte=0xc7; (m64 & reg_opcode=0 ...); simm32 
 { 
     build xrelease; 
-    build spec_m64;
-    spec_m64 = simm32; 
+    build m64;
+    m64 = simm32; 
 }
 @endif
 
@@ -3978,15 +3964,15 @@ define pcodeop swap_bytes;
 :MOVSQ^rep^reptail eseDI8,dseSI8    is $(LONGMODE_ON) & vexMode=0 & rep & reptail & opsize=2 & byte=0xa5 & eseDI8 & dseSI8   { build rep; build eseDI8; build dseSI8; eseDI8 = dseSI8; build reptail; }
 @endif
 
-:MOVSX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xbe; spec_rm8 & Reg16 ...  { Reg16 = sext(spec_rm8); }
-:MOVSX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xbe; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(spec_rm8); build check_Reg32_dest; }
+:MOVSX Reg16,rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xbe; rm8 & Reg16 ...  { Reg16 = sext(rm8); }
+:MOVSX Reg32,rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xbe; rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(rm8); build check_Reg32_dest; }
 @ifdef IA64
-:MOVSX Reg64,spec_rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbe; spec_rm8 & Reg64 ...  { Reg64 = sext(spec_rm8); }
+:MOVSX Reg64,rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbe; rm8 & Reg64 ...  { Reg64 = sext(rm8); }
 @endif
-:MOVSX Reg16,spec_rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xbf; spec_rm16 & Reg16 ... { Reg16 = spec_rm16; }
-:MOVSX Reg32,spec_rm16   is vexMode=0 & opsize=1 & byte=0xf; byte=0xbf; spec_rm16 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(spec_rm16); build check_Reg32_dest; }
+:MOVSX Reg16,rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xbf; rm16 & Reg16 ... { Reg16 = rm16; }
+:MOVSX Reg32,rm16   is vexMode=0 & opsize=1 & byte=0xf; byte=0xbf; rm16 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(rm16); build check_Reg32_dest; }
 @ifdef IA64
-:MOVSX Reg64,spec_rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbf; spec_rm16 & Reg64 ...     { Reg64 = sext(spec_rm16); }
+:MOVSX Reg64,rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbf; rm16 & Reg64 ...     { Reg64 = sext(rm16); }
 @endif
 
 :MOVSXD Reg32,rm32  is vexMode=0 & bit64=1 & opsize=1 & byte=0x63; rm32 & Reg32 ... & check_Reg32_dest ... { Reg32 = rm32; build check_Reg32_dest; }
@@ -3994,15 +3980,15 @@ define pcodeop swap_bytes;
 :MOVSXD Reg64,rm32  is $(LONGMODE_ON) & vexMode=0 & bit64=1 & opsize=2 & byte=0x63; rm32 & Reg64 ... { Reg64 = sext(rm32); }
 @endif
 
-:MOVZX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb6; spec_rm8 & Reg16 ...  { Reg16 = zext(spec_rm8); }
-:MOVZX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb6; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = zext(spec_rm8); build check_Reg32_dest; }
+:MOVZX Reg16,rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb6; rm8 & Reg16 ...  { Reg16 = zext(rm8); }
+:MOVZX Reg32,rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb6; rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = zext(rm8); build check_Reg32_dest; }
 @ifdef IA64
-:MOVZX Reg64,spec_rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb6; spec_rm8 & Reg64 ...  { Reg64 = zext(spec_rm8); }
+:MOVZX Reg64,rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb6; rm8 & Reg64 ...  { Reg64 = zext(rm8); }
 @endif
-:MOVZX Reg16,spec_rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xb7; spec_rm16 & Reg16 ... { Reg16 = spec_rm16; }
-:MOVZX Reg32,spec_rm16   is vexMode=0 & opsize=1 & byte=0xf; byte=0xb7; spec_rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = zext(spec_rm16); build check_Reg32_dest; }
+:MOVZX Reg16,rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xb7; rm16 & Reg16 ... { Reg16 = rm16; }
+:MOVZX Reg32,rm16   is vexMode=0 & opsize=1 & byte=0xf; byte=0xb7; rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = zext(rm16); build check_Reg32_dest; }
 @ifdef IA64
-:MOVZX Reg64,spec_rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb7; spec_rm16 & Reg64 ...     { Reg64 = zext(spec_rm16); }
+:MOVZX Reg64,rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb7; rm16 & Reg64 ...     { Reg64 = zext(rm16); }
 @endif
 
 :MUL rm8        is vexMode=0 & byte=0xf6; rm8 & reg_opcode=4 ...            { AX=zext(AL)*zext(rm8); multflags(AH); }
@@ -4714,11 +4700,11 @@ define pcodeop skinit;
 @ifdef IA64
 :TEST   RAX,simm32  is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0xA9; RAX & simm32            { logicalflags(); local tmp =  RAX & simm32; resultflags(tmp); }
 @endif
-:TEST  spec_rm8,imm8     is vexMode=0 & byte=0xF6;  spec_rm8 & (reg_opcode=0 | reg_opcode=1) ... ; imm8        { logicalflags(); local tmp =  spec_rm8 & imm8;  resultflags(tmp); }
-:TEST spec_rm16,imm16    is vexMode=0 & opsize=0; byte=0xF7; spec_rm16 & (reg_opcode=0 | reg_opcode=1) ... ; imm16 { logicalflags(); local tmp = spec_rm16 & imm16; resultflags(tmp); }
-:TEST spec_rm32,imm32    is vexMode=0 & opsize=1; byte=0xF7; spec_rm32 & (reg_opcode=0 | reg_opcode=1) ... ; imm32 { logicalflags(); local tmp = spec_rm32 & imm32; resultflags(tmp); }
+:TEST  rm8,imm8     is vexMode=0 & byte=0xF6;  rm8 & (reg_opcode=0 | reg_opcode=1) ... ; imm8        { logicalflags(); local tmp =  rm8 & imm8;  resultflags(tmp); }
+:TEST rm16,imm16    is vexMode=0 & opsize=0; byte=0xF7; rm16 & (reg_opcode=0 | reg_opcode=1) ... ; imm16 { logicalflags(); local tmp = rm16 & imm16; resultflags(tmp); }
+:TEST rm32,imm32    is vexMode=0 & opsize=1; byte=0xF7; rm32 & (reg_opcode=0 | reg_opcode=1) ... ; imm32 { logicalflags(); local tmp = rm32 & imm32; resultflags(tmp); }
 @ifdef IA64
-:TEST spec_rm64,simm32   is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0xF7; spec_rm64 & (reg_opcode=0 | reg_opcode=1) ... ; simm32    { logicalflags(); local tmp = spec_rm64 & simm32; resultflags(tmp); }
+:TEST rm64,simm32   is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0xF7; rm64 & (reg_opcode=0 | reg_opcode=1) ... ; simm32    { logicalflags(); local tmp = rm64 & simm32; resultflags(tmp); }
 @endif
 :TEST  rm8,Reg8     is vexMode=0 & byte=0x84;  rm8 & Reg8  ...              { logicalflags(); local tmp =  rm8 & Reg8;  resultflags(tmp); }
 :TEST rm16,Reg16    is vexMode=0 & opsize=0; byte=0x85; rm16 & Reg16 ...        { logicalflags(); local tmp = rm16 & Reg16; resultflags(tmp); }
@@ -4958,16 +4944,16 @@ define pcodeop f2xm1;
     ST0 = abs(ST0); 
 }
     
-:FADD spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=0 ... & spec_m32 
+:FADD m32fp      is vexMode=0 & byte=0xD8; reg_opcode=0 ... & m32fp 
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f+ float2float(spec_m32); 
+    ST0 = ST0 f+ float2float(m32fp); 
 }
  
-:FADD spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=0 ... & spec_m64            
+:FADD m64fp      is vexMode=0 & byte=0xDC; reg_opcode=0 ... & m64fp            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f+ float2float(spec_m64); 
+    ST0 = ST0 f+ float2float(m64fp); 
 } 
 
 :FADD ST0, freg     is vexMode=0 & byte=0xD8; frow=12 & fpage=0 & freg & ST0        
@@ -4996,31 +4982,31 @@ define pcodeop f2xm1;
     fpop();
 }    
 
-:FIADD spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=0 ... & spec_m32            
+:FIADD m32     is vexMode=0 & byte=0xDA; reg_opcode=0 ... & m32            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f+ int2float(spec_m32); 
+    ST0 = ST0 f+ int2float(m32); 
 }   
 
-:FIADD spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=0 ... & spec_m16            
+:FIADD m16     is vexMode=0 & byte=0xDE; reg_opcode=0 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f+ int2float(spec_m16); 
+    ST0 = ST0 f+ int2float(m16); 
 }   
 
 define pcodeop from_bcd;
-:FBLD  spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=4 ... & spec_m80            
+:FBLD  m80     is vexMode=0 & byte=0xDF; reg_opcode=4 ... & m80            
 { 
     FPUInstructionPointer = inst_start;
     fdec(); 
-    ST0 = from_bcd(spec_m80); 
+    ST0 = from_bcd(m80); 
 }
 
 define pcodeop to_bcd;
-:FBSTP spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=6 ... & spec_m80            
+:FBSTP m80     is vexMode=0 & byte=0xDF; reg_opcode=6 ... & m80            
 { 
     FPUInstructionPointer = inst_start;
-    spec_m80 = to_bcd(ST0); 
+    m80 = to_bcd(ST0); 
     fpop(); 
 }
 
@@ -5097,17 +5083,17 @@ define pcodeop to_bcd;
     ST0 = freg; 
 }    
                                                                  
-:FCOM spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & spec_m32            
+:FCOM m32fp       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & m32fp            
 {
     FPUInstructionPointer = inst_start; 
-    local tmp=float2float(spec_m32); 
+    local tmp=float2float(m32fp); 
     fcom(tmp); 
 }         
 
-:FCOM spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & spec_m64            
+:FCOM m64fp       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & m64fp            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp=float2float(spec_m64); 
+    local tmp=float2float(m64fp); 
     fcom(tmp); 
 }         
 
@@ -5123,18 +5109,18 @@ define pcodeop to_bcd;
     fcom(ST1);
 }                   
 
-:FCOMP spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=3 ... & spec_m32            
+:FCOMP m32fp      is vexMode=0 & byte=0xD8; reg_opcode=3 ... & m32fp            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp=float2float(spec_m32); 
+    local tmp=float2float(m32fp); 
     fcom(tmp); 
     fpop(); 
 }     
 
-:FCOMP spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=3 ... & spec_m64            
+:FCOMP m64fp      is vexMode=0 & byte=0xDC; reg_opcode=3 ... & m64fp            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp=float2float(spec_m64); 
+    local tmp=float2float(m64fp); 
     fcom(tmp); 
     fpop(); 
 }     
@@ -5208,16 +5194,16 @@ define pcodeop fcos;
 :FENI               is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE0 {}
 :FNENI              is vexMode=0 & byte=0xDB; byte=0xE0            {}
 
-:FDIV spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=6 ... & spec_m32            
+:FDIV m32fp      is vexMode=0 & byte=0xD8; reg_opcode=6 ... & m32fp            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f/ float2float(spec_m32); 
+    ST0 = ST0 f/ float2float(m32fp); 
 }    
 
-:FDIV spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=6 ... & spec_m64            
+:FDIV m64fp      is vexMode=0 & byte=0xDC; reg_opcode=6 ... & m64fp            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f/ float2float(spec_m64); 
+    ST0 = ST0 f/ float2float(m64fp); 
 }    
 
 :FDIV ST0,freg      is vexMode=0 & byte=0xD8; frow=15 & fpage=0 & freg & ST0        
@@ -5246,28 +5232,28 @@ define pcodeop fcos;
     fpop();
 }         
 
-:FIDIV spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=6 ... & spec_m32            
+:FIDIV m32     is vexMode=0 & byte=0xDA; reg_opcode=6 ... & m32            
 { 
     FPUInstructionPointer = inst_start; 
-    ST0 = ST0 f/ int2float(spec_m32); 
+    ST0 = ST0 f/ int2float(m32); 
 }      
 
-:FIDIV spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=6 ... & spec_m16            
+:FIDIV m16     is vexMode=0 & byte=0xDE; reg_opcode=6 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f/ int2float(spec_m16); 
+    ST0 = ST0 f/ int2float(m16); 
 }      
                                                               
-:FDIVR spec_m32     is vexMode=0 & byte=0xD8; reg_opcode=7 ... & spec_m32 
+:FDIVR m32fp     is vexMode=0 & byte=0xD8; reg_opcode=7 ... & m32fp 
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = float2float(spec_m32) f/ ST0; 
+    ST0 = float2float(m32fp) f/ ST0; 
 }    
 
-:FDIVR spec_m64     is vexMode=0 & byte=0xDC; reg_opcode=7 ... & spec_m64            
+:FDIVR m64fp     is vexMode=0 & byte=0xDC; reg_opcode=7 ... & m64fp            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = float2float(spec_m64) f/ ST0; 
+    ST0 = float2float(m64fp) f/ ST0; 
 }    
 
 :FDIVR ST0,freg     is vexMode=0 & byte=0xD8; frow=15 & fpage=1 & freg & ST0        
@@ -5296,16 +5282,16 @@ define pcodeop fcos;
     fpop();
 }         
 
-:FIDIVR spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=7 ... & spec_m32 
+:FIDIVR m32    is vexMode=0 & byte=0xDA; reg_opcode=7 ... & m32 
 {
     FPUInstructionPointer = inst_start;
-    ST0 = int2float(spec_m32) f/ ST0; 
+    ST0 = int2float(m32) f/ ST0; 
 }      
 
-:FIDIVR spec_m16    is vexMode=0 & byte=0xDE; reg_opcode=7 ... & spec_m16            
+:FIDIVR m16    is vexMode=0 & byte=0xDE; reg_opcode=7 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = int2float(spec_m16) f/ ST0; 
+    ST0 = int2float(m16) f/ ST0; 
 }      
 
 define pcodeop ffree;
@@ -5322,54 +5308,54 @@ define pcodeop ffree;
     fpop();   # FFREE and pop
 }
                                                                   
-:FICOM spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & spec_m16            
+:FICOM m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp = int2float(spec_m16); 
+    local tmp = int2float(m16); 
     fcom(tmp); 
 }          
 
-:FICOM spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=2 ... & spec_m32            
+:FICOM m32     is vexMode=0 & byte=0xDA; reg_opcode=2 ... & m32            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp = int2float(spec_m32); 
+    local tmp = int2float(m32); 
     fcom(tmp);
 }          
 
-:FICOMP spec_m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & spec_m16            
+:FICOMP m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    local tmp = int2float(spec_m16); 
+    local tmp = int2float(m16); 
     fcom(tmp); 
     fpop(); 
 }  
 
-:FICOMP spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=3 ... & spec_m32       
+:FICOMP m32    is vexMode=0 & byte=0xDA; reg_opcode=3 ... & m32       
 {
     FPUInstructionPointer = inst_start;
-    local tmp = int2float(spec_m32); 
+    local tmp = int2float(m32); 
     fcom(tmp); 
     fpop(); 
 }  
                                                                   
-:FILD spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=0 ... & spec_m16           
+:FILD m16      is vexMode=0 & byte=0xDF; reg_opcode=0 ... & m16           
 { 
     FPUInstructionPointer = inst_start;
-    fdec(); ST0 = int2float(spec_m16); 
+    fdec(); ST0 = int2float(m16); 
 }         
 
-:FILD spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=0 ... & spec_m32
+:FILD m32      is vexMode=0 & byte=0xDB; reg_opcode=0 ... & m32
 { 
     FPUInstructionPointer = inst_start;
     fdec(); 
-    ST0 = int2float(spec_m32); 
+    ST0 = int2float(m32); 
 }         
 
-:FILD spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=5 ... & spec_m64
+:FILD m64      is vexMode=0 & byte=0xDF; reg_opcode=5 ... & m64
 { 
     FPUInstructionPointer = inst_start;
     fdec(); 
-    ST0 = int2float(spec_m64); 
+    ST0 = int2float(m64); 
 }         
                                                                   
 :FINCSTP            is vexMode=0 & byte=0xD9; byte=0xF7                 
@@ -5406,83 +5392,83 @@ define pcodeop ffree;
     C3 = 0; 
 }          
 
-:FIST spec_m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & spec_m16            
+:FIST m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & m16            
 { 
     FPUInstructionPointer = inst_start;
     tmp:10 = round(ST0);
-    spec_m16 = trunc(tmp); 
+    m16 = trunc(tmp); 
 }                    
 
-:FIST spec_m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & spec_m32            
+:FIST m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & m32            
 { 
     FPUInstructionPointer = inst_start;
     tmp:10 = round(ST0); 
-    spec_m32 = trunc(tmp); 
+    m32 = trunc(tmp); 
 }            
 
-:FISTP spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=3 ... & spec_m16            
+:FISTP m16      is vexMode=0 & byte=0xDF; reg_opcode=3 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
     tmp:10 = round(ST0); 
     fpop(); 
-    spec_m16 = trunc(tmp); 
+    m16 = trunc(tmp); 
 }                
 
-:FISTP spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=3 ... & spec_m32
+:FISTP m32      is vexMode=0 & byte=0xDB; reg_opcode=3 ... & m32
 { 
     FPUInstructionPointer = inst_start;
     tmp:10 = round(ST0);
     fpop();
-    spec_m32 = trunc(tmp); 
+    m32 = trunc(tmp); 
 }                
 
-:FISTP spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=7 ... & spec_m64  
+:FISTP m64      is vexMode=0 & byte=0xDF; reg_opcode=7 ... & m64  
 {
     FPUInstructionPointer = inst_start;
     tmp:10 = round(ST0); 
     fpop(); 
-    spec_m64 = trunc(tmp); 
+    m64 = trunc(tmp); 
 }                
 
-:FISTTP spec_m16     is vexMode=0 & byte=0xDF; reg_opcode=1 ... & spec_m16 
+:FISTTP m16     is vexMode=0 & byte=0xDF; reg_opcode=1 ... & m16 
 { 
     FPUInstructionPointer = inst_start;
-    spec_m16 = trunc(ST0); 
+    m16 = trunc(ST0); 
     fpop();
 }                 
 
-:FISTTP spec_m32     is vexMode=0 & byte=0xDB; reg_opcode=1 ... & spec_m32 
+:FISTTP m32     is vexMode=0 & byte=0xDB; reg_opcode=1 ... & m32 
 { 
     FPUInstructionPointer = inst_start;
-    spec_m32 = trunc(ST0); 
+    m32 = trunc(ST0); 
     fpop(); 
 }
                  
-:FISTTP spec_m64     is vexMode=0 & byte=0xDD; reg_opcode=1 ... & spec_m64
+:FISTTP m64     is vexMode=0 & byte=0xDD; reg_opcode=1 ... & m64
 { 
     FPUInstructionPointer = inst_start;
-    spec_m64 = trunc(ST0); 
+    m64 = trunc(ST0); 
     fpop(); 
 }                 
                                                                       
-:FLD spec_m32        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & spec_m32            
+:FLD m32fp        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & m32fp            
 { 
     FPUInstructionPointer = inst_start;
     fdec();
-    ST0 = float2float(spec_m32); 
+    ST0 = float2float(m32fp); 
 }           
 
-:FLD spec_m64        is vexMode=0 & byte=0xDD; reg_opcode=0 ... & spec_m64
+:FLD m64fp        is vexMode=0 & byte=0xDD; reg_opcode=0 ... & m64fp
 {
     FPUInstructionPointer = inst_start;
     fdec(); 
-    ST0 = float2float(spec_m64);
+    ST0 = float2float(m64fp);
 }            
 
-:FLD spec_m80        is vexMode=0 & byte=0xDB; reg_opcode=5 ... & spec_m80
+:FLD m80fp        is vexMode=0 & byte=0xDB; reg_opcode=5 ... & m80fp
 {
     FPUInstructionPointer = inst_start;
-    fpushv(spec_m80); 
+    fpushv(m80fp); 
 }                      
 
 # Be careful that you don't clobber freg during fpushv, need a tmp to hold the value
@@ -5560,15 +5546,15 @@ define pcodeop fldenv;
   FPULastInstructionOpcode = *:2 (Mem + 18);
 }
 
-:FMUL spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=1 ... & spec_m32
+:FMUL m32fp       is vexMode=0 & byte=0xD8; reg_opcode=1 ... & m32fp
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f* float2float(spec_m32); 
+    ST0 = ST0 f* float2float(m32fp); 
 }  
 
-:FMUL spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=1 ... & spec_m64            
+:FMUL m64fp       is vexMode=0 & byte=0xDC; reg_opcode=1 ... & m64fp            
 { 
-    ST0 = ST0 f* float2float(spec_m64); 
+    ST0 = ST0 f* float2float(m64fp); 
     FPUInstructionPointer = inst_start;
 }  
 
@@ -5598,16 +5584,16 @@ define pcodeop fldenv;
     fpop(); 
 }       
 
-:FIMUL spec_m32      is vexMode=0 & byte=0xDA; reg_opcode=1 ... & spec_m32            
+:FIMUL m32      is vexMode=0 & byte=0xDA; reg_opcode=1 ... & m32            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f* int2float(spec_m32); 
+    ST0 = ST0 f* int2float(m32); 
 }    
 
-:FIMUL spec_m16      is vexMode=0 & byte=0xDE; reg_opcode=1 ... & spec_m16            
+:FIMUL m16      is vexMode=0 & byte=0xDE; reg_opcode=1 ... & m16            
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f* int2float(spec_m16); 
+    ST0 = ST0 f* int2float(m16); 
 }    
 
 :FNOP           is vexMode=0 & byte=0xD9; byte=0xD0                 
@@ -5755,16 +5741,16 @@ define pcodeop fsin;
     ST0 = sqrt(ST0); 
 }
 
-:FST spec_m32   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & spec_m32            
+:FST m32fp   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & m32fp            
 { 
     FPUInstructionPointer = inst_start;
-    spec_m32 = float2float(ST0); 
+    m32fp = float2float(ST0); 
 }     
 
-:FST spec_m64   is vexMode=0 & byte=0xDD; reg_opcode=2 ... & spec_m64 
+:FST m64fp   is vexMode=0 & byte=0xDD; reg_opcode=2 ... & m64fp 
 { 
     FPUInstructionPointer = inst_start;
-    spec_m64 = float2float(ST0); 
+    m64fp = float2float(ST0); 
 }     
 
 :FST freg       is vexMode=0 & byte=0xDD; frow=13 & fpage=0 & freg          
@@ -5773,24 +5759,24 @@ define pcodeop fsin;
     freg = ST0; 
 }             
 
-:FSTP spec_m32  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & spec_m32 
+:FSTP m32fp  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & m32fp 
 {
     FPUInstructionPointer = inst_start;
-    spec_m32 = float2float(ST0); 
+    m32fp = float2float(ST0); 
     fpop();
 } 
 
-:FSTP spec_m64  is vexMode=0 & byte=0xDD; reg_opcode=3 ... & spec_m64 
+:FSTP m64fp  is vexMode=0 & byte=0xDD; reg_opcode=3 ... & m64fp 
 { 
     FPUInstructionPointer = inst_start;
-    spec_m64 = float2float(ST0); 
+    m64fp = float2float(ST0); 
     fpop();
 } 
 
-:FSTP spec_m80  is vexMode=0 & byte=0xDB; reg_opcode=7 ... & spec_m80
+:FSTP m80fp  is vexMode=0 & byte=0xDB; reg_opcode=7 ... & m80fp
 {
     FPUInstructionPointer = inst_start;
-    fpopv(spec_m80); 
+    fpopv(m80fp); 
 }             
 
 :FSTP freg      is vexMode=0 & byte=0xDD; frow=13 & fpage=1 & freg 
@@ -5849,16 +5835,16 @@ define pcodeop fsin;
     AX = FPUStatusWord; 
 }
 
-:FSUB spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=4 ... & spec_m32  
+:FSUB m32fp  is vexMode=0 & byte=0xD8; reg_opcode=4 ... & m32fp  
 {
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f- float2float(spec_m32); 
+    ST0 = ST0 f- float2float(m32fp); 
 }          
 
-:FSUB spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=4 ... & spec_m64            
+:FSUB m64fp  is vexMode=0 & byte=0xDC; reg_opcode=4 ... & m64fp            
 {
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f- float2float(spec_m64); 
+    ST0 = ST0 f- float2float(m64fp); 
 }          
 
 :FSUB ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=0 & freg & ST0   
@@ -5887,28 +5873,28 @@ define pcodeop fsin;
     fpop(); 
 }             
 
-:FISUB spec_m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & spec_m32 
+:FISUB m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & m32 
 {
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f- int2float(spec_m32); 
+    ST0 = ST0 f- int2float(m32); 
 }            
 
-:FISUB spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=4 ... & spec_m16 
+:FISUB m16 is vexMode=0 & byte=0xDE; reg_opcode=4 ... & m16 
 {
     FPUInstructionPointer = inst_start;
-    ST0 = ST0 f- int2float(spec_m16); 
+    ST0 = ST0 f- int2float(m16); 
 }            
                                                                     
-:FSUBR spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=5 ... & spec_m32   
+:FSUBR m32fp  is vexMode=0 & byte=0xD8; reg_opcode=5 ... & m32fp   
 {
     FPUInstructionPointer = inst_start;
-    ST0 = float2float(spec_m32) f- ST0; 
+    ST0 = float2float(m32fp) f- ST0; 
 }          
 
-:FSUBR spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=5 ... & spec_m64 
+:FSUBR m64fp  is vexMode=0 & byte=0xDC; reg_opcode=5 ... & m64fp 
 {
     FPUInstructionPointer = inst_start;
-    ST0 = float2float(spec_m64) f- ST0; 
+    ST0 = float2float(m64fp) f- ST0; 
 }          
 
 :FSUBR ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=1 & freg & ST0 
@@ -5935,16 +5921,16 @@ define pcodeop fsin;
     freg = ST0 f- freg; fpop(); 
 }             
 
-:FISUBR spec_m32 is vexMode=0 & byte=0xDA; reg_opcode=5 ... & spec_m32  
+:FISUBR m32 is vexMode=0 & byte=0xDA; reg_opcode=5 ... & m32  
 {
     FPUInstructionPointer = inst_start;
-    ST0 = int2float(spec_m32) f- ST0; 
+    ST0 = int2float(m32) f- ST0; 
 }            
 
-:FISUBR spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=5 ... & spec_m16           
+:FISUBR m16 is vexMode=0 & byte=0xDE; reg_opcode=5 ... & m16           
 { 
     FPUInstructionPointer = inst_start;
-    ST0 = int2float(spec_m16) f- ST0; 
+    ST0 = int2float(m16) f- ST0; 
 }            
                                                                     
 :FTST           is vexMode=0 & byte=0xD9; byte=0xE4                 
diff --git a/Ghidra/Processors/x86/data/languages/lockable.sinc b/Ghidra/Processors/x86/data/languages/lockable.sinc
index 746170bf6ba..9f8e7c7baa5 100644
--- a/Ghidra/Processors/x86/data/languages/lockable.sinc
+++ b/Ghidra/Processors/x86/data/languages/lockable.sinc
@@ -4,69 +4,69 @@
 #     is used with any instruction not in the above list.
 # The instructions in this file have their non-lockable counterparts in ia.sinc
 
-:ADC^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=2 ... ; imm8 
+:ADC^lockx m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=2 ... ; imm8 
 { 
     build lockx; 
-    build spec_m8;
-    addCarryFlags( spec_m8, imm8:1 ); 
-    resultflags( spec_m8 );
+    build m8;
+    addCarryFlags(m8, imm8:1); 
+    resultflags(m8);
     build unlock;
 }
 
-:ADC^lockx spec_m16,imm16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=2 ...; imm16 
+:ADC^lockx m16,imm16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=2 ...; imm16 
 {    
     build lockx;
-    build spec_m16;
-    addCarryFlags( spec_m16, imm16:2 );
-    resultflags( spec_m16 );
+    build m16;
+    addCarryFlags(m16, imm16:2);
+    resultflags(m16);
     build unlock; 
 }
 
-:ADC^lockx spec_m32,imm32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=2 ...; imm32 
+:ADC^lockx m32,imm32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=2 ...; imm32 
 {    
     build lockx;
-    build spec_m32;
-    addCarryFlags( spec_m32, imm32:4 );
-    resultflags( spec_m32 );
+    build m32;
+    addCarryFlags(m32, imm32:4);
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:ADC^lockx spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=2 ...; simm32 
+:ADC^lockx m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=2 ...; simm32 
 {    
     build lockx;
-    build spec_m64;
-    addCarryFlags( spec_m64, simm32 );
-    resultflags( spec_m64 );
+    build m64;
+    addCarryFlags(m64,simm32);
+    resultflags(m64);
     build unlock; 
 }
 @endif
 
-:ADC^lockx spec_m16,simm8_16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=2 ...; simm8_16	
+:ADC^lockx m16,simm8_16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=2 ...; simm8_16	
 {
     build lockx; 
-    build spec_m16;
-    addCarryFlags( spec_m16, simm8_16 );
-    resultflags( spec_m16 );
+    build m16;
+    addCarryFlags(m16,simm8_16);
+    resultflags(m16);
     build unlock; 
 }
 
-:ADC^lockx spec_m32,simm8_32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=2 ...; simm8_32 
+:ADC^lockx m32,simm8_32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=2 ...; simm8_32 
 {
     build lockx;
-    build spec_m32;
-    addCarryFlags( spec_m32, simm8_32 );
-    resultflags( spec_m32 );
+    build m32;
+    addCarryFlags(m32,simm8_32);
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:ADC^lockx spec_m64,simm8_64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=2 ...; simm8_64 
+:ADC^lockx m64,simm8_64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=2 ...; simm8_64 
 {
     build lockx;
-    build spec_m64;
-    addCarryFlags( spec_m64, simm8_64 );
-    resultflags( spec_m64 );
+    build m64;
+    addCarryFlags(m64,simm8_64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -75,8 +75,8 @@
 {
     build lockx;
     build m8;
-    addCarryFlags( m8, Reg8 );
-    resultflags( m8 );
+    addCarryFlags(m8, Reg8);
+    resultflags(m8);
     build unlock;
 }
 
@@ -84,8 +84,8 @@
 {
     build lockx;
     build m16;
-    addCarryFlags( m16, Reg16 );
-    resultflags( m16 );
+    addCarryFlags(m16, Reg16);
+    resultflags(m16);
     build unlock;
 }
 
@@ -93,8 +93,8 @@
 {
     build lockx;
     build m32;
-    addCarryFlags( m32, Reg32 );
-    resultflags( m32 );
+    addCarryFlags(m32, Reg32);
+    resultflags(m32);
     build unlock;
 }
 
@@ -103,82 +103,82 @@
 {
     build lockx;
     build m64;
-    addCarryFlags( m64, Reg64 );
-    resultflags( m64 );
+    addCarryFlags(m64, Reg64);
+    resultflags(m64);
     build unlock;
 }
 @endif
 
-:ADD^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=0 ...; imm8		
+:ADD^lockx m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=0 ...; imm8		
 {
     build lockx;
-    build spec_m8;
-    addflags( spec_m8,imm8 );
-    spec_m8 =   spec_m8 +  imm8;
-    resultflags(  spec_m8);
+    build m8;
+    addflags(m8,imm8);
+    m8 = m8 + imm8;
+    resultflags(m8);
     build unlock;
 }
 
-:ADD^lockx spec_m16,imm16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=0 ...; imm16	
+:ADD^lockx m16,imm16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=0 ...; imm16	
 {
     build lockx;
-    build spec_m16;
-    addflags( spec_m16,imm16);
-    spec_m16 =  spec_m16 + imm16;
-    resultflags( spec_m16);
+    build m16;
+    addflags(m16,imm16);
+    m16 = m16 + imm16;
+    resultflags(m16);
     build unlock;
 }
 
-:ADD^lockx spec_m32,imm32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=0 ...; imm32	
+:ADD^lockx m32,imm32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=0 ...; imm32	
 {
     build lockx;
-    build spec_m32;
-    addflags( spec_m32,imm32);
-    spec_m32 =  spec_m32 + imm32;
-    resultflags( spec_m32);
+    build m32;
+    addflags(m32,imm32);
+    m32 = m32 + imm32;
+    resultflags(m32);
     build unlock;
 }
 
 @ifdef IA64
-:ADD^lockx spec_m64,simm32		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=0 ...; simm32	
+:ADD^lockx m64,simm32		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=0 ...; simm32	
 {
     build lockx;
-    build spec_m64;
-    addflags( spec_m64,simm32);
-    spec_m64 =  spec_m64 + simm32;
-    resultflags( spec_m64);
+    build m64;
+    addflags(m64,simm32);
+    m64 = m64 + simm32;
+    resultflags(m64);
     build unlock;
 }
 @endif
 
-:ADD^lockx spec_m16,simm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=0 ...; simm8_16	
+:ADD^lockx m16,simm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=0 ...; simm8_16	
 {
     build lockx;
-    build spec_m16;
-    addflags( spec_m16,simm8_16);
-    spec_m16 =  spec_m16 + simm8_16;
-    resultflags( spec_m16);
+    build m16;
+    addflags(m16,simm8_16);
+    m16 =  m16 + simm8_16;
+    resultflags(m16);
     build unlock;
 }
 
-:ADD^lockx spec_m32,simm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=0 ...; simm8_32	
+:ADD^lockx m32,simm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=0 ...; simm8_32	
 {
     build lockx;
-    build spec_m32;
-    addflags( spec_m32,simm8_32);
-    spec_m32 =  spec_m32 + simm8_32;
-    resultflags( spec_m32);
+    build m32;
+    addflags(m32,simm8_32);
+    m32 = m32 + simm8_32;
+    resultflags(m32);
     build unlock;
 }
 
 @ifdef IA64
-:ADD^lockx spec_m64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=0 ...; simm8_64	
+:ADD^lockx m64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=0 ...; simm8_64	
 {
     build lockx;
-    build spec_m64;
-    addflags( spec_m64,simm8_64);
-    spec_m64 =  spec_m64 + simm8_64;
-    resultflags( spec_m64);
+    build m64;
+    addflags(m64,simm8_64);
+    m64 = m64 + simm8_64;
+    resultflags(m64);
     build unlock;
 }
 @endif
@@ -187,9 +187,9 @@
 {
     build lockx;
     build m8;
-    addflags(  m8,Reg8 );
-    m8 =   m8 +  Reg8;
-    resultflags(  m8);
+    addflags(m8,Reg8);
+    m8 = m8 + Reg8;
+    resultflags(m8);
     build unlock;
 }
 
@@ -197,9 +197,9 @@
 {
     build lockx;
     build m16;
-    addflags( m16,Reg16);
+    addflags(m16,Reg16);
     m16 =  m16 + Reg16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock;
 }
 
@@ -207,9 +207,9 @@
 {
     build lockx;
     build m32;
-    addflags( m32,Reg32);
+    addflags(m32,Reg32);
     m32 =  m32 + Reg32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock;
 }
 
@@ -218,9 +218,9 @@
 {
     build lockx;
     build m64;
-    addflags( m64,Reg64);
+    addflags(m64,Reg64);
     m64 =  m64 + Reg64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock;
 }
 @endif
@@ -230,8 +230,8 @@
     build lockx;
     build m8;
     logicalflags();
-    m8 =   m8 &  imm8;
-    resultflags(  m8);
+    m8 = m8 & imm8;
+    resultflags(m8);
     build unlock;
 }
 
@@ -241,7 +241,7 @@
     build m16;
     logicalflags();
     m16 =  m16 & imm16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock;
 }
 
@@ -251,7 +251,7 @@
     build m32;
     logicalflags();
     m32 =  m32 & imm32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock;
 }
 
@@ -262,7 +262,7 @@
     build m64;
     logicalflags();
     m64 =  m64 & simm32;
-    resultflags( m64);
+    resultflags(m64);
     build unlock;
 }
 @endif
@@ -273,7 +273,7 @@
     build m16;
     logicalflags();
     m16 =  m16 & usimm8_16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock;
 }
 
@@ -283,7 +283,7 @@
     build m32;
     logicalflags();
     m32 =  m32 & usimm8_32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock; 
 }
 
@@ -294,7 +294,7 @@
     build m64;
     logicalflags();
     m64 =  m64 & usimm8_64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -304,8 +304,8 @@
     build lockx;
     build m8;
     logicalflags();
-    m8 =   m8 &  Reg8;
-    resultflags(  m8);
+    m8 = m8 & Reg8;
+    resultflags(m8);
     build unlock; 
 }
 
@@ -315,7 +315,7 @@
     build m16;
     logicalflags();
     m16 =  m16 & Reg16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock; 
 }
 
@@ -325,7 +325,7 @@
     build m32;
     logicalflags();
     m32 =  m32 & Reg32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock; 
 }
 
@@ -336,7 +336,7 @@
     build m64;
     logicalflags();
     m64 =  m64 & Reg64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -674,86 +674,86 @@
 }
 @endif
 
-:DEC^lockx spec_m8       is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 & reg_opcode=1 ...         
+:DEC^lockx m8       is vexMode=0 & lockx & unlock & byte=0xfe; m8 & reg_opcode=1 ...         
 {
     build lockx;
-    build spec_m8;
-    OF = sborrow(spec_m8,1);
-    spec_m8 =  spec_m8 - 1;
-    resultflags( spec_m8);
+    build m8;
+    OF = sborrow(m8,1);
+    m8 =  m8 - 1;
+    resultflags(m8);
     build unlock; 
 }
 
-:DEC^lockx spec_m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 & reg_opcode=1 ... 
+:DEC^lockx m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; m16 & reg_opcode=1 ... 
 {
     build lockx;
-    build spec_m16;
-    OF = sborrow(spec_m16,1);
-    spec_m16 = spec_m16 - 1;
-    resultflags(spec_m16);
+    build m16;
+    OF = sborrow(m16,1);
+    m16 = m16 - 1;
+    resultflags(m16);
     build unlock; 
 }
 
-:DEC^lockx spec_m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 & reg_opcode=1 ... 
+:DEC^lockx m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; m32 & reg_opcode=1 ... 
 {
     build lockx;
-    build spec_m32;
-    OF = sborrow(spec_m32,1);
-    spec_m32 = spec_m32 - 1;
-    resultflags(spec_m32);
+    build m32;
+    OF = sborrow(m32,1);
+    m32 = m32 - 1;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:DEC^lockx spec_m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 & reg_opcode=1 ... 
+:DEC^lockx m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; m64 & reg_opcode=1 ... 
 {
     build lockx;
-    build spec_m64;
-    OF = sborrow(spec_m64,1);
-    spec_m64 = spec_m64 - 1;
-    resultflags(spec_m64);
+    build m64;
+    OF = sborrow(m64,1);
+    m64 = m64 - 1;
+    resultflags(m64);
     build unlock; 
 }
 @endif
 
-:INC^lockx  spec_m8	is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 ...				
+:INC^lockx  m8	is vexMode=0 & lockx & unlock & byte=0xfe; m8 ...				
 {
     build lockx;
-    build spec_m8;
-    OF = scarry(spec_m8,1);
-    spec_m8 =  spec_m8 + 1;
-    resultflags( spec_m8);
+    build m8;
+    OF = scarry(m8,1);
+    m8 =  m8 + 1;
+    resultflags( m8);
     build unlock; 
 }
 
-:INC^lockx spec_m16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 ...	
+:INC^lockx m16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; m16 ...	
 {
     build lockx;
-    build spec_m16;
-    OF = scarry(spec_m16,1);
-    spec_m16 = spec_m16 + 1;
-    resultflags(spec_m16);
+    build m16;
+    OF = scarry(m16,1);
+    m16 = m16 + 1;
+    resultflags(m16);
     build unlock; 
 }
 
-:INC^lockx spec_m32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 ...	
+:INC^lockx m32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; m32 ...	
 {
     build lockx;
-    build spec_m32;
-    OF = scarry(spec_m32,1);
-    spec_m32 = spec_m32 + 1;
-    resultflags(spec_m32);
+    build m32;
+    OF = scarry(m32,1);
+    m32 = m32 + 1;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:INC^lockx spec_m64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 ... 
+:INC^lockx m64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; m64 ... 
 {
     build lockx;
-    build spec_m64;
-    OF = scarry(spec_m64,1);
-    spec_m64 = spec_m64 + 1;
-    resultflags(spec_m64);
+    build m64;
+    OF = scarry(m64,1);
+    m64 = m64 + 1;
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -764,7 +764,7 @@
     build m8;
     negflags(m8);
     m8 =  -m8;
-    resultflags(m8 );
+    resultflags(m8);
     build unlock; 
 }
 
@@ -834,77 +834,77 @@
 }
 @endif
 
-:OR^lockx  spec_m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=1 ...; imm8     
+:OR^lockx  m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=1 ...; imm8     
 {
     build lockx;
-    build spec_m8;
+    build m8;
     logicalflags();
-    spec_m8 =   spec_m8 |  imm8;
-    resultflags(  spec_m8);
+    m8 = m8 | imm8;
+    resultflags(m8);
     build unlock; 
 }
 
-:OR^lockx  spec_m16,imm16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=1 ...; imm16  
+:OR^lockx  m16,imm16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=1 ...; imm16  
 {
     build lockx;
-    build spec_m16;
+    build m16;
     logicalflags();
-    spec_m16 =  spec_m16 | imm16;
-    resultflags( spec_m16);
+    m16 = m16 | imm16;
+    resultflags(m16);
     build unlock; 
 }
 
-:OR^lockx  spec_m32,imm32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=1 ...; imm32  
+:OR^lockx  m32,imm32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=1 ...; imm32  
 {
     build lockx;
-    build spec_m32;
+    build m32;
     logicalflags();
-    spec_m32 =  spec_m32 | imm32;
-    resultflags( spec_m32);
+    m32 = m32 | imm32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:OR^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=1 ...; simm32 
+:OR^lockx  m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=1 ...; simm32 
 {
     build lockx;
-    build spec_m64;
+    build m64;
     logicalflags();
-    tmp:8 = spec_m64;
-    spec_m64 =  tmp | simm32;
-    resultflags( spec_m64);
+    tmp:8 = m64;
+    m64 = tmp | simm32;
+    resultflags(m64);
     build unlock; 
 }
 @endif
 
-:OR^lockx  spec_m16,usimm8_16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=1 ...; usimm8_16  
+:OR^lockx m16,usimm8_16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=1 ...; usimm8_16  
 {
     build lockx;
-    build spec_m16;
+    build m16;
     logicalflags();
-    spec_m16 =  spec_m16 | usimm8_16;
-    resultflags( spec_m16);
+    m16 = m16 | usimm8_16;
+    resultflags(m16);
     build unlock; 
 }
 
-:OR^lockx  spec_m32,usimm8_32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=1 ...; usimm8_32  
+:OR^lockx  m32,usimm8_32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=1 ...; usimm8_32  
 {
     build lockx;
-    build spec_m32;
+    build m32;
     logicalflags();
-    spec_m32 =  spec_m32 | usimm8_32;
-    resultflags( spec_m32);
+    m32 = m32 | usimm8_32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:OR^lockx  spec_m64,usimm8_64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=1 ...; usimm8_64  
+:OR^lockx  m64,usimm8_64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=1 ...; usimm8_64  
 {
     build lockx;
-    build spec_m64;
+    build m64;
     logicalflags();
-    spec_m64 =  spec_m64 | usimm8_64;
-    resultflags( spec_m64);
+    m64 = m64 | usimm8_64;
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -914,8 +914,8 @@
     build lockx;
     build m8;
     logicalflags();
-    m8 =   m8 |  Reg8;
-    resultflags(  m8);
+    m8 = m8 | Reg8;
+    resultflags(m8);
     build unlock; 
 }
 
@@ -925,7 +925,7 @@
     build m16;
     logicalflags();
     m16 =  m16 | Reg16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock; 
 }
 
@@ -935,7 +935,7 @@
     build m32;
     logicalflags();
     m32 =  m32 | Reg32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock; 
 }
 
@@ -946,7 +946,7 @@
     build m64;
     logicalflags();
     m64 =  m64 | Reg64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -955,7 +955,7 @@
 {
     build lockx;
     build m8;
-    subCarryFlags( m8, imm8 );
+    subCarryFlags(m8, imm8);
     resultflags(m8);
     build unlock; 
 }
@@ -964,7 +964,7 @@
 {
     build lockx;
     build m16;
-    subCarryFlags( m16, imm16 );
+    subCarryFlags(m16, imm16);
     resultflags(m16);
     build unlock; 
 }
@@ -973,7 +973,7 @@
 {
     build lockx;
     build m32;
-    subCarryFlags( m32, imm32 );
+    subCarryFlags(m32, imm32);
     resultflags(m32);
     build unlock; 
 }
@@ -983,7 +983,7 @@
 {
     build lockx;
     build m64;
-    subCarryFlags( m64, simm32 );
+    subCarryFlags(m64, simm32);
     resultflags(m64);
     build unlock; 
 }
@@ -993,7 +993,7 @@
 {
     build lockx;
     build m16;
-    subCarryFlags( m16, simm8_16 );
+    subCarryFlags(m16, simm8_16);
     resultflags(m16);
     build unlock; 
 }
@@ -1002,7 +1002,7 @@
 {
     build lockx;
     build m32;
-    subCarryFlags( m32, simm8_32 );
+    subCarryFlags(m32, simm8_32);
     resultflags(m32);
     build unlock; 
 }
@@ -1012,7 +1012,7 @@
 {
     build lockx;
     build m64;
-    subCarryFlags( m64, simm8_64 );
+    subCarryFlags(m64, simm8_64);
     resultflags(m64);
     build unlock; 
 }
@@ -1022,7 +1022,7 @@
 {
     build lockx;
     build m8;
-    subCarryFlags(  m8, Reg8 );
+    subCarryFlags(m8, Reg8);
     resultflags(m8);
     build unlock; 
 }
@@ -1031,7 +1031,7 @@
 {
     build lockx;
     build m16;
-    subCarryFlags( m16, Reg16 );
+    subCarryFlags(m16, Reg16);
     resultflags(m16);
     build unlock; 
 }
@@ -1040,7 +1040,7 @@
 {
     build lockx;
     build m32;
-    subCarryFlags( m32, Reg32 );
+    subCarryFlags(m32, Reg32);
     resultflags(m32);
     build unlock; 
 }
@@ -1050,82 +1050,82 @@
 {
     build lockx;
     build m64;
-    subCarryFlags( m64, Reg64 );
+    subCarryFlags(m64, Reg64);
     resultflags(m64);
     build unlock; 
 }
 @endif
 
-:SUB^lockx  spec_m8,imm8     is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=5 ...; imm8     
+:SUB^lockx  m8,imm8     is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=5 ...; imm8     
 {
     build lockx;
-    build spec_m8;
-    subflags(  spec_m8,imm8 );
-    spec_m8 =   spec_m8 -  imm8;
-    resultflags(  spec_m8);
+    build m8;
+    subflags(m8,imm8);
+    m8 = m8 - imm8;
+    resultflags(m8);
     build unlock; 
 }
 
-:SUB^lockx  spec_m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=5 ...; imm16  
+:SUB^lockx m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=5 ...; imm16  
 {
     build lockx;
-    build spec_m16;
-    subflags( spec_m16,imm16);
-    spec_m16 =  spec_m16 - imm16;
-    resultflags( spec_m16);
+    build m16;
+    subflags(m16,imm16);
+    m16 = m16 - imm16;
+    resultflags(m16);
     build unlock; 
 }
 
-:SUB^lockx  spec_m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=5 ...; imm32  
+:SUB^lockx  m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=5 ...; imm32  
 {
     build lockx;
-    build spec_m32;
-    subflags( spec_m32,imm32);
-    spec_m32 =  spec_m32 - imm32;
-    resultflags( spec_m32);
+    build m32;
+    subflags(m32,imm32);
+    m32 = m32 - imm32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:SUB^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=5 ...; simm32  
+:SUB^lockx  m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=5 ...; simm32  
 {
     build lockx;
-    build spec_m64;
-    subflags( spec_m64,simm32);
-    spec_m64 =  spec_m64 - simm32;
-    resultflags( spec_m64);
+    build m64;
+    subflags(m64,simm32);
+    m64 = m64 - simm32;
+    resultflags(m64);
     build unlock; 
 }
 @endif
 
-:SUB^lockx  spec_m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=5 ...; simm8_16  
+:SUB^lockx m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=5 ...; simm8_16  
 {
     build lockx;
-    build spec_m16;
-    subflags( spec_m16,simm8_16);
-    spec_m16 =  spec_m16 - simm8_16;
-    resultflags( spec_m16);
+    build m16;
+    subflags(m16,simm8_16);
+    m16 = m16 - simm8_16;
+    resultflags(m16);
     build unlock; 
 }
 
-:SUB^lockx  spec_m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=5 ...; simm8_32  
+:SUB^lockx  m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=5 ...; simm8_32  
 {
     build lockx;
-    build spec_m32;
-    subflags( spec_m32,simm8_32);
-    spec_m32 =  spec_m32 - simm8_32;
-    resultflags( spec_m32);
+    build m32;
+    subflags(m32,simm8_32);
+    m32 = m32 - simm8_32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:SUB^lockx  spec_m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=5 ...; simm8_64  
+:SUB^lockx m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=5 ...; simm8_64  
 {
     build lockx;
-    build spec_m64;
-    subflags( spec_m64,simm8_64);
-    spec_m64 =  spec_m64 - simm8_64;
-    resultflags( spec_m64);
+    build m64;
+    subflags(m64,simm8_64);
+    m64 = m64 - simm8_64;
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -1134,9 +1134,9 @@
 {
     build lockx;
     build m8;
-    subflags(  m8,Reg8 );
-    m8 =   m8 -  Reg8;
-    resultflags(  m8);
+    subflags(m8,Reg8);
+    m8 = m8 - Reg8;
+    resultflags(m8);
     build unlock; 
 }
 
@@ -1144,9 +1144,9 @@
 {
     build lockx;
     build m16;
-    subflags( m16,Reg16);
+    subflags(m16,Reg16);
     m16 =  m16 - Reg16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock; 
 }
 
@@ -1154,9 +1154,9 @@
 {
     build lockx;
     build m32;
-    subflags( m32,Reg32);
+    subflags(m32,Reg32);
     m32 =  m32 - Reg32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock; 
 }
 
@@ -1165,9 +1165,9 @@
 {
     build lockx;
     build m64;
-    subflags( m64,Reg64);
+    subflags(m64,Reg64);
     m64 =  m64 - Reg64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -1176,7 +1176,7 @@
 {
     build lockx;
     build m8;
-    addflags( m8,Reg8 );
+    addflags( m8,Reg8);
     local tmp =  m8 +  Reg8;
     Reg8 = m8;
     m8 = tmp;
@@ -1269,76 +1269,76 @@
 }
 @endif
 
-:XOR^lockx spec_m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=6 ...; imm8     
+:XOR^lockx m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=6 ...; imm8     
 {
     build lockx;
-    build spec_m8;
+    build m8;
     logicalflags();
-    spec_m8 =   spec_m8 ^  imm8;
-    resultflags(  spec_m8);
+    m8 = m8 ^ imm8;
+    resultflags(m8);
     build unlock; 
 }
 
-:XOR^lockx spec_m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=6 ...; imm16  
+:XOR^lockx m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=6 ...; imm16  
 {
     build lockx;
-    build spec_m16;
+    build m16;
     logicalflags();
-    spec_m16 =  spec_m16 ^ imm16;
-    resultflags( spec_m16);
+    m16 = m16 ^ imm16;
+    resultflags(m16);
     build unlock; 
 }
 
-:XOR^lockx spec_m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=6 ...; imm32  
+:XOR^lockx m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=6 ...; imm32  
 {
     build lockx;
-    build spec_m32;
+    build m32;
     logicalflags();
-    spec_m32 =  spec_m32 ^ imm32;
-    resultflags( spec_m32);
+    m32 = m32 ^ imm32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:XOR^lockx spec_m64,simm32   is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=6 ...; simm32 
+:XOR^lockx m64,simm32   is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=6 ...; simm32 
 {
     build lockx;
-    build spec_m64;
+    build m64;
     logicalflags();
-    spec_m64 =  spec_m64 ^ simm32;
-    resultflags( spec_m64);
+    m64 = m64 ^ simm32;
+    resultflags(m64);
     build unlock; 
 }
 @endif
 
-:XOR^lockx spec_m16,usimm8_16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=6 ...; usimm8_16  
+:XOR^lockx m16,usimm8_16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=6 ...; usimm8_16  
 {
     build lockx;
-    build spec_m16;
+    build m16;
     logicalflags();
-    spec_m16 =  spec_m16 ^ usimm8_16;
-    resultflags( spec_m16);
+    m16 = m16 ^ usimm8_16;
+    resultflags(m16);
     build unlock; 
 }
 
-:XOR^lockx spec_m32,usimm8_32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=6 ...; usimm8_32  
+:XOR^lockx m32,usimm8_32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=6 ...; usimm8_32  
 {
     build lockx;
-    build spec_m32;
+    build m32;
     logicalflags();
-    spec_m32 =  spec_m32 ^ usimm8_32;
-    resultflags( spec_m32);
+    m32 = m32 ^ usimm8_32;
+    resultflags(m32);
     build unlock; 
 }
 
 @ifdef IA64
-:XOR^lockx spec_m64,usimm8_64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=6 ...; usimm8_64  
+:XOR^lockx m64,usimm8_64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=6 ...; usimm8_64  
 {
     build lockx;
-    build spec_m64;
+    build m64;
     logicalflags();
-    spec_m64 =  spec_m64 ^ usimm8_64;
-    resultflags( spec_m64);
+    m64 = m64 ^ usimm8_64;
+    resultflags(m64);
     build unlock; 
 }
 @endif
@@ -1348,8 +1348,8 @@
     build lockx;
     build m8;
     logicalflags();
-    m8 =   m8 ^  Reg8;
-    resultflags(  m8);
+    m8 = m8 ^ Reg8;
+    resultflags(m8);
     build unlock; 
 }
 
@@ -1359,7 +1359,7 @@
     build m16;
     logicalflags();
     m16 =  m16 ^ Reg16;
-    resultflags( m16);
+    resultflags(m16);
     build unlock; 
 }
 
@@ -1369,7 +1369,7 @@
     build m32;
     logicalflags();
     m32 =  m32 ^ Reg32;
-    resultflags( m32);
+    resultflags(m32);
     build unlock; 
 }
 
@@ -1380,7 +1380,7 @@
     build m64;
     logicalflags();
     m64 =  m64 ^ Reg64;
-    resultflags( m64);
+    resultflags(m64);
     build unlock; 
 }
 @endif
diff --git a/Ghidra/Processors/x86/data/languages/x86.ldefs b/Ghidra/Processors/x86/data/languages/x86.ldefs
index 254beee7459..584708b743b 100644
--- a/Ghidra/Processors/x86/data/languages/x86.ldefs
+++ b/Ghidra/Processors/x86/data/languages/x86.ldefs
@@ -5,7 +5,7 @@
             endian="little"
             size="32"
             variant="default"
-            version="4.3"
+            version="4.4"
             slafile="x86.sla"
             processorspec="x86.pspec"
             manualindexfile="../manuals/x86.idx"
@@ -37,7 +37,7 @@
             endian="little"
             size="32"
             variant="System Management Mode"
-            version="4.3"
+            version="4.4"
             slafile="x86.sla"
             processorspec="x86-16.pspec"
             manualindexfile="../manuals/x86.idx"
@@ -50,7 +50,7 @@
             endian="little"
             size="16"
             variant="Real Mode"
-            version="4.3"
+            version="4.4"
             slafile="x86.sla"
             processorspec="x86-16-real.pspec"
             manualindexfile="../manuals/x86.idx"
@@ -70,7 +70,7 @@
             endian="little"
             size="16"
             variant="Protected Mode"
-            version="4.3"
+            version="4.4"
             slafile="x86.sla"
             processorspec="x86-16.pspec"
             manualindexfile="../manuals/x86.idx"
@@ -85,7 +85,7 @@
             endian="little"
             size="64"
             variant="default"
-            version="4.3"
+            version="4.4"
             slafile="x86-64.sla"
             processorspec="x86-64.pspec"
             manualindexfile="../manuals/x86.idx"
@@ -108,7 +108,7 @@
             endian="little"
             size="64"
             variant="compat32"
-            version="4.3"
+            version="4.4"
             slafile="x86-64.sla"
             processorspec="x86-64-compat32.pspec"
             manualindexfile="../manuals/x86.idx"
```
-----------------------------------
