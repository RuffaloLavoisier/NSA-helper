# Commit: 17ac51c46b7432d389ad21a0bb9121839a36354c
## Message: GP-6176: Refactored Objective-C type metadata analyzers
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_ClassAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_ClassAnalyzer.java
deleted file mode 100644
index 3cbb09be1a3..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_ClassAnalyzer.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.plugin.core.analysis;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import java.io.IOException;
-
-import ghidra.app.services.*;
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.MemoryByteProvider;
-import ghidra.app.util.bin.format.objectiveC.*;
-import ghidra.app.util.importer.MessageLog;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.address.AddressSetView;
-import ghidra.program.model.listing.Program;
-import ghidra.program.model.mem.Memory;
-import ghidra.program.model.mem.MemoryBlock;
-import ghidra.util.exception.CancelledException;
-import ghidra.util.task.TaskMonitor;
-
-public class ObjectiveC1_ClassAnalyzer extends AbstractAnalyzer {
-	private static final String DESCRIPTION =
-		"An analyzer for extracting Objective-C class structure information.";
-	private static final String NAME = "Objective-C Class";
-
-	/* ************************************************************************** */
-	/* ************************************************************************** */
-
-	public ObjectiveC1_ClassAnalyzer() {
-		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
-		setPriority(AnalysisPriority.FORMAT_ANALYSIS);
-		setDefaultEnablement(true);
-	}
-
-	@Override
-	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
-			throws CancelledException {
-
-		MemoryByteProvider provider =
-			MemoryByteProvider.createDefaultAddressSpaceByteProvider(program, false);
-		BinaryReader reader = new BinaryReader(provider, !program.getLanguage().isBigEndian());
-
-		ObjectiveC1_State state =
-			new ObjectiveC1_State(program, monitor, ObjectiveC1_Constants.CATEGORY_PATH);
-
-		try {
-			processModules(state, reader);
-			processProtocols(state, reader);
-
-			ObjectiveC1_Utilities.createMethods(state);
-
-			setDataAndRefBlocksReadOnly(state);
-		}
-		catch (Exception e) {
-		}
-
-		ObjectiveC1_Utilities.fixupReferences(state);
-
-		return true;
-	}
-
-	private void setDataAndRefBlocksReadOnly(ObjectiveC1_State state) {
-		Memory memory = state.program.getMemory();
-
-		MemoryBlock dataBlock = memory.getBlock(ObjectiveC1_Constants.OBJC_SECTION_DATA);
-		if (dataBlock != null) {
-			dataBlock.setWrite(false);
-		}
-
-		MemoryBlock classRefsBlock = memory.getBlock(ObjectiveC1_Constants.OBJC_SECTION_CLASS_REFS);
-		if (classRefsBlock != null) {
-			classRefsBlock.setWrite(false);
-		}
-
-		MemoryBlock messageRefsBlock =
-			memory.getBlock(ObjectiveC1_Constants.OBJC_SECTION_MESSAGE_REFS);
-		if (messageRefsBlock != null) {
-			messageRefsBlock.setWrite(false);
-		}
-	}
-
-	@Override
-	public boolean canAnalyze(Program program) {
-		return ObjectiveC1_Constants.isObjectiveC(program);
-	}
-
-	/* ************************************************************************** */
-	/* ************************************************************************** */
-
-	private void processModules(ObjectiveC1_State state, BinaryReader reader) throws Exception {
-		state.monitor.setMessage("Objective-C Modules...");
-
-		List<ObjectiveC1_Module> modules = parseModuleList(state, reader);
-
-		state.monitor.initialize(modules.size());
-		int progress = 0;
-
-		for (ObjectiveC1_Module module : modules) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			state.monitor.setProgress(++progress);
-
-			module.applyTo();
-		}
-	}
-
-	private List<ObjectiveC1_Module> parseModuleList(ObjectiveC1_State state, BinaryReader reader) {
-		List<ObjectiveC1_Module> modules = new ArrayList<ObjectiveC1_Module>();
-		state.monitor.setMessage("Parsing Objective-C information...");
-		try {
-			MemoryBlock moduleInfoBlock =
-				state.program.getMemory().getBlock(ObjectiveC1_Constants.OBJC_SECTION_MODULE_INFO);
-			long moduleInfoStartIndex = moduleInfoBlock.getStart().getOffset();
-			long moduleInfoEndIndex = moduleInfoBlock.getEnd().getOffset();
-
-			state.monitor.initialize((int) (moduleInfoEndIndex - moduleInfoStartIndex));
-
-			reader.setPointerIndex(moduleInfoStartIndex);
-			while (reader.getPointerIndex() < moduleInfoEndIndex) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				modules.add(new ObjectiveC1_Module(state, reader));
-				state.monitor.setProgress((int) (reader.getPointerIndex() - moduleInfoStartIndex));
-			}
-		}
-		catch (IOException e) {
-			e.printStackTrace();
-		}
-		return modules;
-	}
-
-	private void processProtocols(ObjectiveC1_State state, BinaryReader reader) throws Exception {
-		state.monitor.setMessage("Objective-C Protocols...");
-
-		MemoryBlock block =
-			state.program.getMemory().getBlock(ObjectiveC1_Constants.OBJC_SECTION_PROTOCOL);
-		if (block == null) {
-			return;
-		}
-
-		state.monitor.initialize((int) block.getSize());
-
-		Address address = block.getStart();
-
-		reader.setPointerIndex(block.getStart().getOffset());
-
-		while (address.compareTo(block.getEnd()) < 0) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			state.monitor.setProgress((int) address.subtract(block.getStart()));
-
-			ObjectiveC1_Protocol protocol = new ObjectiveC1_Protocol(state, reader);
-			protocol.applyTo();
-
-			address = address.add(ObjectiveC1_Protocol.SIZEOF);
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_ClassAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_ClassAnalyzer.java
deleted file mode 100644
index c9f146ffdb0..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_ClassAnalyzer.java
+++ /dev/null
@@ -1,476 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.plugin.core.analysis;
-
-import java.util.*;
-
-import java.io.IOException;
-
-import ghidra.app.services.*;
-import ghidra.app.util.bin.*;
-import ghidra.app.util.bin.format.macho.dyld.LibObjcOptimization;
-import ghidra.app.util.bin.format.objc2.*;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.app.util.importer.MessageLog;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.address.AddressSetView;
-import ghidra.program.model.data.DataType;
-import ghidra.program.model.listing.Data;
-import ghidra.program.model.listing.Program;
-import ghidra.program.model.mem.Memory;
-import ghidra.program.model.mem.MemoryBlock;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.CancelledException;
-import ghidra.util.task.TaskMonitor;
-
-public class ObjectiveC2_ClassAnalyzer extends AbstractAnalyzer {
-	private static final String NAME = "Objective-C 2 Class";
-	private static final String DESCRIPTION =
-		"An analyzer for extracting and annotating Objective-C 2.0 class structure information.";
-
-	public ObjectiveC2_ClassAnalyzer() {
-		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
-		setDefaultEnablement(true);
-		//The Objective-C 2.0 analyzer should always run first.
-		//It knows the deal!
-		setPriority(AnalysisPriority.FORMAT_ANALYSIS);
-	}
-
-	@Override
-	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
-			throws CancelledException {
-		return processObjectiveC2(program, monitor, log);
-	}
-
-	@Override
-	public boolean canAnalyze(Program program) {
-		return ObjectiveC2_Constants.isObjectiveC2(program);
-	}
-
-	/* ************************************************************************** */
-	/* ************************************************************************** */
-
-	private boolean processObjectiveC2(Program program, TaskMonitor monitor, MessageLog log) {
-		ObjectiveC2_State state =
-			new ObjectiveC2_State(program, monitor, ObjectiveC2_Constants.CATEGORY_PATH);
-
-		try (ByteProvider provider =
-			MemoryByteProvider.createDefaultAddressSpaceByteProvider(program, false)) {
-			BinaryReader reader = new BinaryReader(provider, !program.getLanguage().isBigEndian());
-
-			// Create a map of Objective-C specific memory blocks.  If this is a dyld_shared_cache
-			// file, there will be many of each type.
-			Map<String, List<MemoryBlock>> objcBlockMap = new HashMap<>();
-			for (MemoryBlock block : program.getMemory().getBlocks()) {
-				String name = block.getName();
-				if (name.startsWith(ObjectiveC2_Constants.OBJC2_PREFIX)) {
-					List<MemoryBlock> list = objcBlockMap.get(name);
-					if (list == null) {
-						list = new ArrayList<>();
-						objcBlockMap.put(name, list);
-					}
-					list.add(block);
-				}
-				if (name.equals(LibObjcOptimization.SECTION_NAME)) {
-					// If this is a dyld_shared_cache, there should one of these.  We'll need to 
-					// save it so we can later extract selector/method names.
-					try {
-						state.libObjcOptimization =
-							new LibObjcOptimization(program, block.getStart());
-					}
-					catch (IOException e) {
-						log.appendMsg(
-							"Failed to parse libobjc. Method names may not be recoverable.");
-					}
-				}
-			}
-
-			processImageInfo(state, reader, objcBlockMap);
-
-			processClassList(state, reader, objcBlockMap);
-			processCategoryList(state, reader, objcBlockMap);
-			processProtocolList(state, reader, objcBlockMap);
-
-			processClassReferences(state, objcBlockMap);
-			processSuperReferences(state, objcBlockMap);
-			processProtocolReferences(state, objcBlockMap);
-			processNonLazyClassReferences(state, objcBlockMap);
-			processSelectorReferences(state, objcBlockMap);
-			processMessageReferences(state, reader, objcBlockMap);
-
-			ObjectiveC1_Utilities.createMethods(state);
-			ObjectiveC1_Utilities.createInstanceVariablesC2_OBJC2(state);
-			ObjectiveC1_Utilities.fixupReferences(state);
-
-			setDataAndRefBlocksReadOnly(state);
-		}
-		catch (Exception e) {
-			String message = e.getMessage();
-			log.appendMsg(getName(), message);
-			log.setStatus(message);
-			return false;
-		}
-		finally {
-			state.dispose();
-		}
-		return true;
-	}
-
-	private void setDataAndRefBlocksReadOnly(ObjectiveC2_State state) {
-		Memory memory = state.program.getMemory();
-		MemoryBlock dataBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_DATA);
-		if (dataBlock != null) {
-			dataBlock.setWrite(false);
-		}
-
-		MemoryBlock classRefsBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_CLASS_REFS);
-		if (classRefsBlock != null) {
-			classRefsBlock.setWrite(false);
-		}
-
-		MemoryBlock messageRefsBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_MESSAGE_REFS);
-		if (messageRefsBlock != null) {
-			messageRefsBlock.setWrite(false);
-		}
-
-		MemoryBlock selectorRefsBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_SELECTOR_REFS);
-		if (selectorRefsBlock != null) {
-			selectorRefsBlock.setWrite(false);
-		}
-
-		MemoryBlock superRefsBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_SUPER_REFS);
-		if (superRefsBlock != null) {
-			superRefsBlock.setWrite(false);
-		}
-
-		MemoryBlock protocolRefsBlock = memory.getBlock(ObjectiveC2_Constants.OBJC2_PROTOCOL_REFS);
-		if (protocolRefsBlock != null) {
-			protocolRefsBlock.setWrite(false);
-		}
-	}
-
-	private void processProtocolReferences(ObjectiveC2_State state,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Protocol References...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_PROTOCOL_REFS);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				ObjectiveC1_Utilities.createPointerAndReturnAddressBeingReferenced(state.program,
-					address);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processClassReferences(ObjectiveC2_State state,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Class References...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_CLASS_REFS);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				ObjectiveC1_Utilities.createPointerAndReturnAddressBeingReferenced(state.program,
-					address);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processNonLazyClassReferences(ObjectiveC2_State state,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Non-lazy Class Lists...");
-
-		List<MemoryBlock> blocks =
-			objcBlockMap.get(ObjectiveC2_Constants.OBJC2_NON_LAZY_CLASS_LIST);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				ObjectiveC1_Utilities.createPointerAndReturnAddressBeingReferenced(state.program,
-					address);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processSuperReferences(ObjectiveC2_State state,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Super References...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_SUPER_REFS);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				ObjectiveC1_Utilities.createPointerAndReturnAddressBeingReferenced(state.program,
-					address);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processCategoryList(ObjectiveC2_State state, BinaryReader reader,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Category Information...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_CATEGORY_LIST);
-		if (blocks == null) {
-			return;
-		}
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				Address categoryAddress = ObjectiveC1_Utilities
-						.createPointerAndReturnAddressBeingReferenced(state.program, address);
-				reader.setPointerIndex(categoryAddress.getOffset());
-				ObjectiveC2_Category category = new ObjectiveC2_Category(state, reader);
-				category.applyTo();
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processImageInfo(ObjectiveC2_State state, BinaryReader reader,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Image Information...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_IMAGE_INFO);
-		if (blocks == null) {
-			return;
-		}
-		for (MemoryBlock block : blocks) {
-			Address address = block.getStart();
-			reader.setPointerIndex(address.getOffset());
-			ObjectiveC2_ImageInfo imageInfo = new ObjectiveC2_ImageInfo(state, reader);
-			imageInfo.applyTo();
-		}
-	}
-
-	private void processProtocolList(ObjectiveC2_State state, BinaryReader reader,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Protocol Information...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_PROTOCOL_LIST);
-		if (blocks == null) {
-			return;
-		}
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-
-				Address protocolAddress = ObjectiveC1_Utilities
-						.createPointerAndReturnAddressBeingReferenced(state.program, address);
-				reader.setPointerIndex(protocolAddress.getOffset());
-
-				ObjectiveC2_Protocol protocol = new ObjectiveC2_Protocol(state, reader);
-				Namespace namespace = ObjectiveC1_Utilities.createNamespace(state.program,
-					ObjectiveC1_Constants.NAMESPACE, "Protocols", protocol.getName());
-				protocol.applyTo(namespace);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-	private void processClassList(ObjectiveC2_State state, BinaryReader reader,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Class Information...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_CLASS_LIST);
-		if (blocks == null) {
-			return;
-		}
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-
-				Address classAddress = ObjectiveC1_Utilities
-						.createPointerAndReturnAddressBeingReferenced(state.program, address);
-				reader.setPointerIndex(classAddress.getOffset() & 0xfffffffffffL);
-
-				ObjectiveC2_Class clazz = new ObjectiveC2_Class(state, reader);
-				clazz.applyTo();
-				address = address.add(state.pointerSize);
-			}
-		}
-
-	}
-
-	private void processMessageReferences(ObjectiveC2_State state, BinaryReader reader,
-			Map<String, List<MemoryBlock>> objcBlockMap)
-			throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Message References...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_MESSAGE_REFS);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / ObjectiveC2_MessageReference.SIZEOF(state);
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				reader.setPointerIndex(address.getOffset());
-				ObjectiveC2_MessageReference messageRef =
-					new ObjectiveC2_MessageReference(state, reader);
-				DataType dt = messageRef.toDataType();
-				Data messageRefData = state.program.getListing().createData(address, dt);
-				Data selData = messageRefData.getComponent(1);
-				Object selAddress = selData.getValue();
-				Data selStringData = state.program.getListing().getDataAt((Address) selAddress);
-				Object selString = selStringData.getValue();
-				ObjectiveC1_Utilities.createSymbol(state.program, null,
-					selString + "_" + ObjectiveC2_MessageReference.NAME, address);
-				address = address.add(dt.getLength());
-			}
-		}
-	}
-
-	private void processSelectorReferences(ObjectiveC2_State state,
-			Map<String, List<MemoryBlock>> objcBlockMap) throws Exception {
-		state.monitor.setMessage("Objective-C 2.0 Selector References...");
-
-		List<MemoryBlock> blocks = objcBlockMap.get(ObjectiveC2_Constants.OBJC2_SELECTOR_REFS);
-		if (blocks == null) {
-			return;
-		}
-
-		for (MemoryBlock block : blocks) {
-			ObjectiveC1_Utilities.clear(state, block);
-
-			long count = block.getSize() / state.pointerSize;
-
-			state.monitor.initialize((int) count);
-
-			Address address = block.getStart();
-
-			for (int i = 0; i < count; ++i) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				state.monitor.setProgress(i);
-				ObjectiveC1_Utilities.createPointerAndReturnAddressBeingReferenced(state.program,
-					address);
-				address = address.add(state.pointerSize);
-			}
-		}
-	}
-
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_MessageAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc1MessageAnalyzer.java
similarity index 91%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_MessageAnalyzer.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc1MessageAnalyzer.java
index 767184b30bc..18e8f1009a5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC1_MessageAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc1MessageAnalyzer.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.plugin.core.analysis;
+package ghidra.app.plugin.core.analysis.objc;
 
 import java.util.List;
 
 import ghidra.app.services.*;
 import ghidra.app.util.bin.format.macho.SectionNames;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
+import ghidra.app.util.bin.format.objc.ObjcUtils;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.address.*;
 import ghidra.program.model.listing.*;
@@ -29,13 +29,13 @@
 import ghidra.util.exception.*;
 import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC1_MessageAnalyzer extends AbstractAnalyzer {
+public class Objc1MessageAnalyzer extends AbstractAnalyzer {
 	private static final String DESCRIPTION =
 		"An analyzer for extracting _objc_msgSend information.";
 
 	private static final String NAME = "Objective-C Message";
 
-	public ObjectiveC1_MessageAnalyzer() {
+	public Objc1MessageAnalyzer() {
 		super(NAME, DESCRIPTION, AnalyzerType.FUNCTION_ANALYZER);
 		setDefaultEnablement(true);
 		setPriority(new AnalysisPriority(10000000));
@@ -76,7 +76,7 @@ public boolean added(Program program, AddressSetView set, TaskMonitor monitor, M
 
 	@Override
 	public boolean canAnalyze(Program program) {
-		return ObjectiveC1_Constants.isObjectiveC(program);
+		return Objc1Constants.isObjectiveC(program);
 	}
 
 	/* ************************************************************************** */
@@ -126,9 +126,9 @@ private boolean isCallingObjcMsgSend(Instruction instruction) {
 
 	private boolean isObjcNameMatch(Symbol symbol) {
 		String name = symbol.getName();
-		return name.startsWith(ObjectiveC1_Constants.OBJC_MSG_SEND) ||
-			name.equals(ObjectiveC1_Constants.READ_UNIX2003) ||
-			name.startsWith("thunk" + ObjectiveC1_Constants.OBJC_MSG_SEND);
+		return name.startsWith(Objc1Constants.OBJC_MSG_SEND) ||
+			name.equals(Objc1Constants.READ_UNIX2003) ||
+			name.startsWith("thunk" + Objc1Constants.OBJC_MSG_SEND);
 	}
 
 	private class CurrentState {
@@ -263,7 +263,7 @@ String pullNameThrough(CurrentState state, Address address, Namespace space) {
 			return null;
 		}
 		if (block.getName().equals(SectionNames.TEXT_CSTRING)) {
-			return ObjectiveC1_Utilities.createString(state.program, address);
+			return ObjcUtils.createString(state.program, address);
 		}
 		Data data = state.program.getListing().getDataAt(address);
 		if (data == null) {
@@ -304,12 +304,12 @@ else if (isMessageBlock(block)) {
 	}
 
 	private boolean isMessageBlock(MemoryBlock block) {
-		return block.getName().equals(ObjectiveC1_Constants.OBJC_SECTION_MESSAGE_REFS);
+		return block.getName().equals(Objc1Constants.OBJC_SECTION_MESSAGE_REFS);
 	}
 
 	private boolean isClassBlock(MemoryBlock block) {
-		return block.getName().equals(ObjectiveC1_Constants.OBJC_SECTION_CLASS_REFS) ||
-			block.getName().equals(ObjectiveC1_Constants.OBJC_SECTION_CLASS);
+		return block.getName().equals(Objc1Constants.OBJC_SECTION_CLASS_REFS) ||
+			block.getName().equals(Objc1Constants.OBJC_SECTION_CLASS);
 	}
 
 	private boolean isValidInstruction(Instruction instruction) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_MessageAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc2MessageAnalyzer.java
similarity index 84%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_MessageAnalyzer.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc2MessageAnalyzer.java
index cea28e6f76b..9131db4ebfc 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_MessageAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/Objc2MessageAnalyzer.java
@@ -13,22 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.plugin.core.analysis;
+package ghidra.app.plugin.core.analysis.objc;
+
+import java.math.BigInteger;
 
 import ghidra.app.services.*;
 import ghidra.app.util.bin.format.macho.SectionNames;
-import ghidra.app.util.bin.format.objc2.ObjectiveC2_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.app.util.bin.format.objc.objc2.Objc2Constants;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.address.*;
 import ghidra.program.model.lang.Register;
 import ghidra.program.model.listing.*;
 import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.scalar.Scalar;
 import ghidra.program.model.symbol.*;
 import ghidra.util.exception.CancelledException;
 import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC2_MessageAnalyzer extends AbstractAnalyzer {
+public class Objc2MessageAnalyzer extends AbstractAnalyzer {
 	private static final String NAME = "Objective-C 2 Message";
 	private static final String DESCRIPTION =
 		"An analyzer for extracting Objective-C 2.0 message information.";
@@ -36,7 +39,7 @@ public class ObjectiveC2_MessageAnalyzer extends AbstractAnalyzer {
 	/* ************************************************************************** */
 	/* ************************************************************************** */
 
-	public ObjectiveC2_MessageAnalyzer() {
+	public Objc2MessageAnalyzer() {
 		super(NAME, DESCRIPTION, AnalyzerType.FUNCTION_ANALYZER);
 		setPrototype();
 		//The Objective-C 2.0 analyzer should always run after the class analyzer.
@@ -66,7 +69,7 @@ public boolean added(Program program, AddressSetView set, TaskMonitor monitor, M
 
 	@Override
 	public boolean canAnalyze(Program program) {
-		return ObjectiveC2_Constants.isObjectiveC2(program);
+		return Objc2Constants.isObjectiveC2(program);
 	}
 
 	/* ************************************************************************** */
@@ -102,9 +105,9 @@ private boolean isCallingObjcMsgSend(Instruction instruction) {
 		if (reference == null) {
 			return false;
 		}
-		if (!reference.getReferenceType().isCall() && !reference.getReferenceType().isJump()) {
-			return false;
-		}
+//		if (!reference.getReferenceType().isCall() && !reference.getReferenceType().isJump()) {
+//			return false;
+//		}
 		SymbolTable symbolTable = instruction.getProgram().getSymbolTable();
 		Symbol symbol = symbolTable.getPrimarySymbol(reference.getToAddress());
 		return isObjcNameMatch(symbol);
@@ -112,8 +115,8 @@ private boolean isCallingObjcMsgSend(Instruction instruction) {
 
 	private boolean isObjcNameMatch(Symbol symbol) {
 		String name = symbol.getName();
-		return name.startsWith(ObjectiveC1_Constants.OBJC_MSG_SEND) ||
-			name.equals(ObjectiveC1_Constants.READ_UNIX2003);
+		return name.startsWith(Objc1Constants.OBJC_MSG_SEND) ||
+			name.equals(Objc1Constants.READ_UNIX2003);
 	}
 
 	private void markupInstruction(Program program, Instruction instruction, TaskMonitor monitor) {
@@ -137,8 +140,10 @@ private void markupInstruction(Program program, Instruction instruction, TaskMon
 				break;//don't look outside of the function
 			}
 
-			final String CLASS_REGISTER = "r0";
-			final String METHOD_REGISTER = "r1";
+			boolean is64bit = program.getDefaultPointerSize() == 8;
+			boolean isX86 = program.getLanguageID().getIdAsString().equals("x86");
+			final String CLASS_REGISTER = is64bit ? "x0" : "r0";
+			final String METHOD_REGISTER = is64bit ? "x1" : "r1";
 
 			boolean isRegisterModified = false;
 
@@ -174,14 +179,27 @@ private void markupInstruction(Program program, Instruction instruction, TaskMon
 			}
 
 			Object[] secondOperandObjects = instructionBefore.getOpObjects(1);
-			if (secondOperandObjects.length != 1) {
+			if (secondOperandObjects.length < 1) {
 				continue;
 			}
 
-			if (!(secondOperandObjects[0] instanceof Address)) {
+			Address toAddress = null;
+			if (secondOperandObjects.length == 1 &&
+				secondOperandObjects[0] instanceof Address addr) {
+				toAddress = addr;
+			}
+			else if (secondOperandObjects.length == 2 &&
+				secondOperandObjects[0] instanceof Register reg &&
+				secondOperandObjects[1] instanceof Scalar scalar) {
+				Address instrAddr = instructionBefore.getAddress();
+				ProgramContext programContext = program.getProgramContext();
+				BigInteger registerValue = programContext.getValue(reg, instrAddr, false);
+				toAddress = instrAddr.getNewAddress(registerValue.longValue() + scalar.getValue());
+			}
+
+			if (toAddress == null) {
 				continue;
 			}
-			Address toAddress = (Address) secondOperandObjects[0];
 
 			MemoryBlock block = program.getMemory().getBlock(toAddress);
 			if (block == null) {
@@ -314,7 +332,7 @@ private boolean isCStringBlock(Program program, Address address) {
 	private boolean isObjcSelectorRefBlock(Program program, Address address) {
 		MemoryBlock block = program.getMemory().getBlock(address);
 		if (block != null) {
-			if (block.getName().equals(ObjectiveC2_Constants.OBJC2_SELECTOR_REFS)) {
+			if (block.getName().equals(Objc2Constants.OBJC2_SELECTOR_REFS)) {
 				return true;
 			}
 		}
@@ -324,7 +342,7 @@ private boolean isObjcSelectorRefBlock(Program program, Address address) {
 	private boolean isObjcClassRefBlock(Program program, Address address) {
 		MemoryBlock block = program.getMemory().getBlock(address);
 		if (block != null) {
-			if (block.getName().equals(ObjectiveC2_Constants.OBJC2_CLASS_REFS)) {
+			if (block.getName().equals(Objc2Constants.OBJC2_CLASS_REFS)) {
 				return true;
 			}
 		}
@@ -334,7 +352,7 @@ private boolean isObjcClassRefBlock(Program program, Address address) {
 	private boolean isObjcConstBlock(Program program, Address address) {
 		MemoryBlock block = program.getMemory().getBlock(address);
 		if (block != null) {
-			if (block.getName().equals(ObjectiveC2_Constants.OBJC2_CONST)) {
+			if (block.getName().equals(Objc2Constants.OBJC2_CONST)) {
 				return true;
 			}
 		}
@@ -344,7 +362,7 @@ private boolean isObjcConstBlock(Program program, Address address) {
 	private boolean isObjcDataBlock(Program program, Address address) {
 		MemoryBlock block = program.getMemory().getBlock(address);
 		if (block != null) {
-			if (block.getName().equals(ObjectiveC2_Constants.OBJC2_DATA)) {
+			if (block.getName().equals(Objc2Constants.OBJC2_DATA)) {
 				return true;
 			}
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/ObjcTypeMetadataAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/ObjcTypeMetadataAnalyzer.java
new file mode 100644
index 00000000000..a0f3253d9f8
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/objc/ObjcTypeMetadataAnalyzer.java
@@ -0,0 +1,80 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.core.analysis.objc;
+
+import ghidra.app.services.*;
+import ghidra.app.util.bin.format.objc.AbstractObjcTypeMetadata;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.app.util.bin.format.objc.objc1.Objc1TypeMetadata;
+import ghidra.app.util.bin.format.objc.objc2.Objc2Constants;
+import ghidra.app.util.bin.format.objc.objc2.Objc2TypeMetadata;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.listing.Program;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class ObjcTypeMetadataAnalyzer extends AbstractAnalyzer {
+	private static final String NAME = "Objective-C Type Metadata Analyzer";
+	private static final String DESCRIPTION = "Discovers Objective-C type metadata records.";
+
+	private AbstractObjcTypeMetadata typeMetadata;
+
+	public ObjcTypeMetadataAnalyzer() {
+		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
+		setDefaultEnablement(true);
+		setPriority(AnalysisPriority.FORMAT_ANALYSIS);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		return Objc1Constants.isObjectiveC(program) || Objc2Constants.isObjectiveC2(program);
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
+			throws CancelledException {
+		if (typeMetadata != null) {
+			return true;
+		}
+		try {
+			if (Objc1Constants.isObjectiveC(program)) {
+				typeMetadata = new Objc1TypeMetadata(program, monitor, log);
+			}
+			else if (Objc2Constants.isObjectiveC2(program)) {
+				typeMetadata = new Objc2TypeMetadata(program, monitor, log);
+			}
+			if (typeMetadata != null) {
+				typeMetadata.applyTo();
+			}
+			return true;
+		}
+		catch (CancelledException e) {
+			throw e;
+		}
+		catch (Exception e) {
+			return false;
+		}
+	}
+
+	@Override
+	public void analysisEnded(Program program) {
+		if (typeMetadata != null) {
+			typeMetadata.close();
+			typeMetadata = null;
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/AbstractObjcTypeMetadata.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/AbstractObjcTypeMetadata.java
new file mode 100644
index 00000000000..03139e71ef1
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/AbstractObjcTypeMetadata.java
@@ -0,0 +1,70 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+import ghidra.app.util.bin.format.objc.objc1.Objc1TypeMetadata;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.listing.Program;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public abstract class AbstractObjcTypeMetadata implements Closeable {
+
+	protected Program program;
+	protected TaskMonitor monitor;
+	protected MessageLog log;
+	protected ObjcState state;
+
+	/**
+	 * Creates a new {@link AbstractObjcTypeMetadata}
+	 * 
+	 * @param state The {@link ObjcState state}
+	 * @param program The {@link Program}
+	 * @param monitor A cancellable task monitor
+	 * @param log The log
+	 * @throws IOException if there was an IO-related error
+	 * @throws CancelledException if the user cancelled the operation
+	 */
+	public AbstractObjcTypeMetadata(ObjcState state, Program program, TaskMonitor monitor,
+			MessageLog log) throws IOException, CancelledException {
+		this.state = state;
+		this.program = program;
+		this.monitor = monitor;
+		this.log = log;
+	}
+
+	/**
+	 * Applies the type metadata to the program
+	 */
+	public abstract void applyTo();
+
+	/**
+	 * Convenience method to perform logging
+	 * 
+	 * @param message The message to log
+	 */
+	public void log(String message) {
+		log.appendMsg(Objc1TypeMetadata.class.getSimpleName(), message);
+	}
+
+	@Override
+	public void close() {
+		state.close();
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethod.java
similarity index 52%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethod.java
index cee719b8553..bdafba68173 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethod.java
@@ -4,38 +4,33 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
 import ghidra.program.model.address.Address;
+import ghidra.program.model.listing.Program;
 import ghidra.program.model.symbol.Namespace;
+import ghidra.util.task.TaskMonitor;
 
-public abstract class ObjectiveC_Method implements StructConverter {
-	protected ObjectiveC1_State _state;
-	protected long _index;
-	protected ObjectiveC_MethodType _methodType;
+public abstract class ObjcMethod extends ObjcTypeMetadataStructure {
+	protected ObjcMethodType _methodType;
 
-	protected ObjectiveC_Method(ObjectiveC1_State state, BinaryReader reader, ObjectiveC_MethodType methodType) {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	public ObjcMethod(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType) {
+		super(program, state, reader.getPointerIndex());
 		this._methodType = methodType;
 	}
 
-	public final long getIndex() {
-		return _index;
-	}
-
-	public final ObjectiveC_MethodType getMethodType() {
+	public final ObjcMethodType getMethodType() {
 		return _methodType;
 	}
 
@@ -45,7 +40,8 @@ public final ObjectiveC_MethodType getMethodType() {
 
 	public abstract long getImplementation();
 
-	public void applyTo(Namespace namespace) throws Exception {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
 		long implementation = getImplementation();
 
 		if (implementation == 0) {
@@ -55,18 +51,19 @@ public void applyTo(Namespace namespace) throws Exception {
 			return;
 		}
 
-		boolean isThumbCode = ObjectiveC1_Utilities.isThumb(_state.program, implementation);
+		boolean isThumbCode = ObjcUtils.isThumb(program, implementation);
 
 		if (isThumbCode) {
 			implementation -= 1;
 		}
 
-		Address implementationAddress = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(implementation);
-		ObjectiveC1_Utilities.createSymbol(_state.program, namespace, getName(), implementationAddress);
-		_state.methodMap.put(implementationAddress, this);
+		Address implementationAddress =
+			program.getAddressFactory().getDefaultAddressSpace().getAddress(implementation);
+		ObjcUtils.createSymbol(program, namespace, getName(), implementationAddress);
+		state.methodMap.put(implementationAddress, this);
 
 		if (isThumbCode) {
-			_state.thumbCodeLocations.add(implementationAddress);
+			state.thumbCodeLocations.add(implementationAddress);
 		}
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodList.java
similarity index 51%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodList.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodList.java
index 28f5e6965d8..7161c1abc2d 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodList.java
@@ -4,58 +4,58 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.DataType;
+import ghidra.program.model.listing.Program;
 import ghidra.program.model.symbol.Namespace;
 import ghidra.util.Msg;
+import ghidra.util.task.TaskMonitor;
 
-public abstract class ObjectiveC_MethodList implements StructConverter {
+public abstract class ObjcMethodList extends ObjcTypeMetadataStructure {
 	private String _className;
-	protected ObjectiveC1_State _state;
-	protected long _index = -1;
 
-	protected List<ObjectiveC_Method> methods = new ArrayList<ObjectiveC_Method>();
+	protected List<ObjcMethod> methods = new ArrayList<ObjcMethod>();
 
-	protected ObjectiveC_MethodList(ObjectiveC1_State state, BinaryReader reader,
+	protected ObjcMethodList(Program program, ObjcState state, BinaryReader reader,
 			String className) {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+		super(program, state, reader.getPointerIndex());
 		this._className = className;
 	}
 
-	public List<ObjectiveC_Method> getMethods() {
+	public List<ObjcMethod> getMethods() {
 		return methods;
 	}
 
-	public void applyTo(Namespace namespace) throws Exception {
-		if (_index == 0) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (base == 0) {
 			return;
 		}
-		if (_state.beenApplied.contains(_index)) {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, _index);
+		Address address = ObjcUtils.toAddress(program, base);
 		DataType dt = toDataType();
 		try {
-			ObjectiveC1_Utilities.applyData(_state.program, dt, address);
+			ObjcUtils.createData(program, dt, address);
 		}
 		catch (Exception e) {
 			Msg.warn(this, "Could not create " + dt.getName() + " @" + address);
@@ -63,16 +63,16 @@ public void applyTo(Namespace namespace) throws Exception {
 
 		try {
 			//creates a symbol on the method list data structure
-			Namespace methodListNamespace = ObjectiveC1_Utilities.createNamespace(_state.program,
-				ObjectiveC1_Constants.NAMESPACE, _className);
-			ObjectiveC1_Utilities.createSymbol(_state.program, methodListNamespace,
-				namespace.getName(), address);
+			Namespace methodListNamespace =
+				ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, _className);
+			ObjcUtils.createSymbol(program, methodListNamespace, namespace.getName(), address);
 		}
 		catch (Exception e) {
+			// do nothing
 		}
 
-		for (ObjectiveC_Method method : getMethods()) {
-			method.applyTo(namespace);
+		for (ObjcMethod method : getMethods()) {
+			method.applyTo(namespace, monitor);
 		}
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodType.java
similarity index 82%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodType.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodType.java
index 0924de54868..a60a62ea7f7 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_MethodType.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcMethodType.java
@@ -1,27 +1,26 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc;
 
-public enum ObjectiveC_MethodType {
+public enum ObjcMethodType {
 	CLASS('+'), INSTANCE('-');
 
 	private char indicator;
 
-	private ObjectiveC_MethodType(char indicator) {
+	private ObjcMethodType(char indicator) {
 		this.indicator = indicator;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcState.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcState.java
new file mode 100644
index 00000000000..d876da30808
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcState.java
@@ -0,0 +1,75 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc;
+
+import java.io.Closeable;
+import java.util.*;
+
+import ghidra.app.util.bin.format.macho.dyld.LibObjcOptimization;
+import ghidra.app.util.bin.format.objc.objc1.Objc1TypeEncodings;
+import ghidra.app.util.bin.format.objc.objc2.Objc2Class;
+import ghidra.app.util.bin.format.objc.objc2.Objc2InstanceVariable;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.listing.Program;
+
+public class ObjcState implements Closeable {
+
+	/**
+	 * If an index is contained in this set, then the corresponding data structure has been applied 
+	 * to the program.
+	 */
+	public final Set<Long> beenApplied = new HashSet<Long>();
+
+	/**
+	 * A map of method addresses to mangled signature strings.
+	 */
+	public final Map<Address, ObjcMethod> methodMap = new HashMap<Address, ObjcMethod>();
+
+	/**
+	 * If an address is contained in this set, then it is thumb code.
+	 */
+	public final Set<Address> thumbCodeLocations = new HashSet<Address>();
+
+	/**
+	 * A map of the index where the class structure was defined to instantiated class object.
+	 */
+	public final Map<Long, Objc2Class> classIndexMap = new HashMap<Long, Objc2Class>();
+
+	/**
+	 * A map of instance variable addresses to mangled type strings.
+	 */
+	public final Map<Address, Objc2InstanceVariable> variableMap =
+		new HashMap<Address, Objc2InstanceVariable>();
+
+	/**
+	 * The dyld_shared_cache libobjc objc_opt_t structure, if it exists
+	 */
+	public LibObjcOptimization libObjcOptimization = null;
+
+	public final Objc1TypeEncodings encodings;
+
+	public ObjcState(Program program, CategoryPath categoryPath) {
+		this.encodings = new Objc1TypeEncodings(program.getDefaultPointerSize(), categoryPath);
+	}
+
+	@Override
+	public void close() {
+		beenApplied.clear();
+		methodMap.clear();
+		thumbCodeLocations.clear();
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcTypeMetadataStructure.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcTypeMetadataStructure.java
new file mode 100644
index 00000000000..fcae08e03ae
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcTypeMetadataStructure.java
@@ -0,0 +1,99 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc;
+
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.task.TaskMonitor;
+
+/**
+ * Implemented by all Objective-C type metadata structures
+ */
+public abstract class ObjcTypeMetadataStructure implements StructConverter {
+
+	public static final String DATA_TYPE_CATEGORY = "/ObjcTypeMetadata";
+
+	protected Program program;
+	protected ObjcState state;
+	protected long base;
+	protected int pointerSize;
+	protected boolean is32bit;
+	protected boolean isArm;
+
+	public ObjcTypeMetadataStructure(Program program, ObjcState state, long base) {
+		this.program = program;
+		this.state = state;
+		this.base = base;
+		this.pointerSize = program.getDefaultPointerSize();
+		this.is32bit = pointerSize == 4;
+		this.isArm = program.getLanguage()
+				.getProcessor()
+				.equals(Processor.findOrPossiblyCreateProcessor("ARM"));
+	}
+
+	/**
+	 * {@return the {@link Program} associated with this {@link ObjcTypeMetadataStructure}}
+	 */
+	public Program getProgram() {
+		return program;
+	}
+
+	/**
+	 * {@return the base "address" of this {@link ObjcTypeMetadataStructure}}
+	 */
+	public long getBase() {
+		return base;
+	}
+
+	/**
+	 * {@return the {@link ObjcState state} of this {@link ObjcTypeMetadataStructure}}
+	 */
+	public ObjcState getState() {
+		return state;
+	}
+
+	/**
+	 * {@return the generic pointer size used by this {@link ObjcTypeMetadataStructure}}
+	 */
+	public int getPointerSize() {
+		return pointerSize;
+	}
+
+	/**
+	 * {@return whether or not the pointer size is 32-bit}
+	 */
+	public boolean is32bit() {
+		return is32bit;
+	}
+
+	/**
+	 * {@return whether or not this {@link ObjcTypeMetadataStructure} is for the ARM-processor}
+	 */
+	public boolean isArm() {
+		return isArm;
+	}
+
+	/**
+	 * Applies this {@link ObjcTypeMetadataStructure} to the program
+	 * 
+	 * @param namespace An optional {@link Namespace} to apply to
+	 * @param monitor A cancellable monitor
+	 * @throws Exception if an error occurred
+	 */
+	public abstract void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception;
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcUtils.java
new file mode 100644
index 00000000000..af90496d732
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/ObjcUtils.java
@@ -0,0 +1,372 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.*;
+
+import ghidra.app.cmd.data.CreateDataCmd;
+import ghidra.app.cmd.disassemble.DisassembleCommand;
+import ghidra.app.cmd.function.CreateFunctionCmd;
+import ghidra.app.cmd.register.SetRegisterCmd;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.framework.cmd.BackgroundCommand;
+import ghidra.framework.cmd.Command;
+import ghidra.program.database.symbol.ClassSymbol;
+import ghidra.program.model.address.*;
+import ghidra.program.model.data.*;
+import ghidra.program.model.data.DataUtilities.ClearDataMode;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.Memory;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.symbol.*;
+import ghidra.program.model.util.CodeUnitInsertionException;
+import ghidra.util.Msg;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+import ghidra.util.task.TaskMonitor;
+
+public final class ObjcUtils {
+
+	/**
+	 * {@return the next read index value}
+	 * <p>
+	 * If {@code is32bit} is true, then 4 bytes will be read to form the index. Otherwise, 8 bytes
+	 * will be read to form the index.
+	 * 
+	 * @param reader A {@link BinaryReader} positioned at the start of the index to read
+	 * @param is32bit True if the index is 32-bit; false if 64-bit;
+	 * @throws IOException if an IO-related error occurred
+	 */
+	public static long readNextIndex(BinaryReader reader, boolean is32bit) throws IOException {
+		return is32bit ? reader.readNextUnsignedInt() : reader.readNextLong();
+	}
+
+	/**
+	 * {@return the string referenced at the next read pointer, or {@code null} if the pointer is
+	 * 0}
+	 * <p>
+	 * If {@code is32bit} is true, then 4 bytes will be read to form the pointer. Otherwise, 8 bytes
+	 * will be read to form the pointer.
+	 * 
+	 * @param reader A {@link BinaryReader} positioned at the start of the string pointer to read
+	 * @param is32bit True if the string pointer is 32-bit; false if 64-bit;
+	 * @throws IOException if an IO-related error occurred
+	 */
+	public static String dereferenceAsciiString(BinaryReader reader, boolean is32bit)
+			throws IOException {
+		long stringIndex = readNextIndex(reader, is32bit);
+		return stringIndex != 0 ? reader.readAsciiString(stringIndex) : null;
+	}
+
+	/**
+	 * {@return whether or not the given address is THUMB code}
+	 * 
+	 * @param program The {@link Program}
+	 * @param address The {@link Address} to check
+	 */
+	public static boolean isThumb(Program program, Address address) {
+		Processor ARM = Processor.findOrPossiblyCreateProcessor("ARM");
+		if (program.getLanguage().getProcessor().equals(ARM)) {
+			MemoryBlock block = program.getMemory().getBlock(address);
+			if (block != null && block.isExecute()) {
+				return (address.getOffset() % 2) != 0;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * {@return whether or not the given address is THUMB code}
+	 * 
+	 * @param program The {@link Program}
+	 * @param address The address to check
+	 */
+	public static boolean isThumb(Program program, long address) {
+		return isThumb(program, toAddress(program, address));
+	}
+
+	/**
+	 * If needed, sets the TMode bit at the specified address
+	 * 
+	 * @param program The {@link Program}
+	 * @param state The {@link ObjcState state}
+	 * @param address The {@link Address} to set
+	 */
+	public static void setThumbBit(Program program, ObjcState state, Address address) {
+		if (state.thumbCodeLocations.contains(address)) {
+			Register tmodeRegister = program.getLanguage().getRegister("TMode");
+			if (tmodeRegister != null) {
+				Command<Program> c =
+					new SetRegisterCmd(tmodeRegister, address, address, BigInteger.valueOf(1));
+				c.applyTo(program);
+			}
+		}
+	}
+
+	/**
+	 * {@return an {@link Address} that corresponds to the given offset in the default address 
+	 * space}
+	 * 
+	 * @param program The {@link Program}
+	 * @param offset The offset to convert to an {@link Address}
+	 */
+	public static Address toAddress(Program program, long offset) {
+		return program.getAddressFactory().getDefaultAddressSpace().getAddress(offset);
+	}
+
+	/**
+	 * Applies the data type at the specified address
+	 * 
+	 * @param program The {@link Program}
+	 * @param dt The {@link DataType} to apply
+	 * @param address The {@link Address} to apply the data type at
+	 * @throws CodeUnitInsertionException if data creation failed
+	 */
+	public static void createData(Program program, DataType dt, Address address)
+			throws CodeUnitInsertionException {
+		Data data = program.getListing().getDefinedDataAt(address);
+		if (data != null && data.getDataType().isEquivalent(dt)) {
+			return;
+		}
+
+		// Clear possible pointers created on import from following pointer chains
+		DataUtilities.createData(program, address, dt, -1,
+			ClearDataMode.CLEAR_ALL_DEFAULT_CONFLICT_DATA);
+	}
+
+	/**
+	 * Creates a string data type at the given address
+	 * 
+	 * @param program The {@link Program}
+	 * @param address The {@link Address} where to create the string at
+	 * @return The string, or {@code null} if it didn't get created
+	 */
+	public static String createString(Program program, Address address) {
+		Data data = program.getListing().getDataAt(address);
+		if (data == null) {
+			CreateDataCmd cmd = new CreateDataCmd(address, new StringDataType());
+			cmd.applyTo(program);
+			data = program.getListing().getDefinedDataAt(address);
+		}
+		if (data == null) {
+			return null;
+		}
+		Object object = data.getValue();
+		if (object instanceof String str) {
+			return str;
+		}
+		Msg.error(null, "Unable to locate string at " + address);
+		return null; // error condition, a string should exist here
+	}
+
+	/**
+	 * {@return the namespace inside the given parent namespace, or a newly created one if it
+	 * doesn't exist}
+	 * 
+	 * @param program The {@link Program}
+	 * @param parentNamespace The parent namespace
+	 * @param namespaceName The name of the namespace to get/create
+	 * @throws DuplicateNameException if another label exists with the given name
+	 * @throws InvalidInputException if the given name is invalid
+	 */
+	private static Namespace getNamespace(Program program, Namespace parentNamespace,
+			String namespaceName) throws DuplicateNameException, InvalidInputException {
+		SymbolTable symbolTable = program.getSymbolTable();
+		Namespace namespace = symbolTable.getNamespace(namespaceName, parentNamespace);
+		if (namespace != null) {
+			return namespace;
+		}
+		return symbolTable.createNameSpace(parentNamespace, namespaceName, SourceType.IMPORTED);
+	}
+
+	/**
+	 * {@return the class inside the given parent namespace, or a newly created one if it
+	 * doesn't exist}
+	 * 
+	 * @param program The {@link Program}
+	 * @param parentNamespace The parent namespace
+	 * @param namespaceName The name of the class namespace to get/create
+	 * @throws DuplicateNameException if another label exists with the given name
+	 * @throws InvalidInputException if the given name is invalid
+	 */
+	public static Namespace getClassNamespace(Program program, Namespace parentNamespace,
+			String namespaceName) throws DuplicateNameException, InvalidInputException {
+		SymbolTable symbolTable = program.getSymbolTable();
+		Symbol symbol = symbolTable.getClassSymbol(namespaceName, parentNamespace);
+		if (symbol instanceof ClassSymbol clsSymbol) {
+			if (clsSymbol.getName().equals(namespaceName)) {
+				return clsSymbol.getObject();
+			}
+		}
+		return symbolTable.createClass(parentNamespace, namespaceName, SourceType.IMPORTED);
+	}
+
+	/**
+	 * {@return a newly created primary {@link Symbol}
+	 *
+	 * @param program The {@link Program}
+	 * @param parentNamespace The parent namespace
+	 * @param symbolName The symbol name
+	 * @param symbolAddress The symbol {@link Address}
+	 * @throws InvalidInputException if the given name is invalid
+	 */
+	public static Symbol createSymbol(Program program, Namespace parentNamespace, String symbolName,
+			Address symbolAddress) throws InvalidInputException {
+		Symbol symbol = program.getSymbolTable()
+				.createLabel(symbolAddress, symbolName, parentNamespace, SourceType.IMPORTED);
+		symbol.setPrimary();
+		return symbol;
+	}
+
+	/**
+	 * {@return a newly created namespace hierarchy formed from the list of given strings}
+	 * 
+	 * @param program The {@link Program}
+	 * @param namespacePath The namespace path
+	 * @throws DuplicateNameException if another label exists with the given name
+	 * @throws InvalidInputException if the given name is invalid
+	 */
+	public static Namespace createNamespace(Program program, String... namespacePath)
+			throws DuplicateNameException, InvalidInputException {
+		Namespace parentNamespace = program.getGlobalNamespace();
+		Namespace namespace = null;
+		for (String namespaceName : namespacePath) {
+			namespace = getNamespace(program, parentNamespace, namespaceName);
+			parentNamespace = namespace;
+		}
+		return namespace;
+	}
+
+	/**
+	 * Creates methods
+	 * 
+	 * @param program The {@link Program}
+	 * @param state The {@link ObjcState state}
+	 * @param log The {@link MessageLog log}
+	 * @param monitor A cancellable monitor
+	 */
+	public final static void createMethods(Program program, ObjcState state, MessageLog log,
+			TaskMonitor monitor) {
+		monitor.initialize(state.methodMap.size(), "Creating Objective-C Methods...");
+
+		Set<Address> addresses = state.methodMap.keySet();
+		for (Address address : addresses) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress();
+
+			ObjcUtils.setThumbBit(program, state, address);
+
+			BackgroundCommand<Program> command = null;
+
+			command = new DisassembleCommand(address, null, true);
+			command.applyTo(program, monitor);
+
+			command = new CreateFunctionCmd(address);
+			command.applyTo(program, monitor);
+
+			//command = new FunctionStackAnalysisCmd(address, false);
+			//command.applyTo(state.program, state.monitor);
+
+			ObjcMethod method = state.methodMap.get(address);
+
+			try {
+				state.encodings.processMethodSignature(program, address, method.getTypes(),
+					method.getMethodType());
+			}
+			catch (Exception e) {
+				Msg.error(ObjcUtils.class, "Unhandled method signature: " + e.getMessage(), e);
+			}
+		}
+	}
+
+	/**
+	 * Removes references to the NULL address and adjusts THUMB references to no longer be offcut
+	 * 
+	 * @param sectionNames The names of the sections to fix
+	 * @param program The {@link Program}
+	 * @param monitor A cancellable monitor
+	 */
+	public final static void fixupReferences(List<String> sectionNames, Program program,
+			TaskMonitor monitor) {
+
+		AddressSet addressSet = new AddressSet();
+
+		sectionNames.stream()
+				.map(program.getMemory()::getBlock)
+				.filter(Objects::nonNull)
+				.forEach(b -> addressSet.addRange(b.getStart(), b.getEnd()));
+
+		monitor.initialize(addressSet.getNumAddresses(), "Fixing References...");
+		ReferenceManager referenceManager = program.getReferenceManager();
+		AddressIterator referenceIterator =
+			referenceManager.getReferenceSourceIterator(addressSet, true);
+		while (referenceIterator.hasNext()) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress();
+			Address sourceAddress = referenceIterator.next();
+			Reference[] references = referenceManager.getReferencesFrom(sourceAddress);
+			for (Reference reference : references) {
+				if (monitor.isCancelled()) {
+					break;
+				}
+				if (reference.getToAddress().getOffset() == 0x0) {
+					referenceManager.delete(reference);
+				}
+				if (ObjcUtils.isThumb(program, reference.getToAddress())) {
+					referenceManager.delete(reference);
+					referenceManager.addMemoryReference(reference.getFromAddress(),
+						reference.getToAddress().subtract(1), reference.getReferenceType(),
+						reference.getSource(), reference.getOperandIndex());
+				}
+			}
+		}
+	}
+
+	/**
+	 * Sets the given block names as read-only
+	 * 
+	 * @param memory The {@link Memory}
+	 * @param blockNames A {@link List} of block names to set as read-only
+	 */
+	public static void setBlocksReadOnly(Memory memory, List<String> blockNames) {
+		blockNames.stream()
+				.map(n -> memory.getBlock(n))
+				.filter(Objects::nonNull)
+				.forEach(b -> b.setWrite(false));
+	}
+
+	/**
+	 * {@return a {@link List} of {@link MemoryBlock}s that match the given section name}
+	 * 
+	 * @param section The section name
+	 * @param program The {@link Program}
+	 */
+	public static List<MemoryBlock> getObjcBlocks(String section, Program program) {
+		return Arrays.stream(program.getMemory().getBlocks())
+				.filter(b -> b.getName().equals(section))
+				.toList();
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Category.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Category.java
new file mode 100644
index 00000000000..bb812070351
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Category.java
@@ -0,0 +1,126 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1Category extends ObjcTypeMetadataStructure {
+	public static final long SIZEOF = 0;
+
+	private String category_name;
+	private String class_name;
+	private Objc1MethodList instance_methods;
+	private Objc1MethodList class_methods;
+	private Objc1ProtocolList protocols;
+	private int unknown0;
+	private int unknown1;
+
+	public Objc1Category(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		category_name = reader.readAsciiString(reader.readNextInt());
+		class_name = reader.readAsciiString(reader.readNextInt());
+		instance_methods = new Objc1MethodList(program, state, reader.clone(reader.readNextInt()),
+			ObjcMethodType.INSTANCE);
+		class_methods = new Objc1MethodList(program, state, reader.clone(reader.readNextInt()),
+			ObjcMethodType.CLASS);
+		protocols = new Objc1ProtocolList(program, state, reader.clone(reader.readNextInt()));
+
+		if (isArm) {
+			unknown0 = reader.readNextInt();
+			unknown1 = reader.readNextInt();
+		}
+	}
+
+	public String getCategoryName() {
+		return category_name;
+	}
+
+	public String getClassName() {
+		return class_name;
+	}
+
+	public Objc1MethodList getInstanceMethods() {
+		return instance_methods;
+	}
+
+	public Objc1MethodList getClassMethods() {
+		return class_methods;
+	}
+
+	public Objc1ProtocolList getProtocols() {
+		return protocols;
+	}
+
+	public int getUnknown0() {
+		return unknown0;
+	}
+
+	public int getUnknown1() {
+		return unknown1;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		String name = "objc_category";
+		StructureDataType struct = new StructureDataType(name, 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "category_name", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "class_name", null);
+		struct.add(
+			PointerDataType.getPointer(Objc1MethodList.toGenericDataType(pointerSize), pointerSize),
+			"instance_methods", null);
+		struct.add(
+			PointerDataType.getPointer(Objc1MethodList.toGenericDataType(pointerSize), pointerSize),
+			"class_methods", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolList.toGenericDataType(pointerSize),
+			pointerSize), "protocols", null);
+		if (isArm) {
+			struct.add(DWORD, "unknown0", null);
+			struct.add(DWORD, "unknown1", null);
+		}
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
+			return;
+		}
+		state.beenApplied.add(base);
+
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
+		DataType dt = toDataType();
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
+
+		Namespace categoryNamespace = ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE,
+			"Categories", class_name + '(' + category_name + ')');
+
+		instance_methods.applyTo(categoryNamespace, monitor);
+		class_methods.applyTo(categoryNamespace, monitor);
+		protocols.applyTo(namespace, monitor);
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Class.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Class.java
new file mode 100644
index 00000000000..39db92029da
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Class.java
@@ -0,0 +1,152 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1Class extends ObjcTypeMetadataStructure {
+	public final static String NAME = "objc_class";
+	public static final long SIZEOF = 0x30;
+
+	private Objc1MetaClass isa;
+	private String super_class;
+	private String name;
+	private int version;
+	private int info;
+	private int instance_size;
+	private Objc1InstanceVariableList variable_list;
+	private Objc1MethodList method_list;
+	private int cache;
+	private Objc1ProtocolList protocols;
+	private int unknown0;
+	private int unknown1;
+
+	public Objc1Class(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		isa = new Objc1MetaClass(program, state, reader.clone(reader.readNextInt()));
+		super_class = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		name = reader.readAsciiString(reader.readNextInt());
+		version = reader.readNextInt();
+		info = reader.readNextInt();
+		instance_size = reader.readNextInt();
+		variable_list =
+			new Objc1InstanceVariableList(program, state, reader.clone(reader.readNextInt()));
+		method_list = new Objc1MethodList(program, state, reader.clone(reader.readNextInt()),
+			ObjcMethodType.INSTANCE);
+		cache = reader.readNextInt();
+		protocols = new Objc1ProtocolList(program, state, reader.clone(reader.readNextInt()));
+		unknown0 = reader.readNextInt();
+		unknown1 = reader.readNextInt();
+	}
+
+	public Objc1MetaClass getISA() {
+		return isa;
+	}
+
+	public String getSuperClass() {
+		return super_class;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public int getVersion() {
+		return version;
+	}
+
+	public int getInfo() {
+		return info;
+	}
+
+	public int getInstanceSize() {
+		return instance_size;
+	}
+
+	public Objc1InstanceVariableList getInstanceVariableList() {
+		return variable_list;
+	}
+
+	public Objc1MethodList getMethodList() {
+		return method_list;
+	}
+
+	public int getCache() {
+		return cache;
+	}
+
+	public Objc1ProtocolList getProtocols() {
+		return protocols;
+	}
+
+	public int getUnknown0() {
+		return unknown0;
+	}
+
+	public int getUnknown1() {
+		return unknown1;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureDataType struct = new StructureDataType(NAME, 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(isa.toDataType(), pointerSize), "isa", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "super_class", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "name", null);
+		struct.add(DWORD, "version", null);
+		struct.add(DWORD, "info", null);
+		struct.add(DWORD, "instance_size", null);
+		struct.add(PointerDataType.getPointer(Objc1InstanceVariableList.toGenericDataType(),
+			pointerSize), "instance_vars", null);
+		struct.add(PointerDataType.getPointer(Objc1MethodList.toGenericDataType(pointerSize),
+			pointerSize), "method_lists", null);
+		struct.add(DWORD, "cache", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolList.toGenericDataType(pointerSize),
+			pointerSize), "protocols", null);
+		struct.add(DWORD, "unknown0", null);
+		struct.add(DWORD, "unknown1", null);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
+		DataType dt = toDataType();
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
+		program.getSymbolTable().createLabel(address, "objc_class_" + name, SourceType.ANALYSIS);
+
+		Namespace classNamespace = ObjcUtils.getClassNamespace(program, null, name);
+
+		isa.applyTo(namespace, monitor);
+		variable_list.applyTo(namespace, monitor);
+		method_list.applyTo(classNamespace, monitor);
+
+		//don't do protocols here... they are applied independent
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Constants.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Constants.java
similarity index 92%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Constants.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Constants.java
index d7cb1128bd3..f58097cf697 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Constants.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Constants.java
@@ -4,26 +4,26 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.app.util.opinion.MachoLoader;
-import ghidra.program.model.data.CategoryPath;
-import ghidra.program.model.listing.Program;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.List;
 
-public final class ObjectiveC1_Constants {
+import ghidra.app.util.opinion.MachoLoader;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.listing.Program;
+
+public final class Objc1Constants {
 
 	public final static String NAMESPACE = "objc";
 
@@ -60,15 +60,16 @@ public final class ObjectiveC1_Constants {
 	 */
 	public final static List<String> getObjectiveCSectionNames() {
 		List<String> sectionNames = new ArrayList<String>();
-		Field [] declaredFields = ObjectiveC1_Constants.class.getDeclaredFields();
+		Field [] declaredFields = Objc1Constants.class.getDeclaredFields();
 		for (Field field : declaredFields) {
 			try {
-				if (field.getName().startsWith(SECTION_FIELD_NAME_PREFIX)) {
-					String name = (String)field.get(null);
+				if (field.get(null) instanceof String name &&
+					name.startsWith(SECTION_FIELD_NAME_PREFIX)) {
 					sectionNames.add(name);
 				}
 			}
-			catch (Exception e) {
+			catch (IllegalAccessException e) {
+				// do nothing
 			}
 		}
 		return sectionNames;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariable.java
similarity index 52%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariable.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariable.java
index db6cf0e6392..c1ec9bead68 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariable.java
@@ -13,30 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-import java.io.IOException;
-
-public class ObjectiveC1_InstanceVariable implements StructConverter {
-	private ObjectiveC1_State _state;
-	private long _index;
-
+public class Objc1InstanceVariable extends ObjcTypeMetadataStructure {
 	private String name;
 	private String type;
 	private int offset;
 
-	ObjectiveC1_InstanceVariable(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	Objc1InstanceVariable(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
 
-		name = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		type = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		type = ObjcUtils.dereferenceAsciiString(reader, is32bit);
 		offset = reader.readNextInt();
 	}
 
@@ -55,22 +55,23 @@ public int getOffset() {
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType("objc_ivar", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "ivar_name", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "ivar_type", null);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "ivar_name", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "ivar_type", null);
 		struct.add(DWORD, "ivar_offset", null);
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
 		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariableList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariableList.java
similarity index 58%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariableList.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariableList.java
index 1be33a708c6..8fcdc3d9223 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_InstanceVariableList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1InstanceVariableList.java
@@ -13,38 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.ObjcState;
+import ghidra.app.util.bin.format.objc.ObjcTypeMetadataStructure;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC1_InstanceVariableList implements StructConverter {
+public class Objc1InstanceVariableList extends ObjcTypeMetadataStructure {
 	public static final String NAME = "objc_method_list";
 
-	private ObjectiveC1_State _state;
-	private long _index;
-
 	private int ivar_count;
-	private List<ObjectiveC1_InstanceVariable> ivar_list = new ArrayList<ObjectiveC1_InstanceVariable>();
+	private List<Objc1InstanceVariable> ivar_list = new ArrayList<Objc1InstanceVariable>();
 
-	ObjectiveC1_InstanceVariableList(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-		if (_index == 0) {
+	Objc1InstanceVariableList(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+		if (base == 0) {
 			return;
 		}
 
 		ivar_count = reader.readNextInt();
 
 		for (int i = 0 ; i < ivar_count ; ++i) {
-			ivar_list.add(new ObjectiveC1_InstanceVariable(state, reader));
+			ivar_list.add(new Objc1InstanceVariable(program, state, reader));
 		}
 	}
 
@@ -52,13 +53,13 @@ public int getInstanceVariableCount() {
 		return ivar_count;
 	}
 
-	public List<ObjectiveC1_InstanceVariable> getInstanceVariables() {
+	public List<Objc1InstanceVariable> getInstanceVariables() {
 		return ivar_list;
 	}
 
 	public static DataType toGenericDataType() throws DuplicateNameException {
 		Structure struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "ivar_count", null);
 		return struct;
 	}
@@ -66,7 +67,7 @@ public static DataType toGenericDataType() throws DuplicateNameException {
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType("objc_ivar_list"+"_"+ivar_count+"_", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "ivar_count", null);
 		if (ivar_count > 0) {
 			DataType dt = ivar_list.get(0).toDataType();
@@ -75,18 +76,19 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		if (_index == 0) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (base == 0) {
 			return;
 		}
-		if (_state.beenApplied.contains(_index)) {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
 		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MetaClass.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MetaClass.java
new file mode 100644
index 00000000000..f418bd0b91b
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MetaClass.java
@@ -0,0 +1,152 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1MetaClass extends ObjcTypeMetadataStructure {
+	private String isa;
+	private String super_class;
+	private String name;
+	private int version;
+	private int info;
+	private int instance_size;
+	private Objc1InstanceVariableList variable_list;
+	private Objc1MethodList method_list;
+	private int cache;
+	private Objc1ProtocolList protocols;
+	private int unknown0;
+	private int unknown1;
+
+	Objc1MetaClass(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		isa = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		super_class = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		version = reader.readNextInt();
+		info = reader.readNextInt();
+		instance_size = reader.readNextInt();
+		variable_list =
+			new Objc1InstanceVariableList(program, state, reader.clone(reader.readNextInt()));
+		method_list = new Objc1MethodList(program, state, reader.clone(reader.readNextInt()),
+			ObjcMethodType.INSTANCE);
+		cache = reader.readNextInt();
+		protocols = new Objc1ProtocolList(program, state, reader.clone(reader.readNextInt()));
+		unknown0 = reader.readNextInt();
+		unknown1 = reader.readNextInt();
+	}
+
+	public String getISA() {
+		return isa;
+	}
+
+	public String getSuperClass() {
+		return super_class;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public int getVersion() {
+		return version;
+	}
+
+	public int getInfo() {
+		return info;
+	}
+
+	public int getInstanceSize() {
+		return instance_size;
+	}
+
+	public Objc1InstanceVariableList getInstanceVariableList() {
+		return variable_list;
+	}
+
+	public Objc1MethodList getMethodList() {
+		return method_list;
+	}
+
+	public int getCache() {
+		return cache;
+	}
+
+	public Objc1ProtocolList getProtocols() {
+		return protocols;
+	}
+
+	public int getUnknown0() {
+		return unknown0;
+	}
+
+	public int getUnknown1() {
+		return unknown1;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureDataType struct = new StructureDataType("objc_metaclass", 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "isa", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "super_class", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "name", null);
+		struct.add(DWORD, "version", null);
+		struct.add(DWORD, "info", null);
+		struct.add(DWORD, "instance_size", null);
+		struct.add(PointerDataType.getPointer(Objc1InstanceVariableList.toGenericDataType(),
+			pointerSize), "instance_vars", null);
+		struct.add(
+			PointerDataType.getPointer(Objc1MethodList.toGenericDataType(pointerSize), pointerSize),
+			"method_lists", null);
+		struct.add(DWORD, "cache", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolList.toGenericDataType(pointerSize),
+			pointerSize), "protocols", null);
+		struct.add(DWORD, "unknown0", null);
+		struct.add(DWORD, "unknown1", null);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
+			return;
+		}
+		state.beenApplied.add(base);
+
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
+		DataType dt = toDataType();
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
+
+		Namespace newNamespace =
+			ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, "Meta-classes", name);
+
+		variable_list.applyTo(namespace, monitor);
+		method_list.applyTo(newNamespace, monitor);
+		protocols.applyTo(namespace, monitor);
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Method.java
similarity index 59%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Method.java
index 3654d8796ca..eade730aae3 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Method.java
@@ -13,35 +13,40 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.util.exception.DuplicateNameException;
 
-public class ObjectiveC1_Method extends ObjectiveC_Method {
+public class Objc1Method extends ObjcMethod {
 	private String name;
 	private String signature;
 	private int address;
 
-	ObjectiveC1_Method(ObjectiveC1_State state, BinaryReader reader, ObjectiveC_MethodType methodType) throws IOException {
-		super(state, reader, methodType);
+	Objc1Method(Program program, ObjcState state, BinaryReader reader, ObjcMethodType methodType)
+			throws IOException {
+		super(program, state, reader, methodType);
 
-		name      = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		signature = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		address   = reader.readNextInt();
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		signature = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		address = reader.readNextInt();
 	}
 
 	@Override
 	public String getName() {
 		return name;
 	}
+
 	@Override
 	public String getTypes() {
 		return signature;
 	}
+
 	@Override
 	public long getImplementation() {
 		return Integer.toUnsignedLong(address);
@@ -50,10 +55,10 @@ public long getImplementation() {
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType("objc_method", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "method_name", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "method_types", null);
-		struct.add(PointerDataType.getPointer(VOID,  _state.pointerSize), "method_imp", null);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "method_name", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "method_types", null);
+		struct.add(PointerDataType.getPointer(VOID, pointerSize), "method_imp", null);
 		return struct;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MethodList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MethodList.java
similarity index 61%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MethodList.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MethodList.java
index 511dccf806a..652eeb81b29 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MethodList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1MethodList.java
@@ -13,37 +13,41 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.util.exception.DuplicateNameException;
 
-public class ObjectiveC1_MethodList extends ObjectiveC_MethodList {
+public class Objc1MethodList extends ObjcMethodList {
 	public static final String NAME = "objc_method_list";
 
-	private ObjectiveC1_MethodList obsolete;
+	private Objc1MethodList obsolete;
 	private int method_count;
 
-	ObjectiveC1_MethodList(ObjectiveC1_State state, BinaryReader reader, ObjectiveC_MethodType methodType) throws IOException {
-		super(state, reader, NAME);
+	Objc1MethodList(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType) throws IOException {
+		super(program, state, reader, NAME);
 
-		if (_index == 0) {
+		if (base == 0) {
 			return;
 		}
 
-		obsolete = new ObjectiveC1_MethodList(state, reader.clone(reader.readNextInt()), methodType );
+		obsolete =
+			new Objc1MethodList(program, state, reader.clone(reader.readNextInt()), methodType);
 
 		method_count = reader.readNextInt();
 
 		for (int i = 0 ; i < method_count ; ++i) {
-			methods.add(new ObjectiveC1_Method(state, reader, methodType));
+			methods.add(new Objc1Method(program, state, reader, methodType));
 		}
 	}
 
-	public ObjectiveC1_MethodList getObsolete() {
+	public Objc1MethodList getObsolete() {
 		return obsolete;
 	}
 
@@ -51,11 +55,11 @@ public int getMethodCount() {
 		return method_count;
 	}
 
-	public static DataType toGenericDataType(ObjectiveC1_State state)
+	public static DataType toGenericDataType(int pointerSize)
 			throws DuplicateNameException {
 		Structure struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(struct, state.pointerSize), "obsolete", null);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(struct, pointerSize), "obsolete", null);
 		struct.add(DWORD, "method_count", null);
 		return struct;
 	}
@@ -63,13 +67,13 @@ public static DataType toGenericDataType(ObjectiveC1_State state)
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType(NAME+"_"+method_count+"_", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		if (obsolete == null) {
-			struct.add(PointerDataType.getPointer(VOID, _state.pointerSize), "obsolete", null);
+			struct.add(PointerDataType.getPointer(VOID, pointerSize), "obsolete", null);
 		}
 		else {
 			DataType obsoleteDT = obsolete.toDataType();
-			struct.add(PointerDataType.getPointer(obsoleteDT, _state.pointerSize), "obsolete", null);
+			struct.add(PointerDataType.getPointer(obsoleteDT, pointerSize), "obsolete", null);
 		}
 		struct.add(DWORD, "method_count", null);
 		if (method_count > 0) {
@@ -78,7 +82,4 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 		}
 		return struct;
 	}
-
-
-
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Module.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Module.java
similarity index 58%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Module.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Module.java
index d6526a242fa..69c08f01378 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Module.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Module.java
@@ -4,48 +4,47 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.data.DataUtilities.ClearDataMode;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.Msg;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC1_Module implements StructConverter {
-	private ObjectiveC1_State _state;
-	private long _index;
-
+public class Objc1Module extends ObjcTypeMetadataStructure {
 	private int version;
 	private int size;
 	private String name;
-	private ObjectiveC1_SymbolTable symbolTable;
+	private Objc1SymbolTable symbolTable;
 
-	public ObjectiveC1_Module(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		_index = reader.getPointerIndex();
+	public Objc1Module(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
 
 		version = reader.readNextInt();
 		size = reader.readNextInt();
-		name = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
 
 		int symbolTableIndex = reader.readNextInt();
 
 		if (symbolTableIndex != 0) {
-			symbolTable = new ObjectiveC1_SymbolTable(state, reader.clone(symbolTableIndex));
+			symbolTable = new Objc1SymbolTable(program, state, reader.clone(symbolTableIndex));
 		}
 	}
 
@@ -61,21 +60,21 @@ public String getName() {
 		return name;
 	}
 
-	public ObjectiveC1_SymbolTable getSymbolTable() {
+	public Objc1SymbolTable getSymbolTable() {
 		return symbolTable;
 	}
 
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address =
-			_state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
 		DataType dt = toDataType();
 		try {
-			DataUtilities.createData(_state.program, address, dt, -1,
+			DataUtilities.createData(program, address, dt, -1,
 				ClearDataMode.CLEAR_ALL_DEFAULT_CONFLICT_DATA);
 		}
 		catch (Exception e) {
@@ -83,19 +82,19 @@ public void applyTo() throws Exception {
 		}
 
 		if (symbolTable != null) {
-			symbolTable.applyTo();
+			symbolTable.applyTo(namespace, monitor);
 		}
 	}
 
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType("objc_module", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "version", null);
 		struct.add(DWORD, "size", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "name", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_SymbolTable.toGenericDataType(),
-			_state.pointerSize), "symtab", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "name", null);
+		struct.add(PointerDataType.getPointer(Objc1SymbolTable.toGenericDataType(), pointerSize),
+			"symtab", null);
 		return struct;
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Protocol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Protocol.java
new file mode 100644
index 00000000000..e1558643432
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1Protocol.java
@@ -0,0 +1,103 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1Protocol extends ObjcTypeMetadataStructure {
+	public final static String NAME = "objc_protocol";
+	public final static int SIZEOF = 20;
+
+	private int isa;
+	private String name;
+	private Objc1ProtocolList protocolList;
+	private Objc1ProtocolMethodList instanceMethods;
+	private Objc1ProtocolMethodList classMethods;
+
+	public Objc1Protocol(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		isa = reader.readNextInt();
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		protocolList = new Objc1ProtocolList(program, state, reader.clone(reader.readNextInt()));
+		instanceMethods = new Objc1ProtocolMethodList(program, state,
+			reader.clone(reader.readNextInt()), ObjcMethodType.INSTANCE);
+		classMethods = new Objc1ProtocolMethodList(program, state,
+			reader.clone(reader.readNextInt()), ObjcMethodType.CLASS);
+	}
+
+	public int getIsa() {
+		return isa;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public Objc1ProtocolList getProtocolList() {
+		return protocolList;
+	}
+
+	public Objc1ProtocolMethodList getInstanceMethods() {
+		return instanceMethods;
+	}
+
+	public Objc1ProtocolMethodList getClassMethods() {
+		return classMethods;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureDataType struct = new StructureDataType(NAME, 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(DWORD, "isa", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "name", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolList.toGenericDataType(pointerSize),
+			pointerSize), "protocolList", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolMethodList.toGenericDataType(state),
+			pointerSize), "instanceMethods", null);
+		struct.add(PointerDataType.getPointer(Objc1ProtocolMethodList.toGenericDataType(state),
+			pointerSize), "classMethods", null);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
+			return;
+		}
+		state.beenApplied.add(base);
+
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
+		DataType dt = toDataType();
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
+
+		protocolList.applyTo(namespace, monitor);
+		instanceMethods.applyTo(namespace, monitor);
+		classMethods.applyTo(namespace, monitor);
+	}
+
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolList.java
new file mode 100644
index 00000000000..6688e7bdef9
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolList.java
@@ -0,0 +1,115 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.ObjcState;
+import ghidra.app.util.bin.format.objc.ObjcTypeMetadataStructure;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1ProtocolList extends ObjcTypeMetadataStructure {
+	public static final String NAME = "objc_protocol_list";
+
+	private Objc1ProtocolList next;
+	private int count;
+	private List<Objc1Protocol> protocols = new ArrayList<Objc1Protocol>();
+
+	Objc1ProtocolList(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+		if (base == 0) {
+			return;
+		}
+
+		next = new Objc1ProtocolList(program, state, reader.clone(reader.readNextInt()));
+
+		count = reader.readNextInt();
+
+		for (int i = 0 ; i < count ; ++i) {
+			int protocolIndex = reader.readNextInt();
+			long oldProtocolIndex = reader.getPointerIndex();
+			reader.setPointerIndex(protocolIndex);
+			protocols.add(new Objc1Protocol(program, state, reader));
+			reader.setPointerIndex(oldProtocolIndex);
+		}
+	}
+
+	public Objc1ProtocolList getNext() {
+		return next;
+	}
+
+	public int getCount() {
+		return count;
+	}
+
+	public List<Objc1Protocol> getProtocols() {
+		return protocols;
+	}
+
+	public static DataType toGenericDataType(int pointerSize) throws DuplicateNameException {
+		Structure struct = new StructureDataType(NAME, 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(struct, pointerSize), "next", null);
+		struct.add(DWORD, "count", null);
+		return struct;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureDataType struct = new StructureDataType(NAME+"_"+count+"_", 0);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(toGenericDataType(pointerSize), pointerSize), "next",
+			null);
+		struct.add(DWORD, "count", null);
+		if (count > 0) {
+			DataType dt =
+				PointerDataType.getPointer(protocols.get(0).toDataType(), pointerSize);
+			struct.add(new ArrayDataType(dt, count, dt.getLength()), "protocols", null);
+		}
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (base == 0) {
+			return;
+		}
+		if (state.beenApplied.contains(base)) {
+			return;
+		}
+		state.beenApplied.add(base);
+
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
+		DataType dt = toDataType();
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
+
+		for (Objc1Protocol protocol : protocols) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			protocol.applyTo(namespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethod.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethod.java
similarity index 53%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethod.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethod.java
index 48f0a583b2d..1c478f53507 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethod.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethod.java
@@ -13,32 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.data.DataType;
-import ghidra.program.model.data.PointerDataType;
-import ghidra.program.model.data.StructureDataType;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-import java.io.IOException;
-
-public class ObjectiveC1_ProtocolMethod implements StructConverter {
+public class Objc1ProtocolMethod extends ObjcTypeMetadataStructure {
 	private static final String NAME = "objc_protocol_method";
 
-	private ObjectiveC1_State _state;
-	private ObjectiveC_MethodType _methodType;
+	private ObjcMethodType _methodType;
 
 	private String name;
 	private String types;
 
-	ObjectiveC1_ProtocolMethod(ObjectiveC1_State state, BinaryReader reader, ObjectiveC_MethodType methodType) throws IOException {
-		this._state = state;
+	Objc1ProtocolMethod(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType) throws IOException {
+		super(program, state, reader.getPointerIndex());
 		this._methodType = methodType;
 
-		name  = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		types = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
+		name = ObjcUtils.dereferenceAsciiString(reader, is32bit);
+		types = ObjcUtils.dereferenceAsciiString(reader, is32bit);
 	}
 
 	public String getName() {
@@ -49,19 +50,21 @@ public String getTypes() {
 		return types;
 	}
 
-	public ObjectiveC_MethodType getMethodType() {
+	public ObjcMethodType getMethodType() {
 		return _methodType;
 	}
 
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "name", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "types", null);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "name", null);
+		struct.add(PointerDataType.getPointer(ASCII, pointerSize), "types", null);
 		return struct;
 	}
 
-	void applyTo() {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		// do nothing
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethodList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethodList.java
similarity index 55%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethodList.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethodList.java
index 8fc8454999d..f7ef8c14976 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolMethodList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1ProtocolMethodList.java
@@ -13,38 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC1_ProtocolMethodList implements StructConverter {
+public class Objc1ProtocolMethodList extends ObjcTypeMetadataStructure {
 	public static final String NAME = "objc_protocol_method_list";
 
-	private ObjectiveC1_State _state;
-	private long _index;
-
 	private int method_count;
-	private List<ObjectiveC1_ProtocolMethod> method_list = new ArrayList<ObjectiveC1_ProtocolMethod>();
+	private List<Objc1ProtocolMethod> method_list = new ArrayList<Objc1ProtocolMethod>();
 
-	ObjectiveC1_ProtocolMethodList(ObjectiveC1_State state, BinaryReader reader, ObjectiveC_MethodType methodType) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-		if (_index == 0) {
+	Objc1ProtocolMethodList(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType) throws IOException {
+		super(program, state, reader.getPointerIndex());
+		if (base == 0) {
 			return;
 		}
 
 		method_count = reader.readNextInt();
 
 		for (int i = 0 ; i < method_count ; ++i) {
-			method_list.add(new ObjectiveC1_ProtocolMethod(state, reader, methodType));
+			method_list.add(new Objc1ProtocolMethod(program, state, reader, methodType));
 		}
 	}
 
@@ -52,14 +52,14 @@ public int getMethodCount() {
 		return method_count;
 	}
 
-	public List<ObjectiveC1_ProtocolMethod> getMethodList() {
+	public List<Objc1ProtocolMethod> getMethodList() {
 		return method_list;
 	}
 
-	public static DataType toGenericDataType(ObjectiveC1_State state)
+	public static DataType toGenericDataType(ObjcState state)
 			throws DuplicateNameException {
 		Structure struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "method_count", null);
 		return struct;
 	}
@@ -67,7 +67,7 @@ public static DataType toGenericDataType(ObjectiveC1_State state)
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct = new StructureDataType(NAME+"_"+method_count+"_", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "method_count", null);
 		if (method_count > 0) {
 			DataType dt = method_list.get(0).toDataType();
@@ -76,25 +76,26 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		if (_index == 0) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (base == 0) {
 			return;
 		}
-		if (_state.beenApplied.contains(_index)) {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
 		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
+		program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
+		program.getListing().createData(address, dt);
 
-		for (ObjectiveC1_ProtocolMethod method : method_list) {
-			if (_state.monitor.isCancelled()) {
+		for (Objc1ProtocolMethod method : method_list) {
+			if (monitor.isCancelled()) {
 				break;
 			}
-			method.applyTo();
+			method.applyTo(namespace, monitor);
 		}
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_SymbolTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1SymbolTable.java
similarity index 66%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_SymbolTable.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1SymbolTable.java
index aecf7421de6..f820de1b903 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_SymbolTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1SymbolTable.java
@@ -4,45 +4,45 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.ObjcState;
+import ghidra.app.util.bin.format.objc.ObjcTypeMetadataStructure;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.data.DataUtilities.ClearDataMode;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.Msg;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC1_SymbolTable implements StructConverter {
+public class Objc1SymbolTable extends ObjcTypeMetadataStructure {
 	public static final String NAME = "objc_symtab";
 
-	private ObjectiveC1_State _state;
-	private long _index;
-
 	private int sel_ref_cnt;
 	private int refs;
 	private short cls_def_cnt;
 	private short cat_def_cnt;
-	private List<ObjectiveC1_Class> classes = new ArrayList<ObjectiveC1_Class>();
-	private List<ObjectiveC1_Category> categories = new ArrayList<ObjectiveC1_Category>();
+	private List<Objc1Class> classes = new ArrayList<Objc1Class>();
+	private List<Objc1Category> categories = new ArrayList<Objc1Category>();
 
-	ObjectiveC1_SymbolTable(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	Objc1SymbolTable(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
 
 		sel_ref_cnt = reader.readNextInt();
 		refs = reader.readNextInt();
@@ -53,7 +53,7 @@ public class ObjectiveC1_SymbolTable implements StructConverter {
 			long classIndex = reader.readNextInt();
 			long oldClassIndex = reader.getPointerIndex();
 			reader.setPointerIndex(classIndex);
-			classes.add(new ObjectiveC1_Class(state, reader));
+			classes.add(new Objc1Class(program, state, reader));
 			reader.setPointerIndex(oldClassIndex);
 		}
 
@@ -61,7 +61,7 @@ public class ObjectiveC1_SymbolTable implements StructConverter {
 			long categoryIndex = reader.readNextInt();
 			long oldCategoryIndex = reader.getPointerIndex();
 			reader.setPointerIndex(categoryIndex);
-			categories.add(new ObjectiveC1_Category(state, reader));
+			categories.add(new Objc1Category(program, state, reader));
 			reader.setPointerIndex(oldCategoryIndex);
 		}
 	}
@@ -82,17 +82,17 @@ public short getCategoryDefinitionCount() {
 		return cat_def_cnt;
 	}
 
-	public List<ObjectiveC1_Class> getClasses() {
+	public List<Objc1Class> getClasses() {
 		return classes;
 	}
 
-	public List<ObjectiveC1_Category> getCategories() {
+	public List<Objc1Category> getCategories() {
 		return categories;
 	}
 
 	public static DataType toGenericDataType() throws DuplicateNameException {
 		Structure struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "sel_ref_cnt", null);
 		struct.add(DWORD, "refs", null);
 		struct.add(WORD, "cls_def_cnt", null);
@@ -104,47 +104,46 @@ public static DataType toGenericDataType() throws DuplicateNameException {
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		StructureDataType struct =
 			new StructureDataType(NAME + "_" + cls_def_cnt + "_" + cat_def_cnt + "_", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc1Constants.CATEGORY_PATH);
 		struct.add(DWORD, "sel_ref_cnt", null);
 		struct.add(DWORD, "refs", null);
 		struct.add(WORD, "cls_def_cnt", null);
 		struct.add(WORD, "cat_def_cnt", null);
 		for (int i = 0; i < cls_def_cnt; ++i) {
-			struct.add(PointerDataType.getPointer(classes.get(i).toDataType(), _state.pointerSize),
+			struct.add(PointerDataType.getPointer(classes.get(i).toDataType(), pointerSize),
 				"class" + i, null);
 		}
 		for (int i = 0; i < cat_def_cnt; ++i) {
-			struct.add(
-				PointerDataType.getPointer(categories.get(i).toDataType(), _state.pointerSize),
+			struct.add(PointerDataType.getPointer(categories.get(i).toDataType(), pointerSize),
 				"category" + i, null);
 		}
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {
 			return;
 		}
-		_state.beenApplied.add(_index);
+		state.beenApplied.add(base);
 
-		Address address =
-			_state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
+		Address address = program.getAddressFactory().getDefaultAddressSpace().getAddress(base);
 		DataType dt = toDataType();
 		try {
-			DataUtilities.createData(_state.program, address, dt, -1,
+			DataUtilities.createData(program, address, dt, -1,
 				ClearDataMode.CLEAR_ALL_DEFAULT_CONFLICT_DATA);
 		}
 		catch (Exception e) {
 			Msg.warn(this, "Could not create " + dt.getName() + " @" + address);
 		}
 
-		_state.program.getListing().getDefinedDataAt(address);
+		program.getListing().getDefinedDataAt(address);
 
-		for (ObjectiveC1_Class clazz : classes) {
-			clazz.applyTo();
+		for (Objc1Class clazz : classes) {
+			clazz.applyTo(namespace, monitor);
 		}
-		for (ObjectiveC1_Category category : categories) {
-			category.applyTo();
+		for (Objc1Category category : categories) {
+			category.applyTo(namespace, monitor);
 		}
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_TypeEncodings.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeEncodings.java
similarity index 98%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_TypeEncodings.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeEncodings.java
index 2050c079d98..11734f861ed 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_TypeEncodings.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeEncodings.java
@@ -4,27 +4,28 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objectiveC;
+package ghidra.app.util.bin.format.objc.objc1;
 
 import java.util.*;
 
 import ghidra.app.cmd.function.ApplyFunctionSignatureCmd;
+import ghidra.app.util.bin.format.objc.ObjcMethodType;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.listing.*;
 import ghidra.program.model.symbol.SourceType;
 import ghidra.util.exception.DuplicateNameException;
 
-public final class ObjectiveC1_TypeEncodings {
+public final class Objc1TypeEncodings {
 	public final static char _C_ID = '@';
 	public final static char _C_CLASS = '#';
 	public final static char _C_SEL = ':';
@@ -98,7 +99,7 @@ public String toString() {
 	private int pointerSize;
 	private CategoryPath categoryPath;
 
-	public ObjectiveC1_TypeEncodings(int pointerSize, CategoryPath categoryPath) {
+	public Objc1TypeEncodings(int pointerSize, CategoryPath categoryPath) {
 		this.pointerSize = pointerSize;
 		this.categoryPath = categoryPath;
 
@@ -108,7 +109,7 @@ public ObjectiveC1_TypeEncodings(int pointerSize, CategoryPath categoryPath) {
 	}
 
 	public void processMethodSignature(Program program, Address methodAddress,
-			String mangledSignature, ObjectiveC_MethodType methodType) {
+			String mangledSignature, ObjcMethodType methodType) {
 		Function method = program.getListing().getFunctionAt(methodAddress);
 		if (method == null) {
 			return;//function might not have been created, prevents NPE in datatype
@@ -215,6 +216,7 @@ private DataType parseDataType(StringBuffer buffer) {
 			dt.setCategoryPath(categoryPath);
 		}
 		catch (DuplicateNameException e) {
+			// do nothing
 		}
 		return dt;
 	}
@@ -432,6 +434,7 @@ private Union parseBitFields(StringBuffer buffer) {
 			bitFieldUnion.setCategoryPath(categoryPath);
 		}
 		catch (DuplicateNameException e) {
+			// do nothing
 		}
 
 		List<String> names = new ArrayList<String>();
@@ -459,6 +462,7 @@ private Union parseBitFields(StringBuffer buffer) {
 			dt.setCategoryPath(categoryPath);
 		}
 		catch (DuplicateNameException e) {
+			// do nothing
 		}
 
 		for (String name : names) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeMetadata.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeMetadata.java
new file mode 100644
index 00000000000..84d07699b35
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc1/Objc1TypeMetadata.java
@@ -0,0 +1,146 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc1;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.MemoryByteProvider;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc1TypeMetadata extends AbstractObjcTypeMetadata {
+
+	private List<Objc1Module> modules = new ArrayList<>();
+	private List<Objc1Protocol> protocols = new ArrayList<>();
+
+	/**
+	 * Creates a new {@link Objc1TypeMetadata}
+	 * 
+	 * @param program The {@link Program}
+	 * @param monitor A cancellable task monitor
+	 * @param log The log
+	 * @throws IOException if there was an IO-related error
+	 * @throws CancelledException if the user cancelled the operation
+	 */
+	public Objc1TypeMetadata(Program program, TaskMonitor monitor, MessageLog log)
+			throws IOException, CancelledException {
+		super(new ObjcState(program, Objc1Constants.CATEGORY_PATH), program, monitor, log);
+		parse();
+	}
+
+	/**
+	 * {@return a {@link List} of {@link Objc1Module modules}}
+	 */
+	public List<Objc1Module> getModules() {
+		return modules;
+	}
+
+	/**
+	 * {@return a {@link List} of {@link Objc1Protocol protocols}}
+	 */
+	public List<Objc1Protocol> getProtocols() {
+		return protocols;
+	}
+
+	/**
+	 * Parses the {@link Objc1TypeMetadata}
+	 * 
+	 * @throws IOException if there was an IO-related error
+	 * @throws CancelledException if the user cancelled the operation
+	 */
+	private void parse() throws IOException, CancelledException {
+		try (MemoryByteProvider provider =
+			MemoryByteProvider.createDefaultAddressSpaceByteProvider(program, false)) {
+			BinaryReader reader = new BinaryReader(provider, !program.getLanguage().isBigEndian());
+		
+			parseModules(Objc1Constants.OBJC_SECTION_MODULE_INFO, reader);
+			parseProtocols(Objc1Constants.OBJC_SECTION_PROTOCOL, reader);
+		}
+	}
+
+	private void parseModules(String section, BinaryReader reader) throws CancelledException {
+		monitor.setMessage("Parsing Objective-C modules...");
+		monitor.setIndeterminate(true);
+		try {
+			for (MemoryBlock block : ObjcUtils.getObjcBlocks(section, program)) {
+				long start = block.getStart().getOffset();
+				long end = block.getEnd().getOffset();
+				reader.setPointerIndex(start);
+				while (reader.getPointerIndex() < end) {
+					monitor.checkCancelled();
+					modules.add(new Objc1Module(program, state, reader));
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse modules from section '" + section + "'");
+		}
+	}
+
+	private void parseProtocols(String section, BinaryReader reader) throws CancelledException {
+		monitor.setMessage("Parsing Objective-C protocols...");
+		monitor.setIndeterminate(true);
+		try {
+			for (MemoryBlock block : ObjcUtils.getObjcBlocks(section, program)) {
+				long start = block.getStart().getOffset();
+				long end = block.getEnd().getOffset();
+				reader.setPointerIndex(start);
+				while (reader.getPointerIndex() < end) {
+					monitor.checkCancelled();
+					protocols.add(new Objc1Protocol(program, state, reader));
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse protocols from section '" + section + "'");
+		}
+	}
+
+	@Override
+	public void applyTo() {
+		for (Objc1Module module : modules) {
+			try {
+				module.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup module: " + module.getName());
+			}
+		}
+		for (Objc1Protocol protocol : protocols) {
+			try {
+				protocol.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup protocol: " + protocol.getName());
+			}
+		}
+
+		ObjcUtils.createMethods(program, state, log, monitor);
+		ObjcUtils.fixupReferences(Objc1Constants.getObjectiveCSectionNames(), program, monitor);
+
+		ObjcUtils.setBlocksReadOnly(program.getMemory(), List.of(
+			Objc1Constants.OBJC_SECTION_DATA,
+			Objc1Constants.OBJC_SECTION_CLASS_REFS,
+			Objc1Constants.OBJC_SECTION_MESSAGE_REFS));
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Cache.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Cache.java
similarity index 59%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Cache.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Cache.java
index f35f63fe13a..7dd9cf9222e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Cache.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Cache.java
@@ -13,30 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.TypedefDataType;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-import java.io.IOException;
-
-public class ObjectiveC2_Cache implements StructConverter {
-	private ObjectiveC2_State _state;
-
+public class Objc2Cache extends ObjcTypeMetadataStructure {
 	private long cache;
 
-	public ObjectiveC2_Cache(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-
-		if (state.is32bit) {
-			cache = reader.readNextInt() & 0xffffffffL;
-		}
-		else {
-			cache = reader.readNextLong();
-		}
+	public Objc2Cache(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+		cache = ObjcUtils.readNextIndex(reader, is32bit);
 	}
 
 	public long getCache() {
@@ -45,12 +40,11 @@ public long getCache() {
 
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
-		if (_state.is32bit) {
-			return new TypedefDataType("Cache", DWORD);
-		}
-		return new TypedefDataType("Cache", QWORD);
+		return new TypedefDataType("Cache", is32bit ? DWORD : QWORD);
 	}
 
-	public void applyTo() throws Exception {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		// do nothing
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Category.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Category.java
new file mode 100644
index 00000000000..a60d58f1d56
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Category.java
@@ -0,0 +1,219 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2Category extends ObjcTypeMetadataStructure {
+	public final static String NAME = "category_t";
+
+	private String name;
+	private Objc2Class cls;
+	private Objc2MethodList instanceMethods;
+	private Objc2MethodList classMethods;
+	private Objc2ProtocolList protocols;
+	private Objc2PropertyList instanceProperties;
+
+	public Objc2Category(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		readName(reader);
+		readClass(reader);
+		if (cls != null && cls.getISA() != null) {
+			readInstanceMethods(reader);
+			readClassMethods(reader);
+			readProtocols(reader);
+			readInstanceProperties(reader);
+		}
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public Objc2Class getCls() {
+		return cls;
+	}
+
+	public Objc2MethodList getInstanceMethods() {
+		return instanceMethods;
+	}
+
+	public Objc2MethodList getClassMethods() {
+		return classMethods;
+	}
+
+	public Objc2ProtocolList getProtocols() {
+		return protocols;
+	}
+
+	public Objc2PropertyList getInstanceProperties() {
+		return instanceProperties;
+	}
+
+	private void readName(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+		if (index != 0 && reader.isValidIndex(index)) {
+			name = reader.readAsciiString(index);
+		}
+	}
+
+	private void readClass(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+
+		if (state.classIndexMap.containsKey(index)) {
+			cls = state.classIndexMap.get(index);
+			return;
+		}
+
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			cls = new Objc2Class(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readInstanceMethods(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			instanceMethods = new Objc2MethodList(program, state, reader, ObjcMethodType.INSTANCE);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readClassMethods(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			classMethods = new Objc2MethodList(program, state, reader, ObjcMethodType.CLASS);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readProtocols(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			protocols = new Objc2ProtocolList(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readInstanceProperties(BinaryReader reader) throws IOException {
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			instanceProperties = new Objc2PropertyList(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StringBuffer buffer = new StringBuffer();
+		buffer.append(NAME);
+
+		if (cls == null) {
+			buffer.append("<no_class>");
+		}
+
+		Structure struct = new StructureDataType(buffer.toString(), 0);
+
+		struct.add(new PointerDataType(STRING), pointerSize, "name", null);
+
+		if (cls == null) {
+			struct.add(new PointerDataType(VOID), pointerSize, "cls", null);
+		}
+		else {
+			struct.add(new PointerDataType(cls.toDataType()), pointerSize, "cls", null);
+		}
+
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"instanceMethods", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"classMethods", null);
+		struct.add(new PointerDataType(Objc2ProtocolList.toGenericDataType(is32bit)), pointerSize,
+			"protocols", null);
+		struct.add(new PointerDataType(Objc2PropertyList.toGenericDataType()), pointerSize,
+			"instanceProperties", null);
+
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+
+		try {
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		try {
+			Namespace categoryNamespace =
+				ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, Objc2Category.NAME);
+			ObjcUtils.createSymbol(program, categoryNamespace, getName(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		String string = null;
+		try {
+			string = cls.getData().getName() + '_' + name + '_';
+		}
+		catch (Exception e) {
+			string = name;
+		}
+		Namespace categoryNamespace =
+			ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, "Categories", string);
+
+		if (cls != null) {
+			cls.applyTo(categoryNamespace, monitor);
+		}
+		if (instanceMethods != null) {
+			instanceMethods.applyTo(categoryNamespace, monitor);
+		}
+		if (classMethods != null) {
+			classMethods.applyTo(categoryNamespace, monitor);
+		}
+		if (protocols != null) {
+			protocols.applyTo(categoryNamespace, monitor);
+		}
+		if (instanceProperties != null) {
+			instanceProperties.applyTo(categoryNamespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Class.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Class.java
new file mode 100644
index 00000000000..b24720c3b54
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Class.java
@@ -0,0 +1,243 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2Class extends ObjcTypeMetadataStructure {
+	public final static String NAME = "class_t";
+
+	private Objc2Class isa;
+	private Objc2Class superclass;
+	private Objc2Cache cache;
+	private Objc2Implementation vtable;
+	private Objc2ClassRW data; // class_rw_t * plus custom rr/alloc flags
+
+	public Objc2Class(Program program, ObjcState state, BinaryReader reader) {
+		super(program, state, reader.getPointerIndex());
+
+		state.classIndexMap.put(base, this);
+
+		// TODO: Some class references point to a GOT entry. These aren't real class structures, 
+		// so don't  parse them.
+
+		try {
+			readISA(reader);
+			readSuperClass(reader);
+			readCache(reader);
+			readVTable(reader);
+			readData(reader);
+		}
+		catch (IOException ioe) {
+			// Couldn't read something, usually a metaclass pointing to an uninitialized section since
+			// runtime 2.0 got rid of the metaclass type.
+		}
+	}
+
+	@Override
+	public boolean equals(Object that) {
+		if (that instanceof Objc2Class) {
+			return this.base == ((Objc2Class) that).base;
+		}
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return (int) base;
+	}
+
+	public Objc2Class getISA() {
+		return isa;
+	}
+
+	public Objc2Class getSuperClass() {
+		return superclass;
+	}
+
+	public Objc2Cache getCache() {
+		return cache;
+	}
+
+	public Objc2Implementation getVTable() {
+		return vtable;
+	}
+
+	public Objc2ClassRW getData() {
+		return data;
+	}
+
+	public long getIndex() {
+		return base;
+	}
+
+	private void readData(BinaryReader reader) throws IOException {
+		long index = 0;
+		try {
+			index = ObjcUtils.readNextIndex(reader, is32bit);
+		}
+		catch (IOException ioe) {
+			//Trying to read uninitialized memory
+			return;
+		}
+
+		// Fix pointer by applying Swift FAST_DATA_MASK (see objc-runtime-new.h for details)
+		index &= is32bit ? ~0x3L : ~0x7L;
+
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			data = new Objc2ClassRW(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readVTable(BinaryReader reader) {
+		try {
+			vtable = new Objc2Implementation(program, state, reader);
+		}
+		catch (IOException ioe) {
+			//Trying to read uninitialized memory
+		}
+	}
+
+	private void readCache(BinaryReader reader) {
+		try {
+			cache = new Objc2Cache(program, state, reader);
+		}
+		catch (IOException ioe) {
+			//Trying to read uninitialized memory
+		}
+	}
+
+	private void readSuperClass(BinaryReader reader) {
+		long index = 0;
+		try {
+			index = ObjcUtils.readNextIndex(reader, is32bit);
+		}
+		catch (IOException ioe) {
+			//Trying to read uninitialized memory
+			return;
+		}
+
+		if (state.classIndexMap.containsKey(index)) {
+			superclass = state.classIndexMap.get(index);
+			return;
+		}
+
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			superclass = new Objc2Class(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	private void readISA(BinaryReader reader) {
+		long index = 0;
+		try {
+			index = ObjcUtils.readNextIndex(reader, is32bit);
+		}
+		catch (IOException ioe) {
+			//Trying to read uninitialized memory
+			return;
+		}
+
+		if (state.classIndexMap.containsKey(index)) {
+			isa = state.classIndexMap.get(index);
+			return;
+		}
+
+		if (index != 0 && reader.isValidIndex(index)) {
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(index);
+			isa = new Objc2Class(program, state, reader);
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType(NAME, 0);
+
+		struct.add(new PointerDataType(struct), pointerSize, "isa", null);
+		struct.add(new PointerDataType(struct), pointerSize, "superclass", null);
+		struct.add(cache.toDataType(), "cache", null);
+		struct.add(vtable.toDataType(), "vtable", null);
+
+		if (data == null) {
+			Objc2ClassRW fakeData = new Objc2ClassRW(program, state);
+			struct.add(new PointerDataType(fakeData.toDataType()), pointerSize, "data", null);
+		}
+		else {
+			struct.add(new PointerDataType(data.toDataType()), pointerSize, "data", null);
+		}
+
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (state.beenApplied.contains(base)) {//handle circular references
+			return;
+		}
+		state.beenApplied.add(base);
+
+		Address address = ObjcUtils.toAddress(program, getIndex());
+		try {
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		try {
+			Namespace classNamespace =
+				ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, Objc2Class.NAME);
+			ObjcUtils.createSymbol(program, classNamespace, data.getName(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		if (isa != null) {
+			isa.applyTo(namespace, monitor);
+		}
+		if (superclass != null) {
+			superclass.applyTo(namespace, monitor);
+		}
+		if (cache != null) {
+			cache.applyTo(namespace, monitor);
+		}
+		if (vtable != null) {
+			vtable.applyTo(namespace, monitor);
+		}
+		if (data != null) {
+			data.applyTo(namespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ClassRW.java
similarity index 54%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ClassRW.java
index 20e09b991b4..8174bfdc718 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ClassRW.java
@@ -13,43 +13,42 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.*;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC2_ClassRW implements StructConverter {
+public class Objc2ClassRW extends ObjcTypeMetadataStructure {
 	public final static String NAME = "class_rw_t";
 
-	private ObjectiveC2_State _state;
-	private long _index;
-
 	private long flags;
 	private long instanceStart;
 	private long instanceSize;
 	private long reserved;
 	private String name;
-	private ObjectiveC2_MethodList baseMethods;
-	private ObjectiveC2_ProtocolList baseProtocols;
-	private ObjectiveC2_InstanceVariableList ivars;
+	private Objc2MethodList baseMethods;
+	private Objc2ProtocolList baseProtocols;
+	private Objc2InstanceVariableList ivars;
 	private long weakIvarLayout;
-	private ObjectiveC2_PropertyList baseProperties;
+	private Objc2PropertyList baseProperties;
 
-	public ObjectiveC2_ClassRW() {
+	public Objc2ClassRW(Program program, ObjcState state) {
+		super(program, state, -1);
 	}
 
-	public ObjectiveC2_ClassRW(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	public Objc2ClassRW(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
 
-		if (state.is32bit) {
+		if (is32bit) {
 			flags = reader.readNextUnsignedInt();
 			instanceStart = reader.readNextUnsignedInt();
 			instanceSize = reader.readNextUnsignedInt();
@@ -66,13 +65,13 @@ public ObjectiveC2_ClassRW(ObjectiveC2_State state, BinaryReader reader) throws
 		readBaseProtocols(reader);
 		readInstanceVariables(reader);
 
-		weakIvarLayout = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
+		weakIvarLayout = ObjcUtils.readNextIndex(reader, is32bit);
 
 		readBaseProperties(reader);
 	}
 
 	public long getIndex() {
-		return _index;
+		return base;
 	}
 
 	public String getName() {
@@ -82,79 +81,83 @@ public String getName() {
 	public long getFlags() {
 		return flags;
 	}
+
 	public long getInstanceStart() {
 		return instanceStart;
 	}
+
 	public long getInstanceSize() {
 		return instanceSize;
 	}
+
 	public long getReserved() {
 		return reserved;
 	}
+
 	public long getWeakIvarLayout() {
 		return weakIvarLayout;
 	}
 
-	public ObjectiveC2_MethodList getBaseMethods() {
+	public Objc2MethodList getBaseMethods() {
 		return baseMethods;
 	}
 
-	public ObjectiveC2_ProtocolList getBaseProtocols() {
+	public Objc2ProtocolList getBaseProtocols() {
 		return baseProtocols;
 	}
 
-	public ObjectiveC2_InstanceVariableList getInstanceVariables() {
+	public Objc2InstanceVariableList getInstanceVariables() {
 		return ivars;
 	}
 
-	public ObjectiveC2_PropertyList getBaseProperties() {
+	public Objc2PropertyList getBaseProperties() {
 		return baseProperties;
 	}
 
 	private void readName(BinaryReader reader) throws IOException {
-		long nameIndex = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long nameIndex = ObjcUtils.readNextIndex(reader, is32bit);
 		if (nameIndex != 0) {
-			name = reader.readAsciiString( nameIndex );
+			name = reader.readAsciiString(nameIndex);
 		}
 	}
 
 	private void readBaseProperties(BinaryReader reader) throws IOException {
-		long propertiesIndex = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long propertiesIndex = ObjcUtils.readNextIndex(reader, is32bit);
 		if (propertiesIndex != 0) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(propertiesIndex);
-			baseProperties = new ObjectiveC2_PropertyList( _state, reader );
+			baseProperties = new Objc2PropertyList(program, state, reader);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readInstanceVariables(BinaryReader reader)
 			throws IOException {
-		long instanceVariablesIndex = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long instanceVariablesIndex = ObjcUtils.readNextIndex(reader, is32bit);
 		if (instanceVariablesIndex != 0) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(instanceVariablesIndex);
-			ivars = new ObjectiveC2_InstanceVariableList( _state, reader );
+			ivars = new Objc2InstanceVariableList(program, state, reader);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readBaseProtocols(BinaryReader reader) throws IOException {
-		long protocolsIndex = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long protocolsIndex = ObjcUtils.readNextIndex(reader, is32bit);
 		if (protocolsIndex != 0) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(protocolsIndex);
-			baseProtocols = new ObjectiveC2_ProtocolList(_state, reader);
+			baseProtocols = new Objc2ProtocolList(program, state, reader);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readBaseMethods(BinaryReader reader) throws IOException {
-		long methodsIndex = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long methodsIndex = ObjcUtils.readNextIndex(reader, is32bit);
 		if (methodsIndex != 0) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(methodsIndex);
-			baseMethods = new ObjectiveC2_MethodList( _state, reader, ObjectiveC_MethodType.INSTANCE );
+			baseMethods = new Objc2MethodList(program, state, reader, ObjcMethodType.INSTANCE);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
@@ -163,7 +166,7 @@ private void readBaseMethods(BinaryReader reader) throws IOException {
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		Structure struct = new StructureDataType(NAME, 0);
 
-		if (_state.is32bit) {
+		if (is32bit) {
 			struct.add(DWORD, "flags", null);
 			struct.add(DWORD, "instanceStart", null);
 			struct.add(DWORD, "instanceSize", null);
@@ -175,51 +178,61 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 			struct.add(QWORD, "instanceSize", null);
 		}
 
-		struct.add(new PointerDataType(ASCII),                                                _state.pointerSize, "name", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),           _state.pointerSize, "baseMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_ProtocolList.toGenericDataType(_state)),   _state.pointerSize, "baseProtocols", null);
-		struct.add(new PointerDataType(ObjectiveC2_InstanceVariableList.toGenericDataType()), _state.pointerSize, "ivars", null);
+		struct.add(new PointerDataType(ASCII), pointerSize, "name", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"baseMethods", null);
+		struct.add(new PointerDataType(Objc2ProtocolList.toGenericDataType(is32bit)), pointerSize,
+			"baseProtocols", null);
+		struct.add(new PointerDataType(Objc2InstanceVariableList.toGenericDataType()), pointerSize,
+			"ivars", null);
 
-		if (_state.is32bit) {
+		if (is32bit) {
 			struct.add(DWORD, "weakIvarLayout", null);
 		}
 		else {
 			struct.add(QWORD, "weakIvarLayout", null);
 		}
 
-		struct.add(new PointerDataType(ObjectiveC2_PropertyList.toGenericDataType()), _state.pointerSize, "baseProperties", null);
+		struct.add(new PointerDataType(Objc2PropertyList.toGenericDataType()), pointerSize,
+			"baseProperties", null);
 
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, getIndex());
 
 		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
 		}
-		catch (Exception e) {}
 
 		try {
-			Namespace namespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_ClassRW.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, namespace, getName(), address);
+			Namespace classNamespace = ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE,
+				Objc2ClassRW.NAME);
+			ObjcUtils.createSymbol(program, classNamespace, getName(), address);
+		}
+		catch (Exception e) {
+			// do nothing
 		}
-		catch (Exception e) {}
 
-		Namespace namespace = ObjectiveC1_Utilities.getClassNamespace(_state.program, null, getName());
+		Namespace classNamespace = ObjcUtils.getClassNamespace(program, null, getName());
 
 		if (baseMethods != null) {
-			baseMethods.applyTo(namespace);
+			baseMethods.applyTo(classNamespace, monitor);
 		}
 		if (baseProtocols != null) {
-			baseProtocols.applyTo(namespace);
+			baseProtocols.applyTo(classNamespace, monitor);
 		}
 		if (ivars != null) {
-			ivars.applyTo(namespace);
+			ivars.applyTo(classNamespace, monitor);
 		}
 		if (baseProperties != null) {
-			baseProperties.applyTo(namespace);
+			baseProperties.applyTo(classNamespace, monitor);
 		}
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Constants.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Constants.java
similarity index 59%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Constants.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Constants.java
index adaff479f73..54031fa48c1 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Constants.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Constants.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -25,37 +25,25 @@
 import ghidra.program.model.listing.Program;
 import ghidra.program.model.mem.MemoryBlock;
 
-public final class ObjectiveC2_Constants {
+public final class Objc2Constants {
 
 	/**
 	 * The name prefix of all Objective-C 2 sections.
 	 */
 	public final static String OBJC2_PREFIX = "__objc_";
 
-	/** Objective-C 2 category list. */
-	public final static String OBJC2_CATEGORY_LIST             = "__objc_catlist";
-	/** Objective-C 2 class list. */
-	public final static String OBJC2_CLASS_LIST                = "__objc_classlist";
-	/** Objective-C 2 class references. */
-	public final static String OBJC2_CLASS_REFS                = "__objc_classrefs";
-	/** Objective-C 2 constants. */
-	public final static String OBJC2_CONST                     = "__objc_const";
-	/**  */
-	public final static String OBJC2_DATA                      = "__objc_data";
-	/**  */
-	public final static String OBJC2_IMAGE_INFO                = "__objc_imageinfo";
-	/**  */
-	public final static String OBJC2_MESSAGE_REFS              = "__objc_msgrefs";
-	/** Objective-C 2 non-lazy class list */
-	public final static String OBJC2_NON_LAZY_CLASS_LIST       = "__objc_nlclslist";
-	/**  */
-	public final static String OBJC2_PROTOCOL_LIST             = "__objc_protolist";
-	/**  */
-	public final static String OBJC2_PROTOCOL_REFS             = "__objc_protorefs";
-	/**  */
-	public final static String OBJC2_SELECTOR_REFS             = "__objc_selrefs";
-	/**  */
-	public final static String OBJC2_SUPER_REFS                = "__objc_superrefs";
+	public final static String OBJC2_CATEGORY_LIST = "__objc_catlist";
+	public final static String OBJC2_CLASS_LIST = "__objc_classlist";
+	public final static String OBJC2_CLASS_REFS = "__objc_classrefs";
+	public final static String OBJC2_CONST = "__objc_const";
+	public final static String OBJC2_DATA = "__objc_data";
+	public final static String OBJC2_IMAGE_INFO = "__objc_imageinfo";
+	public final static String OBJC2_MESSAGE_REFS = "__objc_msgrefs";
+	public final static String OBJC2_NON_LAZY_CLASS_LIST = "__objc_nlclslist";
+	public final static String OBJC2_PROTOCOL_LIST = "__objc_protolist";
+	public final static String OBJC2_PROTOCOL_REFS = "__objc_protorefs";
+	public final static String OBJC2_SELECTOR_REFS = "__objc_selrefs";
+	public final static String OBJC2_SUPER_REFS = "__objc_superrefs";
 
 	/**
 	 * Returns a list containing valid Objective-C 2.0 section names.
@@ -63,20 +51,22 @@ public final class ObjectiveC2_Constants {
 	 */
 	public final static List<String> getObjectiveC2SectionNames() {
 		List<String> sectionNames = new ArrayList<String>();
-		Field [] declaredFields = ObjectiveC2_Constants.class.getDeclaredFields();
+		Field[] declaredFields = Objc2Constants.class.getDeclaredFields();
 		for (Field field : declaredFields) {
 			try {
-				String name = (String)field.get(null);
-				if (!name.equals(OBJC2_PREFIX) && name.startsWith(OBJC2_PREFIX)) {
+				if (field.get(null) instanceof String name && !name.equals(OBJC2_PREFIX) &&
+					name.startsWith(OBJC2_PREFIX)) {
 					sectionNames.add(name);
 				}
 			}
-			catch (Exception e) {
+			catch (IllegalAccessException e) {
+				// do nothing
 			}
 		}
 		sectionNames.add("__data");//not really an Objective-C 2.0 section, but it contains structures used by Objective-C 2.0
 		return sectionNames;
 	}
+
 	/**
 	 * Returns true if this program contains Objective-C 2.
 	 * @param program the program to check
@@ -87,7 +77,7 @@ public final static boolean isObjectiveC2(Program program) {
 		if (MachoLoader.MACH_O_NAME.equals(format) ||
 			DyldCacheLoader.DYLD_CACHE_NAME.equals(format) ||
 			"Extracted DYLD Component".equals(format)) {
-			MemoryBlock [] blocks = program.getMemory().getBlocks();
+			MemoryBlock[] blocks = program.getMemory().getBlocks();
 			for (MemoryBlock memoryBlock : blocks) {
 				if (memoryBlock.getName().startsWith(OBJC2_PREFIX)) {
 					return true;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ImageInfo.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ImageInfo.java
similarity index 61%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ImageInfo.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ImageInfo.java
index 9b34f0d90a5..9f3c75011b2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ImageInfo.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ImageInfo.java
@@ -13,34 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-import java.io.IOException;
-
-public class ObjectiveC2_ImageInfo implements StructConverter {
+public class Objc2ImageInfo extends ObjcTypeMetadataStructure {
 	public final static int OBJC_IMAGE_IS_REPLACEMENT = 1 << 0;
-	public final static int OBJC_IMAGE_SUPPORTS_GC    = 1 << 1;
-	public final static int OBJC_IMAGE_REQUIRES_GC    = 1 << 2;
-
-	private ObjectiveC2_State _state;
-	private long _index;
+	public final static int OBJC_IMAGE_SUPPORTS_GC = 1 << 1;
+	public final static int OBJC_IMAGE_REQUIRES_GC = 1 << 2;
 
 	private int version;
 	private int flags;
 
-	public ObjectiveC2_ImageInfo(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	public Objc2ImageInfo(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
 
-		version   = reader.readNextInt();
-		flags     = reader.readNextInt();
+		version = reader.readNextInt();
+		flags = reader.readNextInt();
 	}
 
 	public int getVersion() {
@@ -63,24 +62,18 @@ public boolean isRequiresGarbageCollection() {
 		return (flags & OBJC_IMAGE_REQUIRES_GC) != 0;
 	}
 
-	public long getIndex() {
-		return _index;
-	}
-
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		Structure struct = new StructureDataType("objc_image_info", 0);
 		struct.add(DWORD, "version", null);
 		struct.add(DWORD, "flags", null);
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
-	public void applyTo() throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {}
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+		ObjcUtils.createData(program, toDataType(), address);
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Implementation.java
similarity index 61%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Implementation.java
index f9965436cf6..95e87d056fe 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Implementation.java
@@ -13,67 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.TypedefDataType;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC2_Implementation implements StructConverter {
-	private boolean _is32bit;
-	private long _index;
+public class Objc2Implementation extends ObjcTypeMetadataStructure {
 	private boolean _isSmall = false;
 
 	private long imp;
 
-	public ObjectiveC2_Implementation(ObjectiveC2_State state, BinaryReader reader, boolean isSmall)
-			throws IOException {
-		this._is32bit = state.is32bit;
-		this._index = reader.getPointerIndex();
+	public Objc2Implementation(Program program, ObjcState state, BinaryReader reader,
+			boolean isSmall) throws IOException {
+		super(program, state, reader.getPointerIndex());
 		this._isSmall = isSmall;
 
-		if (isSmall) {
-			imp = _index + reader.readNextInt();
-		}
-		else {
-			if (state.is32bit) {
-				imp = reader.readNextUnsignedInt();
-			}
-			else {
-				imp = reader.readNextLong();
-			}
-		}
+		imp = isSmall ? base + reader.readNextInt() : ObjcUtils.readNextIndex(reader, is32bit);
 	}
 
-	public ObjectiveC2_Implementation(ObjectiveC2_State state, BinaryReader reader)
+	public Objc2Implementation(Program program, ObjcState state, BinaryReader reader)
 			throws IOException {
-		this(state, reader, false);
+		this(program, state, reader, false);
 	}
 
 	public long getImplementation() {
 		return imp;
 	}
 
-	public long getIndex() {
-		return _index;
-	}
-
 	@Override
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		if (_isSmall) {
 			return new TypedefDataType("ImplementationOffset", DWORD);
 		}
-		else if (_is32bit) {
+		else if (is32bit) {
 			return new TypedefDataType("Implementation", DWORD);
 		}
 		return new TypedefDataType("Implementation", QWORD);
 	}
 
-	public void applyTo() throws Exception {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
 		// do nothing
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariable.java
new file mode 100644
index 00000000000..4e3f73d4a95
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariable.java
@@ -0,0 +1,108 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2InstanceVariable extends ObjcTypeMetadataStructure {
+	private long offset;
+	private String name;
+	private String type;
+	private int alignment;
+	private int size;
+
+	public Objc2InstanceVariable(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		offset = ObjcUtils.readNextIndex(reader, is32bit);
+
+		long nameIndex = ObjcUtils.readNextIndex(reader, is32bit);
+		if (nameIndex > 0 && reader.isValidIndex(nameIndex)) {
+			name = reader.readAsciiString(nameIndex);
+		}
+
+		long typeIndex = ObjcUtils.readNextIndex(reader, is32bit);
+		if (typeIndex > 0 && reader.isValidIndex(typeIndex)) {
+			type = reader.readAsciiString(typeIndex);
+		}
+
+		alignment = reader.readNextInt();
+		size = reader.readNextInt();
+	}
+
+	public long getOffset() {
+		return offset;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getType() {
+		return type;
+	}
+
+	public int getAlignment() {
+		return alignment;
+	}
+
+	public int getSize() {
+		return size;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType("ivar_t", 0);
+		if (is32bit) {
+			struct.add(new PointerDataType(DWORD), pointerSize, "offset", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "name", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "type", null);
+		}
+		else {
+			struct.add(new PointerDataType(QWORD), pointerSize, "offset", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "name", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "type", null);
+		}
+		struct.add(DWORD, "alignment", null);
+		struct.add(DWORD, "size", null);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		if (getOffset() == 0) {
+			return;
+		}
+		if (getName() == null && getName().length() == 0) {
+			return;
+		}
+		Address address =
+			program.getAddressFactory().getDefaultAddressSpace().getAddress(getOffset());
+		ObjcUtils.createSymbol(program, namespace, getName(), address);
+		state.variableMap.put(address, this);
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariableList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariableList.java
new file mode 100644
index 00000000000..854fcb944a4
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2InstanceVariableList.java
@@ -0,0 +1,109 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2InstanceVariableList extends ObjcTypeMetadataStructure {
+	public final static String NAME = "ivar_list_t";
+
+	private int entsize;
+	private int count;
+	private List<Objc2InstanceVariable> ivars = new ArrayList<Objc2InstanceVariable>();
+
+	public Objc2InstanceVariableList(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		entsize = reader.readNextInt();
+		count = reader.readNextInt();
+
+		for (int i = 0; i < count; ++i) {
+			ivars.add(new Objc2InstanceVariable(program, state, reader));
+		}
+	}
+
+	public long getEntsize() {
+		return entsize;
+	}
+
+	public long getCount() {
+		return count;
+	}
+
+	public List<Objc2InstanceVariable> getIvars() {
+		return ivars;
+	}
+
+	public static DataType toGenericDataType() throws DuplicateNameException {
+		Structure struct = new StructureDataType(NAME, 0);
+		struct.add(DWORD, "entsize", null);
+		struct.add(DWORD, "count", null);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType(NAME + '_' + count + '_', 0);
+
+		struct.add(DWORD, "entsize", null);
+		struct.add(DWORD, "count", null);
+
+		for (int i = 0; i < ivars.size(); ++i) {
+			struct.add(ivars.get(i).toDataType(), "var" + i, null);
+		}
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+		try {
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		try {
+			Namespace instanceVariableNamespace = ObjcUtils.createNamespace(program,
+				Objc1Constants.NAMESPACE, Objc2InstanceVariableList.NAME);
+			ObjcUtils.createSymbol(program, instanceVariableNamespace, namespace.getName(),
+				address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		for (Objc2InstanceVariable ivar : getIvars()) {
+			ivar.applyTo(namespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MessageReference.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MessageReference.java
new file mode 100644
index 00000000000..175f6f5090a
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MessageReference.java
@@ -0,0 +1,85 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2MessageReference extends ObjcTypeMetadataStructure {
+	public static final String NAME = "message_ref";
+
+	public static int SIZEOF(int pointerSize) {
+		return 2 * pointerSize;
+	}
+
+	private long implementation;
+	private String selector;
+
+	public Objc2MessageReference(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		if (is32bit) {
+			implementation = reader.readNextUnsignedInt();
+		}
+		else {
+			implementation = reader.readNextLong();
+		}
+
+		long selectorIndex = ObjcUtils.readNextIndex(reader, is32bit);
+		if (selectorIndex != 0) {
+			selector = reader.readAsciiString(selectorIndex);
+		}
+	}
+
+	public long getImplementation() {
+		return implementation;
+	}
+
+	public String getSelector() {
+		return selector;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+		DataType dt = toDataType();
+		Data messageRefData = program.getListing().createData(address, dt);
+		Data selData = messageRefData.getComponent(1);
+		Object selAddress = selData.getValue();
+		Data selStringData = program.getListing().getDataAt((Address) selAddress);
+		Object selString = selStringData.getValue();
+		ObjcUtils.createSymbol(program, null, selString + "_" + Objc2MessageReference.NAME,
+			address);
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType(NAME, 0);
+		struct.add(new PointerDataType(VOID), pointerSize, "imp", null);
+		struct.add(new PointerDataType(ASCII), pointerSize, "sel", null);
+		return struct;
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Method.java
similarity index 68%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Method.java
index 91a6980a36a..f08513f700d 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Method.java
@@ -4,45 +4,46 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.format.macho.dyld.LibObjcOptimization;
-import ghidra.app.util.bin.format.objectiveC.*;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.util.exception.DuplicateNameException;
 
-public class ObjectiveC2_Method extends ObjectiveC_Method {
+public class Objc2Method extends ObjcMethod {
 	private String name;
 	private String types;
-	private ObjectiveC2_Implementation imp;
+	private Objc2Implementation imp;
 
 	private LibObjcOptimization libObjcOptimization;
 	private boolean isSmall;
 
-	public ObjectiveC2_Method(ObjectiveC2_State state, BinaryReader reader,
-			ObjectiveC_MethodType methodType, boolean isSmallList) throws IOException {
-		super(state, reader, methodType);
+	public Objc2Method(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType, boolean isSmallList) throws IOException {
+		super(program, state, reader, methodType);
 
 		libObjcOptimization = state.libObjcOptimization;
 		isSmall = isSmallList;
 
 		if (isSmallList) {
-			int nameOffset = (int) ObjectiveC1_Utilities.readNextIndex(reader, true);
+			int nameOffset = reader.readNextInt();
 			long namePtr;
-			if (state.is32bit) {
-				namePtr = reader.readInt(_index + nameOffset);
+			if (is32bit) {
+				namePtr = reader.readInt(base + nameOffset);
 			}
 			else {
 				if (libObjcOptimization != null) {
@@ -52,28 +53,28 @@ public ObjectiveC2_Method(ObjectiveC2_State state, BinaryReader reader,
 							libObjcOptimization.getRelativeSelectorBaseAddressOffset() + nameOffset;
 					}
 					else {
-						namePtr = _index + nameOffset;
+						namePtr = base + nameOffset;
 					}
 				}
 				else {
-					namePtr = reader.readLong(_index + nameOffset);
+					namePtr = reader.readLong(base + nameOffset);
 				}
 			}
 
 			name = reader.readAsciiString(namePtr);
 
-			int typesOffset = (int) ObjectiveC1_Utilities.readNextIndex(reader, true);
-			types = reader.readAsciiString(_index + 4 + typesOffset);
+			int typesOffset = reader.readNextInt();
+			types = reader.readAsciiString(base + 4 + typesOffset);
 		}
 		else {
-			long nameIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
+			long nameIndex = ObjcUtils.readNextIndex(reader, is32bit);
 			name = reader.readAsciiString(nameIndex);
 
-			long typesIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
+			long typesIndex = ObjcUtils.readNextIndex(reader, is32bit);
 			types = reader.readAsciiString(typesIndex);
 		}
 
-		imp = new ObjectiveC2_Implementation(state, reader, isSmallList);
+		imp = new Objc2Implementation(program, state, reader, isSmallList);
 	}
 
 	@Override
@@ -116,11 +117,11 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 			struct.add(new PointerTypedef(null, VOID, 4, null, REL), "imp", comment);
 		}
 		else {
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "name", null);
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "types", null);
-			struct.add(new PointerDataType(VOID), _state.pointerSize, "imp", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "name", null);
+			struct.add(new PointerDataType(STRING), pointerSize, "types", null);
+			struct.add(new PointerDataType(VOID), pointerSize, "imp", null);
 		}
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MethodList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MethodList.java
similarity index 74%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MethodList.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MethodList.java
index 71bac5371a0..e9b5c080ea6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MethodList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2MethodList.java
@@ -4,36 +4,36 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC_MethodList;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC_MethodType;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.util.exception.DuplicateNameException;
 
-public class ObjectiveC2_MethodList extends ObjectiveC_MethodList {
+public class Objc2MethodList extends ObjcMethodList {
 	public final static String NAME = "method_list_t";
 
 	private int entsizeAndFlags;
 	private int count;
 
-	public ObjectiveC2_MethodList(ObjectiveC2_State state, BinaryReader reader,
-			ObjectiveC_MethodType methodType) throws IOException {
-		super(state, reader, NAME);
+	public Objc2MethodList(Program program, ObjcState state, BinaryReader reader,
+			ObjcMethodType methodType) throws IOException {
+		super(program, state, reader, NAME);
 
-		if (_index == 0) {
+		if (base == 0) {
 			return;
 		}
 
@@ -43,7 +43,7 @@ public ObjectiveC2_MethodList(ObjectiveC2_State state, BinaryReader reader,
 		boolean isSmallList = isSmallMethods();
 
 		for (int i = 0; i < count; ++i) {
-			methods.add(new ObjectiveC2_Method(state, reader, methodType, isSmallList));
+			methods.add(new Objc2Method(program, state, reader, methodType, isSmallList));
 		}
 	}
 
@@ -63,7 +63,7 @@ public static DataType toGenericDataType() throws DuplicateNameException {
 		Structure struct = new StructureDataType(NAME, 0);
 		struct.add(DWORD, "entsizeAndFlags", null);
 		struct.add(DWORD, "count", null);
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
@@ -79,8 +79,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 			struct.add(methods.get(i).toDataType(), "method" + i, null);
 		}
 
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
-
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Property.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Property.java
similarity index 55%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Property.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Property.java
index 48c7475a747..eebaa2bb3a2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Property.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Property.java
@@ -13,31 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
+import ghidra.app.util.bin.format.objc.*;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-import java.io.IOException;
-
-public class ObjectiveC2_Property implements StructConverter {
-	private ObjectiveC2_State _state;
-
+public class Objc2Property extends ObjcTypeMetadataStructure {
 	private String name;
 	private String attributes;
 
-	public ObjectiveC2_Property(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
+	public Objc2Property(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
 
-		long nameIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-		name  = reader.readAsciiString(nameIndex);
+		long nameIndex = ObjcUtils.readNextIndex(reader, is32bit);
+		name = reader.readAsciiString(nameIndex);
 
-		long attributesIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-		attributes  = reader.readAsciiString(attributesIndex);
+		long attributesIndex = ObjcUtils.readNextIndex(reader, is32bit);
+		attributes = reader.readAsciiString(attributesIndex);
 	}
 
 	public String getName() {
@@ -52,13 +51,15 @@ public String getAttributes() {
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		Structure struct = new StructureDataType("objc_property", 0);
 
-		struct.add(new PointerDataType(ASCII), _state.pointerSize, "name", null);
-		struct.add(new PointerDataType(ASCII), _state.pointerSize, "name", null);
+		struct.add(new PointerDataType(ASCII), pointerSize, "name", null);
+		struct.add(new PointerDataType(ASCII), pointerSize, "name", null);
 
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
-	public void applyTo(Namespace namespace) {
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		// do nothing
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2PropertyList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2PropertyList.java
new file mode 100644
index 00000000000..b7c02299106
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2PropertyList.java
@@ -0,0 +1,110 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2PropertyList extends ObjcTypeMetadataStructure {
+	public final static String NAME = "objc_property_list";
+
+	private int entsize;
+	private int count;
+
+	private List<Objc2Property> properties = new ArrayList<Objc2Property>();
+
+	public Objc2PropertyList(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		entsize = reader.readNextInt();
+		count = reader.readNextInt();
+
+		for (int i = 0; i < count; ++i) {
+			properties.add(new Objc2Property(program, state, reader));
+		}
+	}
+
+	public int getEntrySize() {
+		return entsize;
+	}
+
+	public int getCount() {
+		return count;
+	}
+
+	public List<Objc2Property> getProperties() {
+		return properties;
+	}
+
+	public static DataType toGenericDataType() throws DuplicateNameException {
+		Structure struct = new StructureDataType(NAME, 0);
+		struct.add(DWORD, "entsize", null);
+		struct.add(DWORD, "count", null);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType(NAME + '_' + count + '_', 0);
+
+		struct.add(DWORD, "entsize", null);
+		struct.add(DWORD, "count", null);
+
+		for (int i = 0; i < properties.size(); ++i) {
+			struct.add(properties.get(i).toDataType(), "property" + i, null);
+		}
+
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+		try {
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		try {
+			Namespace propertyListNamespace = ObjcUtils.createNamespace(program,
+				Objc1Constants.NAMESPACE, Objc2PropertyList.NAME);
+			ObjcUtils.createSymbol(program, propertyListNamespace, namespace.getName(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		for (Objc2Property property : getProperties()) {
+			property.applyTo(namespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Protocol.java
similarity index 53%
rename from Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java
rename to Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Protocol.java
index f1ffeb0042e..646a0759638 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2Protocol.java
@@ -13,41 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package ghidra.app.util.bin.format.objc2;
+package ghidra.app.util.bin.format.objc.objc2;
 
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.*;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
 import ghidra.program.model.symbol.Namespace;
 import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
 
-public class ObjectiveC2_Protocol implements StructConverter {
+public class Objc2Protocol extends ObjcTypeMetadataStructure {
 	public final static String NAME = "protocol_t";
 
-	private ObjectiveC2_State _state;
-	private long _index;
-
 	private long isa;
 	private String name;
-	private ObjectiveC2_ProtocolList protocols;
-	private ObjectiveC2_MethodList instanceMethods;
-	private ObjectiveC2_MethodList classMethods;
+	private Objc2ProtocolList protocols;
+	private Objc2MethodList instanceMethods;
+	private Objc2MethodList classMethods;
 
-	private ObjectiveC2_MethodList optionalInstanceMethods;
-	private ObjectiveC2_MethodList optionalClassMethods;
-	private ObjectiveC2_PropertyList instanceProperties;
+	private Objc2MethodList optionalInstanceMethods;
+	private Objc2MethodList optionalClassMethods;
+	private Objc2PropertyList instanceProperties;
 	private long unknown0;
 	private long unknown1;
 
-	public ObjectiveC2_Protocol(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
+	public Objc2Protocol(Program program, ObjcState state, BinaryReader reader) throws IOException {
+		super(program, state, reader.getPointerIndex());
 
-		isa = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);//TODO
+		isa = ObjcUtils.readNextIndex(reader, is32bit);//TODO
 		readName(reader);
 		readProtocols(reader);
 		readInstanceMethods(reader);
@@ -56,7 +54,7 @@ public ObjectiveC2_Protocol(ObjectiveC2_State state, BinaryReader reader) throws
 		readOptionalClassMethods(reader);
 		readInstanceProperties(reader);
 
-		if (state.is32bit) {
+		if (is32bit) {
 			unknown0 = reader.readNextUnsignedInt();
 			unknown1 = reader.readNextUnsignedInt();
 		}
@@ -74,27 +72,27 @@ public String getName() {
 		return name;
 	}
 
-	public ObjectiveC2_ProtocolList getProtocols() {
+	public Objc2ProtocolList getProtocols() {
 		return protocols;
 	}
 
-	public ObjectiveC2_MethodList getInstanceMethods() {
+	public Objc2MethodList getInstanceMethods() {
 		return instanceMethods;
 	}
 
-	public ObjectiveC2_MethodList getClassMethods() {
+	public Objc2MethodList getClassMethods() {
 		return classMethods;
 	}
 
-	public ObjectiveC2_MethodList getOptionalInstanceMethods() {
+	public Objc2MethodList getOptionalInstanceMethods() {
 		return optionalInstanceMethods;
 	}
 
-	public ObjectiveC2_MethodList getOptionalClassMethods() {
+	public Objc2MethodList getOptionalClassMethods() {
 		return optionalClassMethods;
 	}
 
-	public ObjectiveC2_PropertyList getInstanceProperties() {
+	public Objc2PropertyList getInstanceProperties() {
 		return instanceProperties;
 	}
 
@@ -107,75 +105,74 @@ public long getUnknown1() {
 	}
 
 	public long getIndex() {
-		return _index;
+		return base;
 	}
 
 	private void readProtocols(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
-			protocols = new ObjectiveC2_ProtocolList(_state, reader);
+			protocols = new Objc2ProtocolList(program, state, reader);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readName(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			name = reader.readAsciiString(index);
 		}
 	}
 
 	private void readInstanceMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
-			instanceMethods =
-				new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.INSTANCE);
+			instanceMethods = new Objc2MethodList(program, state, reader, ObjcMethodType.INSTANCE);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readClassMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
-			classMethods = new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.CLASS);
+			classMethods = new Objc2MethodList(program, state, reader, ObjcMethodType.CLASS);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readOptionalInstanceMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
 			optionalInstanceMethods =
-				new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.INSTANCE);
+				new Objc2MethodList(program, state, reader, ObjcMethodType.INSTANCE);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readOptionalClassMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
 			optionalClassMethods =
-				new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.CLASS);
+				new Objc2MethodList(program, state, reader, ObjcMethodType.CLASS);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
 
 	private void readInstanceProperties(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
+		long index = ObjcUtils.readNextIndex(reader, is32bit);
 		if (index != 0 && reader.isValidIndex(index)) {
 			long originalIndex = reader.getPointerIndex();
 			reader.setPointerIndex(index);
-			instanceProperties = new ObjectiveC2_PropertyList(_state, reader);
+			instanceProperties = new Objc2PropertyList(program, state, reader);
 			reader.setPointerIndex(originalIndex);
 		}
 	}
@@ -184,28 +181,28 @@ private void readInstanceProperties(BinaryReader reader) throws IOException {
 	public DataType toDataType() throws DuplicateNameException, IOException {
 		Structure struct = new StructureDataType(NAME, 0);
 
-		if (_state.is32bit) {
+		if (is32bit) {
 			struct.add(DWORD, "isa", null);
 		}
 		else {
 			struct.add(QWORD, "isa", null);
 		}
 
-		struct.add(new PointerDataType(STRING), _state.pointerSize, "name", null);
-		struct.add(new PointerDataType(ObjectiveC2_ProtocolList.toGenericDataType(_state)),
-			_state.pointerSize, "protocols", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),
-			_state.pointerSize, "instanceMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),
-			_state.pointerSize, "classMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),
-			_state.pointerSize, "optionalInstanceMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),
-			_state.pointerSize, "optionalClassMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_PropertyList.toGenericDataType()),
-			_state.pointerSize, "instanceProperties", null);
-
-		if (_state.is32bit) {
+		struct.add(new PointerDataType(STRING), pointerSize, "name", null);
+		struct.add(new PointerDataType(Objc2ProtocolList.toGenericDataType(is32bit)),
+			pointerSize, "protocols", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"instanceMethods", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"classMethods", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"optionalInstanceMethods", null);
+		struct.add(new PointerDataType(Objc2MethodList.toGenericDataType()), pointerSize,
+			"optionalClassMethods", null);
+		struct.add(new PointerDataType(Objc2PropertyList.toGenericDataType()), pointerSize,
+			"instanceProperties", null);
+
+		if (is32bit) {
 			struct.add(DWORD, "unknown0", null);
 			struct.add(DWORD, "unknown1", null);
 		}
@@ -214,45 +211,46 @@ public DataType toDataType() throws DuplicateNameException, IOException {
 			struct.add(QWORD, "unknown1", null);
 		}
 
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
 		return struct;
 	}
 
-	public void applyTo(Namespace namespace) throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, getIndex());
 		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
+			ObjcUtils.createData(program, toDataType(), address);
 		}
 		catch (Exception e) {
+			// do nothing
 		}
 
 		try {
 			Namespace protocolNamespace =
-				ObjectiveC1_Utilities.createNamespace(_state.program,
-					ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_Protocol.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, protocolNamespace, getName(),
-				address);
+				ObjcUtils.createNamespace(program, Objc1Constants.NAMESPACE, Objc2Protocol.NAME);
+			ObjcUtils.createSymbol(program, protocolNamespace, getName(), address);
 		}
 		catch (Exception e) {
+			// do nothing
 		}
 
 		if (protocols != null) {
-			protocols.applyTo(namespace);
+			protocols.applyTo(namespace, monitor);
 		}
 		if (instanceMethods != null) {
-			instanceMethods.applyTo(namespace);
+			instanceMethods.applyTo(namespace, monitor);
 		}
 		if (classMethods != null) {
-			classMethods.applyTo(namespace);
+			classMethods.applyTo(namespace, monitor);
 		}
 		if (optionalInstanceMethods != null) {
-			optionalInstanceMethods.applyTo(namespace);
+			optionalInstanceMethods.applyTo(namespace, monitor);
 		}
 		if (optionalClassMethods != null) {
-			optionalClassMethods.applyTo(namespace);
+			optionalClassMethods.applyTo(namespace, monitor);
 		}
 		if (instanceProperties != null) {
-			instanceProperties.applyTo(namespace);
+			instanceProperties.applyTo(namespace, monitor);
 		}
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ProtocolList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ProtocolList.java
new file mode 100644
index 00000000000..2bb3e2d393f
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2ProtocolList.java
@@ -0,0 +1,116 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2ProtocolList extends ObjcTypeMetadataStructure {
+	public final static String NAME = "protocol_list_t";
+
+	private List<Objc2Protocol> protocols = new ArrayList<Objc2Protocol>();
+
+	public Objc2ProtocolList(Program program, ObjcState state, BinaryReader reader)
+			throws IOException {
+		super(program, state, reader.getPointerIndex());
+
+		long count = is32bit ? reader.readNextUnsignedInt() : reader.readNextLong();
+
+		for (long i = 0; i < count; ++i) {
+			long protocolIndex = ObjcUtils.readNextIndex(reader, is32bit);
+			long originalIndex = reader.getPointerIndex();
+			reader.setPointerIndex(protocolIndex);
+			protocols.add(new Objc2Protocol(program, state, reader));
+			reader.setPointerIndex(originalIndex);
+		}
+	}
+
+	public long getCount() {
+		return protocols.size();
+	}
+
+	public List<Objc2Protocol> getProtocols() {
+		return protocols;
+	}
+
+	public static DataType toGenericDataType(boolean is32bit)
+			throws DuplicateNameException {
+		Structure struct = new StructureDataType(NAME, 0);
+		if (is32bit) {
+			struct.add(DWORD, "count", null);
+		}
+		else {
+			struct.add(QWORD, "count", null);
+		}
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		Structure struct = new StructureDataType(NAME + '_' + protocols.size() + '_', 0);
+
+		if (is32bit) {
+			struct.add(DWORD, "count", null);
+		}
+		else {
+			struct.add(QWORD, "count", null);
+		}
+
+		for (int i = 0; i < protocols.size(); ++i) {
+			DataType dataType = protocols.get(i).toDataType();
+			struct.add(new PointerDataType(dataType), pointerSize, "protocol" + i, null);
+		}
+
+		struct.setCategoryPath(Objc2Constants.CATEGORY_PATH);
+		return struct;
+	}
+
+	@Override
+	public void applyTo(Namespace namespace, TaskMonitor monitor) throws Exception {
+		Address address = ObjcUtils.toAddress(program, base);
+		try {
+			ObjcUtils.createData(program, toDataType(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		try {
+			Namespace protocolListNamespace = ObjcUtils.createNamespace(program,
+				Objc1Constants.NAMESPACE, Objc2ProtocolList.NAME);
+			ObjcUtils.createSymbol(program, protocolListNamespace, namespace.getName(), address);
+		}
+		catch (Exception e) {
+			// do nothing
+		}
+
+		for (Objc2Protocol protocol : getProtocols()) {
+			protocol.applyTo(namespace, monitor);
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2TypeMetadata.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2TypeMetadata.java
new file mode 100644
index 00000000000..c6371d733da
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc/objc2/Objc2TypeMetadata.java
@@ -0,0 +1,322 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.objc.objc2;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.MemoryByteProvider;
+import ghidra.app.util.bin.format.macho.dyld.LibObjcOptimization;
+import ghidra.app.util.bin.format.objc.*;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.app.util.bin.format.objc.objc1.Objc1TypeMetadata;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.DataUtilities;
+import ghidra.program.model.data.PointerDataType;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class Objc2TypeMetadata extends AbstractObjcTypeMetadata {
+
+	/**
+	 * Creates a new {@link Objc2TypeMetadata}
+	 * 
+	 * @param program The {@link Program}
+	 * @param monitor A cancellable task monitor
+	 * @param log The log
+	 * @throws IOException if there was an IO-related error
+	 * @throws CancelledException if the user cancelled the operation
+	 */
+	public Objc2TypeMetadata(Program program, TaskMonitor monitor, MessageLog log)
+			throws IOException, CancelledException {
+		super(new ObjcState(program, Objc2Constants.CATEGORY_PATH), program, monitor, log);
+		parse();
+	}
+
+	/**
+	 * Parses the {@link Objc1TypeMetadata}
+	 * 
+	 * @throws IOException if there was an IO-related error
+	 * @throws CancelledException if the user cancelled the operation
+	 */
+	private void parse() throws IOException, CancelledException {
+		try (MemoryByteProvider provider =
+			MemoryByteProvider.createDefaultAddressSpaceByteProvider(program, false)) {
+			BinaryReader reader = new BinaryReader(provider, !program.getLanguage().isBigEndian());
+
+			// Create a map of Objective-C specific memory blocks.  If this is a dyld_shared_cache
+			// file, there will be many of each type.
+			Map<String, List<MemoryBlock>> objcBlockMap =
+				Arrays.stream(program.getMemory().getBlocks())
+						.filter(b -> b.getName().startsWith(Objc2Constants.OBJC2_PREFIX))
+						.collect(Collectors.groupingBy(MemoryBlock::getName));
+
+			parseLibObjcOptimization(LibObjcOptimization.SECTION_NAME, objcBlockMap);
+			parseRefs(Objc2Constants.OBJC2_CLASS_REFS, refs, objcBlockMap);
+			parseRefs(Objc2Constants.OBJC2_SUPER_REFS, refs, objcBlockMap);
+			parseRefs(Objc2Constants.OBJC2_PROTOCOL_REFS, refs, objcBlockMap);
+			parseRefs(Objc2Constants.OBJC2_SELECTOR_REFS, refs, objcBlockMap);
+			parseRefs(Objc2Constants.OBJC2_NON_LAZY_CLASS_LIST, refs, objcBlockMap);
+			parseImageInfo(Objc2Constants.OBJC2_IMAGE_INFO, reader, objcBlockMap);
+			parseCategoryList(Objc2Constants.OBJC2_CATEGORY_LIST, reader, objcBlockMap);
+			parseClassList(Objc2Constants.OBJC2_CLASS_LIST, reader, objcBlockMap);
+			parseProtocolList(Objc2Constants.OBJC2_PROTOCOL_LIST, reader, objcBlockMap);
+			parseMessageReferences(Objc2Constants.OBJC2_MESSAGE_REFS, reader, objcBlockMap);
+		}
+	}
+
+	private Set<Address> refs = new HashSet<>();
+	private List<Objc2ImageInfo> imageInfos = new ArrayList<>();
+	private List<Objc2Category> categories = new ArrayList<>();
+	private List<Objc2Class> classes = new ArrayList<>();
+	private List<Objc2Protocol> protocols = new ArrayList<>();
+	private List<Objc2MessageReference> messageRefs = new ArrayList<>();
+
+	private void parseRefs(String section, Set<Address> set,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Parsing Objective-C %s references...".formatted(section));
+		for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+			long count = block.getSize() / program.getDefaultPointerSize();
+			monitor.initialize((int) count);
+			Address address = block.getStart();
+			for (int i = 0; i < count; ++i) {
+				monitor.increment();
+				set.add(address);
+				address = address.add(program.getDefaultPointerSize());
+			}
+		}
+	}
+
+	private void parseImageInfo(String section, BinaryReader reader,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws IOException {
+		monitor.setMessage("Parsing Objective-C image infos...");
+		for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+			Address address = block.getStart();
+			reader.setPointerIndex(address.getOffset());
+			imageInfos.add(new Objc2ImageInfo(program, state, reader));
+		}
+	}
+
+	private void parseCategoryList(String section, BinaryReader reader,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Objective-C categories...");
+		try {
+			for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+				long count = block.getSize() / program.getDefaultPointerSize();
+				monitor.initialize((int) count);
+				Address address = block.getStart();
+				for (int i = 0; i < count; ++i) {
+					monitor.increment();
+					long categoryAddress =
+						program.getDefaultPointerSize() == 4
+								? reader.readUnsignedInt(address.getOffset())
+								: reader.readLong(address.getOffset());
+					reader.setPointerIndex(categoryAddress);
+					categories.add(new Objc2Category(program, state, reader));
+					refs.add(address);
+					address = address.add(program.getDefaultPointerSize());
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse Objective-C categeory from section '" + section + "'");
+		}
+	}
+
+	private void parseClassList(String section, BinaryReader reader,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Objective-C classes...");
+		try {
+			for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+				long count = block.getSize() / program.getDefaultPointerSize();
+				monitor.initialize((int) count);
+				Address address = block.getStart();
+				for (int i = 0; i < count; ++i) {
+					monitor.increment();
+					long classAddress =
+						program.getDefaultPointerSize() == 4
+								? reader.readUnsignedInt(address.getOffset())
+								: reader.readLong(address.getOffset());
+					reader.setPointerIndex(classAddress);
+					classes.add(new Objc2Class(program, state, reader));
+					refs.add(address);
+					address = address.add(program.getDefaultPointerSize());
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse Objective-C class from section '" + section + "'");
+		}
+	}
+
+	private void parseProtocolList(String section, BinaryReader reader,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Objective-C protocols...");
+		try {
+			for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+				long count = block.getSize() / program.getDefaultPointerSize();
+				monitor.initialize((int) count);
+				Address address = block.getStart();
+				for (int i = 0; i < count; ++i) {
+					monitor.increment();
+					long protocolAddress =
+						program.getDefaultPointerSize() == 4
+								? reader.readUnsignedInt(address.getOffset())
+								: reader.readLong(address.getOffset());
+					reader.setPointerIndex(protocolAddress);
+					Objc2Protocol protocol = new Objc2Protocol(program, state, reader);
+					protocols.add(protocol);
+					refs.add(address);
+					address = address.add(program.getDefaultPointerSize());
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse Objective-C protocol from section '" + section + "'");
+		}
+	}
+
+	private void parseMessageReferences(String section, BinaryReader reader,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Objective-C message references...");
+		try {
+			for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+				long count =
+					block.getSize() / Objc2MessageReference.SIZEOF(program.getDefaultPointerSize());
+				monitor.initialize((int) count);
+				Address address = block.getStart();
+				for (int i = 0; i < count; ++i) {
+					monitor.increment();
+					reader.setPointerIndex(address.getOffset());
+					messageRefs.add(new Objc2MessageReference(program, state, reader));
+					address =
+						address.add(Objc2MessageReference.SIZEOF(program.getDefaultPointerSize()));
+				}
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse Objective-C message reference from section '" + section + "'");
+		}
+	}
+
+	private void parseLibObjcOptimization(String section,
+			Map<String, List<MemoryBlock>> objcBlockMap) throws CancelledException {
+		monitor.setMessage("Parsing Objective-C libObjc optimizations...");
+		try {
+			for (MemoryBlock block : objcBlockMap.getOrDefault(section, List.of())) {
+				monitor.checkCancelled();
+				state.libObjcOptimization = new LibObjcOptimization(program, block.getStart());
+			}
+		}
+		catch (IOException e) {
+			log("Failed to parse Objective-C libObjc optimizations from section '" + section + "'");
+		}
+	}
+
+	@Override
+	public void applyTo() {
+		for (Address addr : refs) {
+			try {
+				DataUtilities.createData(program, addr, new PointerDataType(), -1,
+					DataUtilities.ClearDataMode.CLEAR_SINGLE_DATA);
+			}
+			catch (Exception e) {
+				log("Failed to create pointer at " + addr);
+			}
+		}
+		for (Objc2ImageInfo imageInfo : imageInfos) {
+			try {
+				imageInfo.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup image info: " + imageInfo);
+			}
+		}
+		for (Objc2Category category : categories) {
+			try {
+				category.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup category: " + category);
+			}
+		}
+		for (Objc2Class cls : classes) {
+			try {
+				cls.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup class: " + cls);
+			}
+		}
+		for (Objc2Protocol protocol : protocols) {
+			try {
+				Namespace namespace = ObjcUtils.createNamespace(program,
+					Objc1Constants.NAMESPACE, "Protocols", protocol.getName());
+				protocol.applyTo(namespace, monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup protocol: " + protocol);
+			}
+		}
+		for (Objc2MessageReference messageRef : messageRefs) {
+			try {
+				messageRef.applyTo(program.getGlobalNamespace(), monitor);
+			}
+			catch (Exception e) {
+				log("Failed to markup message reference: " + messageRef);
+			}
+		}
+
+		ObjcUtils.createMethods(program, state, log, monitor);
+		ObjcUtils.fixupReferences(Objc2Constants.getObjectiveC2SectionNames(), program, monitor);
+		createInstanceVariables();
+
+		ObjcUtils.setBlocksReadOnly(program.getMemory(), List.of(
+			Objc2Constants.OBJC2_DATA,
+			Objc2Constants.OBJC2_CLASS_REFS,
+			Objc2Constants.OBJC2_MESSAGE_REFS,
+			Objc2Constants.OBJC2_SELECTOR_REFS,
+			Objc2Constants.OBJC2_SUPER_REFS,
+			Objc2Constants.OBJC2_PROTOCOL_REFS));
+	}
+
+	/**
+	 * Creates instance variables
+	 */
+	private void createInstanceVariables() {
+		monitor.initialize(state.variableMap.size(), "Creating Objective-C Instance Variables...");
+		for (Address address : state.variableMap.keySet()) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress();
+			Objc2InstanceVariable variable = state.variableMap.get(address);
+			try {
+				state.encodings.processInstanceVariableSignature(program, address,
+					variable.getType(), variable.getSize());
+			}
+			catch (Exception e) {
+				log("Unhandled instance variable signature: " + e.getMessage());
+			}
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java
deleted file mode 100644
index bc90883ffdf..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java
+++ /dev/null
@@ -1,214 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.*;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_Category implements StructConverter {
-	public final static String NAME = "category_t";
-
-	private ObjectiveC2_State _state;
-	private long _index;
-
-	private String name;
-	private ObjectiveC2_Class cls;
-	private ObjectiveC2_MethodList instanceMethods;
-	private ObjectiveC2_MethodList classMethods;
-	private ObjectiveC2_ProtocolList protocols;
-	private ObjectiveC2_PropertyList instanceProperties;
-
-	public ObjectiveC2_Category(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		readName(reader);
-		readClass(reader);
-		if (cls != null && cls.getISA() != null) {
-			readInstanceMethods(reader);
-			readClassMethods(reader);
-			readProtocols(reader);
-			readInstanceProperties(reader);
-		}
-	}
-
-	public long getIndex() {
-		return _index;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public ObjectiveC2_Class getCls() {
-		return cls;
-	}
-
-	public ObjectiveC2_MethodList getInstanceMethods() {
-		return instanceMethods;
-	}
-
-	public ObjectiveC2_MethodList getClassMethods() {
-		return classMethods;
-	}
-
-	public ObjectiveC2_ProtocolList getProtocols() {
-		return protocols;
-	}
-
-	public ObjectiveC2_PropertyList getInstanceProperties() {
-		return instanceProperties;
-	}
-
-	private void readName(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		if (index != 0 && reader.isValidIndex(index)) {
-			name = reader.readAsciiString(index);
-		}
-	}
-
-	private void readClass(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-
-		if (_state.classIndexMap.containsKey(index)) {
-			cls = _state.classIndexMap.get(index);
-			return;
-		}
-
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			cls = new ObjectiveC2_Class(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readInstanceMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			instanceMethods = new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.INSTANCE);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readClassMethods(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			classMethods = new ObjectiveC2_MethodList(_state, reader, ObjectiveC_MethodType.CLASS);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readProtocols(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			protocols = new ObjectiveC2_ProtocolList(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readInstanceProperties(BinaryReader reader) throws IOException {
-		long index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			instanceProperties = new ObjectiveC2_PropertyList(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		StringBuffer buffer = new StringBuffer();
-		buffer.append(NAME);
-
-		if (cls == null) {
-			buffer.append("<no_class>");
-		}
-
-		Structure struct = new StructureDataType(buffer.toString(), 0);
-
-		struct.add(new PointerDataType(STRING), _state.pointerSize, "name", null);
-
-		if (cls == null) {
-			struct.add(new PointerDataType(VOID), _state.pointerSize, "cls", null);
-		}
-		else {
-			struct.add(new PointerDataType(cls.toDataType()), _state.pointerSize, "cls", null);
-		}
-
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),         _state.pointerSize, "instanceMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_MethodList.toGenericDataType()),         _state.pointerSize, "classMethods", null);
-		struct.add(new PointerDataType(ObjectiveC2_ProtocolList.toGenericDataType(_state)), _state.pointerSize, "protocols", null);
-		struct.add(new PointerDataType(ObjectiveC2_PropertyList.toGenericDataType()),       _state.pointerSize, "instanceProperties", null);
-
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {}
-
-		try {
-			Namespace categoryNamespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_Category.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, categoryNamespace, getName(), address);
-		}
-		catch (Exception e) {}
-
-		String string = null;
-		try {
-			string = cls.getData().getName()+'_'+name+'_';
-		}
-		catch (Exception e) {
-			string = name;
-		}
-		Namespace namespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, "Categories", string);
-
-		if (cls != null) {
-			cls.applyTo();
-		}
-		if (instanceMethods != null) {
-			instanceMethods.applyTo(namespace);
-		}
-		if (classMethods != null) {
-			classMethods.applyTo(namespace);
-		}
-		if (protocols != null) {
-			protocols.applyTo(namespace);
-		}
-		if (instanceProperties != null) {
-			instanceProperties.applyTo(namespace);
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Class.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Class.java
deleted file mode 100644
index f4a85054166..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Class.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.macho.SectionNames;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.address.AddressSpace;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.program.model.symbol.Symbol;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_Class implements StructConverter {
-	public final static String NAME = "class_t";
-
-	private ObjectiveC2_State _state;
-	private long _index;
-
-	private ObjectiveC2_Class isa;
-	private ObjectiveC2_Class superclass;
-	private ObjectiveC2_Cache cache;
-	private ObjectiveC2_Implementation vtable;
-	private ObjectiveC2_ClassRW data; // class_rw_t * plus custom rr/alloc flags
-
-	public ObjectiveC2_Class(ObjectiveC2_State state, BinaryReader reader) {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		state.classIndexMap.put(_index, this);
-		
-		// Some class references point to a GOT entry. These aren't real class structures, so don't 
-		// parse them.
-		AddressSpace space = _state.program.getAddressFactory().getDefaultAddressSpace();
-		Address addr = space.getAddress(_index);
-		Symbol symbol = _state.program.getSymbolTable().getPrimarySymbol(addr);
-		if (symbol != null && symbol.getParentNamespace().getName().equals(SectionNames.SECT_GOT)) {
-			return;
-		}
-
-		try {
-			readISA(reader);
-			readSuperClass(reader);
-			readCache(reader);
-			readVTable(reader);
-			readData(reader);
-		}
-		catch (IOException ioe) {
-			// Couldn't read something, usually a metaclass pointing to an uninitialized section since
-			// runtime 2.0 got rid of the metaclass type.
-		}
-	}
-
-	@Override
-	public boolean equals(Object that) {
-		if (that instanceof ObjectiveC2_Class) {
-			return this._index == ((ObjectiveC2_Class) that)._index;
-		}
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return (int) _index;
-	}
-
-	public ObjectiveC2_Class getISA() {
-		return isa;
-	}
-
-	public ObjectiveC2_Class getSuperClass() {
-		return superclass;
-	}
-
-	public ObjectiveC2_Cache getCache() {
-		return cache;
-	}
-
-	public ObjectiveC2_Implementation getVTable() {
-		return vtable;
-	}
-
-	public ObjectiveC2_ClassRW getData() {
-		return data;
-	}
-
-	public long getIndex() {
-		return _index;
-	}
-
-	private void readData(BinaryReader reader) throws IOException {
-		long index = 0;
-		try {
-			index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		}
-		catch (IOException ioe) {
-			//Trying to read uninitialized memory
-			return;
-		}
-
-		// Fix pointer by applying Swift FAST_DATA_MASK (see objc-runtime-new.h for details)
-		index &= _state.is64bit ? ~0x7L : ~0x3L;
-
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			data = new ObjectiveC2_ClassRW(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readVTable(BinaryReader reader) {
-		try {
-			vtable = new ObjectiveC2_Implementation(_state, reader);
-		}
-		catch (IOException ioe) {
-			//Trying to read uninitialized memory
-		}
-	}
-
-	private void readCache(BinaryReader reader) {
-		try {
-			cache = new ObjectiveC2_Cache(_state, reader);
-		}
-		catch (IOException ioe) {
-			//Trying to read uninitialized memory
-		}
-	}
-
-	private void readSuperClass(BinaryReader reader) throws IOException {
-		long index = 0;
-		try {
-			index = ObjectiveC1_Utilities.readNextIndex(reader, _state.is32bit);
-		}
-		catch (IOException ioe) {
-			//Trying to read uninitialized memory
-			return;
-		}
-
-		if (_state.classIndexMap.containsKey(index)) {
-			superclass = _state.classIndexMap.get(index);
-			return;
-		}
-
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			superclass = new ObjectiveC2_Class(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	private void readISA(BinaryReader reader) throws IOException {
-		long index = 0;
-		try {
-			index = ObjectiveC2_Utilities.readNextIndex(reader, _state.is32bit);
-		}
-		catch (IOException ioe) {
-			//Trying to read uninitialized memory
-			return;
-		}
-
-		if (_state.classIndexMap.containsKey(index)) {
-			isa = _state.classIndexMap.get(index);
-			return;
-		}
-
-		if (index != 0 && reader.isValidIndex(index)) {
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(index);
-			isa = new ObjectiveC2_Class(_state, reader);
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType(NAME, 0);
-
-		struct.add(new PointerDataType(struct), _state.pointerSize, "isa", null);
-		struct.add(new PointerDataType(struct), _state.pointerSize, "superclass", null);
-		struct.add(cache.toDataType(), "cache", null);
-		struct.add(vtable.toDataType(), "vtable", null);
-
-		if (data == null) {
-			ObjectiveC2_ClassRW fakeData = new ObjectiveC2_ClassRW();
-			struct.add(new PointerDataType(fakeData.toDataType()), _state.pointerSize, "data", null);
-		}
-		else {
-			struct.add(new PointerDataType(data.toDataType()), _state.pointerSize, "data", null);
-		}
-
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {//handle circular references
-			return;
-		}
-		_state.beenApplied.add(_index);
-
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {
-		}
-
-		try {
-			Namespace namespace =
-				ObjectiveC1_Utilities.createNamespace(_state.program,
-					ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_Class.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, namespace, data.getName(), address);
-		}
-		catch (Exception e) {
-		}
-
-		if (isa != null) {
-			isa.applyTo();
-		}
-		if (superclass != null) {
-			superclass.applyTo();
-		}
-		if (cache != null) {
-			cache.applyTo();
-		}
-		if (vtable != null) {
-			vtable.applyTo();
-		}
-		if (data != null) {
-			data.applyTo();
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java
deleted file mode 100644
index 3dcee0386eb..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_InstanceVariable implements StructConverter {
-	private ObjectiveC2_State _state;
-
-	private long offset;
-	private String name;
-	private String type;
-	private int alignment;
-	private int size;
-
-	public ObjectiveC2_InstanceVariable(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-
-		if (state.is32bit) {
-			offset = reader.readNextUnsignedInt();
-		}
-		else {
-			offset = reader.readNextLong();
-		}
-
-		long nameIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-		if (nameIndex > 0 && reader.isValidIndex(nameIndex)) {
-			name      = reader.readAsciiString( nameIndex );
-		}
-
-		long typeIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-		if (typeIndex > 0 && reader.isValidIndex(typeIndex)) {
-			type      = reader.readAsciiString( typeIndex );
-		}
-
-		alignment  = reader.readNextInt();
-		size       = reader.readNextInt();
-	}
-
-	public long getOffset() {
-		return offset;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String getType() {
-		return type;
-	}
-
-	public int getAlignment() {
-		return alignment;
-	}
-
-	public int getSize() {
-		return size;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType("ivar_t", 0);
-		if (_state.is32bit) {
-			struct.add(new PointerDataType(DWORD), _state.pointerSize, "offset", null);
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "name", null);
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "type", null);
-		}
-		else {
-			struct.add(new PointerDataType(QWORD), _state.pointerSize, "offset", null);
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "name", null);
-			struct.add(new PointerDataType(STRING), _state.pointerSize, "type", null);
-		}
-		struct.add(DWORD, "alignment", null);
-		struct.add(DWORD, "size", null);
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo(Namespace namespace) throws Exception {
-		if (getOffset() == 0) {
-			return;
-		}
-		if (getName() == null && getName().length() == 0) {
-			return;
-		}
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(getOffset());
-		ObjectiveC1_Utilities.createSymbol(_state.program, namespace, getName(), address);
-		_state.variableMap.put(address, this);
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariableList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariableList.java
deleted file mode 100644
index 76797560bd0..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariableList.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_InstanceVariableList implements StructConverter {
-	public final static String NAME = "ivar_list_t";
-
-	private ObjectiveC2_State _state;
-	private long _index;
-
-	private int entsize;
-	private int count;
-	private List<ObjectiveC2_InstanceVariable> ivars = new ArrayList<ObjectiveC2_InstanceVariable>();
-
-	public ObjectiveC2_InstanceVariableList(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		entsize = reader.readNextInt();
-		count   = reader.readNextInt();
-
-		for (int i = 0 ; i < count ; ++i) {
-			ivars.add( new ObjectiveC2_InstanceVariable(state, reader) );
-		}
-	}
-
-	public long getEntsize() {
-		return entsize;
-	}
-
-	public long getCount() {
-		return count;
-	}
-
-	public List<ObjectiveC2_InstanceVariable> getIvars() {
-		return ivars;
-	}
-
-	public long getIndex() {
-		return _index;
-	}
-
-	public static DataType toGenericDataType() throws DuplicateNameException {
-		Structure struct = new StructureDataType(NAME, 0);
-		struct.add(DWORD, "entsize", null);
-		struct.add(DWORD,   "count", null);
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType(NAME+'_'+count+'_', 0);
-
-		struct.add(DWORD, "entsize", null);
-		struct.add(DWORD,   "count", null);
-
-		for (int i = 0 ; i < ivars.size() ; ++i) {
-			struct.add(ivars.get(i).toDataType(), "var"+i, null);
-		}
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo(Namespace namespace) throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {}
-
-		try {
-			Namespace instanceVariableNamespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_InstanceVariableList.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, instanceVariableNamespace, namespace.getName(), address);
-		}
-		catch (Exception e) {}
-
-		for (ObjectiveC2_InstanceVariable ivar : getIvars()) {
-			ivar.applyTo(namespace);
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java
deleted file mode 100644
index 15ac5e544c2..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.data.*;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_MessageReference implements StructConverter {
-	public static final String NAME = "message_ref";
-
-	public static int SIZEOF(ObjectiveC2_State state) {
-		return 2 * state.pointerSize;
-	}
-
-	private ObjectiveC2_State _state;
-
-	private long implementation;
-	private String selector;
-
-	public ObjectiveC2_MessageReference(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-
-		if (state.is32bit) {
-			implementation = reader.readNextUnsignedInt();
-		}
-		else {
-			implementation = reader.readNextLong();
-		}
-
-		long selectorIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-		if (selectorIndex != 0) {
-			selector = reader.readAsciiString(selectorIndex);
-		}
-	}
-
-	public long getImplementation() {
-		return implementation;
-	}
-
-	public String getSelector() {
-		return selector;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType(NAME, 0);
-		struct.add(new PointerDataType(VOID),  _state.pointerSize, "imp", null);
-		struct.add(new PointerDataType(ASCII), _state.pointerSize, "sel", null);
-		return struct;
-	}
-}
-
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_PropertyList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_PropertyList.java
deleted file mode 100644
index 99252e67c72..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_PropertyList.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_PropertyList implements StructConverter {
-	public final static String NAME = "objc_property_list";
-
-	private ObjectiveC2_State _state;
-	private long _index = -1;
-
-	private int entsize;
-	private int count;
-
-	private List<ObjectiveC2_Property> properties = new ArrayList<ObjectiveC2_Property>();
-
-	public ObjectiveC2_PropertyList(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		entsize = reader.readNextInt();
-		count   = reader.readNextInt();
-
-		for (int i = 0 ; i < count ; ++i) {
-			properties.add( new ObjectiveC2_Property(state, reader) );
-		}
-	}
-
-	public long getIndex() {
-		return _index;
-	}
-
-	public int getEntrySize() {
-		return entsize;
-	}
-
-	public int getCount() {
-		return count;
-	}
-
-	public List<ObjectiveC2_Property> getProperties() {
-		return properties;
-	}
-
-	public static DataType toGenericDataType() throws DuplicateNameException {
-		Structure struct = new StructureDataType(NAME, 0);
-		struct.add(DWORD, "entsize", null);
-		struct.add(DWORD,   "count", null);
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType(NAME+'_'+count+'_', 0);
-
-		struct.add(DWORD, "entsize", null);
-		struct.add(DWORD,   "count", null);
-
-		for (int i = 0 ; i < properties.size() ; ++i) {
-			struct.add(properties.get(i).toDataType(), "property"+i, null);
-		}
-
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo(Namespace namespace) throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {}
-
-		try {
-			Namespace propertyListNamespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_PropertyList.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, propertyListNamespace, namespace.getName(), address);
-		}
-		catch (Exception e) {}
-
-		for (ObjectiveC2_Property property : getProperties()) {
-			property.applyTo( namespace);
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java
deleted file mode 100644
index 6386b19d215..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC2_ProtocolList implements StructConverter {
-	public final static String NAME = "protocol_list_t";
-
-	private ObjectiveC2_State _state;
-	private long _index;
-
-	private List<ObjectiveC2_Protocol> protocols = new ArrayList<ObjectiveC2_Protocol>();
-
-	public ObjectiveC2_ProtocolList(ObjectiveC2_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		long count = state.is32bit ? reader.readNextUnsignedInt() : reader.readNextLong();
-
-		for (long i = 0 ; i < count ; ++i) {
-			long protocolIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
-			long originalIndex = reader.getPointerIndex();
-			reader.setPointerIndex(protocolIndex);
-			protocols.add( new ObjectiveC2_Protocol(state, reader) );
-			reader.setPointerIndex(originalIndex);
-		}
-	}
-
-	public long getCount() {
-		return protocols.size();
-	}
-
-	public long getIndex() {
-		return _index;
-	}
-
-	public List<ObjectiveC2_Protocol> getProtocols() {
-		return protocols;
-	}
-
-	public static DataType toGenericDataType(ObjectiveC2_State state)
-			throws DuplicateNameException {
-		Structure struct = new StructureDataType(NAME, 0);
-		if (state.is32bit) {
-			struct.add(DWORD, "count", null);
-		}
-		else {
-			struct.add(QWORD, "count", null);
-		}
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		Structure struct = new StructureDataType(NAME+'_'+protocols.size()+'_', 0);
-
-		if (_state.is32bit) {
-			struct.add(DWORD, "count", null);
-		}
-		else {
-			struct.add(QWORD, "count", null);
-		}
-
-		for (int i = 0 ; i < protocols.size() ; ++i) {
-			DataType dataType = protocols.get(i).toDataType();
-			struct.add(new PointerDataType(dataType), _state.pointerSize, "protocol"+i, null);
-		}
-
-		struct.setCategoryPath(ObjectiveC2_Constants.CATEGORY_PATH);
-		return struct;
-	}
-
-	public void applyTo(Namespace namespace) throws Exception {
-		Address address = ObjectiveC1_Utilities.toAddress(_state.program, getIndex());
-		try {
-			ObjectiveC1_Utilities.applyData(_state.program, toDataType(), address);
-		}
-		catch (Exception e) {}
-
-		try {
-			Namespace protocolListNamespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, ObjectiveC2_ProtocolList.NAME);
-			ObjectiveC1_Utilities.createSymbol(_state.program, protocolListNamespace, namespace.getName(), address);
-		}
-		catch (Exception e) {}
-
-		for (ObjectiveC2_Protocol protocol : getProtocols()) {
-			protocol.applyTo(namespace);
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_State.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_State.java
deleted file mode 100644
index 5e98c3fb74a..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_State.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.util.*;
-
-import ghidra.app.util.bin.format.macho.dyld.LibObjcOptimization;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_State;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.CategoryPath;
-import ghidra.program.model.listing.Program;
-import ghidra.util.task.TaskMonitor;
-
-public class ObjectiveC2_State extends ObjectiveC1_State {
-
-	/**
-	 * A map of the index where the class structure was defined to instantiated class object.
-	 */
-	public final Map<Long, ObjectiveC2_Class> classIndexMap = new HashMap<Long, ObjectiveC2_Class>();
-
-	/**
-	 * A map of instance variable addresses to mangled type strings.
-	 */
-	public final Map<Address, ObjectiveC2_InstanceVariable> variableMap = new HashMap<Address, ObjectiveC2_InstanceVariable>();
-
-	/**
-	 * The dyld_shared_cache libobjc objc_opt_t structure, if it exists
-	 */
-	public LibObjcOptimization libObjcOptimization = null;
-
-	public ObjectiveC2_State(Program program, TaskMonitor monitor, CategoryPath categoryPath) {
-		super(program, monitor, categoryPath);
-	}
-
-	@Override
-	public void dispose() {
-		super.dispose();
-		classIndexMap.clear();
-		variableMap.clear();
-	}
-
-	@Override
-	public List<String> getObjectiveCSectionNames() {
-		return ObjectiveC2_Constants.getObjectiveC2SectionNames();
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java
deleted file mode 100644
index 72e133b4489..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objc2;
-
-import java.io.IOException;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.program.database.symbol.ClassSymbol;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.listing.GhidraClass;
-import ghidra.program.model.listing.Program;
-import ghidra.program.model.mem.Memory;
-import ghidra.program.model.mem.MemoryBlock;
-import ghidra.program.model.symbol.*;
-import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.exception.InvalidInputException;
-
-final class ObjectiveC2_Utilities {
-
-	/**
-	 * Reads the next index value. If is32bit is true, then 4 bytes
-	 * will be read to form index. Otherwise, 8 bytes will be read to form index.
-	 */
-	static long readNextIndex(BinaryReader reader, boolean is32bit) throws IOException {
-		if (is32bit) {
-			return reader.readNextUnsignedInt();
-		}
-		return reader.readNextLong();
-	}
-
-	/**
-	 * Returns the name space inside the given parent name space.
-	 * If it does not exist, then create it and return it.
-	 */
-	static Namespace getNamespace(Program program, Namespace parentNamespace, String namespaceName)
-			throws DuplicateNameException, InvalidInputException {
-		SymbolTable symbolTable = program.getSymbolTable();
-		Namespace namespace = symbolTable.getNamespace(namespaceName, parentNamespace);
-		if (namespace != null) {
-			return namespace;
-		}
-		return symbolTable.createNameSpace(parentNamespace, namespaceName, SourceType.IMPORTED);
-	}
-
-	/**
-	 * Returns the class inside the given parent name space.
-	 * If it does not exist, then create it and return it.
-	 */
-	static Namespace getClassNamespace(Program program, Namespace parentNamespace,
-			String namespaceName) throws DuplicateNameException, InvalidInputException {
-		SymbolTable symbolTable = program.getSymbolTable();
-		Symbol symbol = symbolTable.getClassSymbol(namespaceName, parentNamespace);
-		if (symbol instanceof ClassSymbol) {
-			if (symbol.getName().equals(namespaceName)) {
-				return (GhidraClass) symbol.getObject();
-			}
-		}
-		return symbolTable.createClass(parentNamespace, namespaceName, SourceType.IMPORTED);
-	}
-
-	/**
-	 * Creates a symbol with the given name at the specified address.
-	 * The symbol will be created in a name space with the name of
-	 * the memory block that contains the address.
-	 */
-	public static Symbol createSymbolUsingMemoryBlockAsNamespace(Program program, Address address,
-			String name, SourceType sourceType)
-			throws DuplicateNameException, InvalidInputException {
-
-		SymbolTable symbolTable = program.getSymbolTable();
-		Memory memory = program.getMemory();
-
-		MemoryBlock block = memory.getBlock(address);
-		String namespaceName = block.getName();
-
-		Namespace namespace = symbolTable.getNamespace(namespaceName, program.getGlobalNamespace());
-		if (namespace == null) {
-			namespace = symbolTable.createNameSpace(program.getGlobalNamespace(), namespaceName,
-				sourceType);
-		}
-
-		return symbolTable.createLabel(address, name, namespace, SourceType.ANALYSIS);
-	}
-
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Category.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Category.java
deleted file mode 100644
index a61c122aaec..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Category.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-import java.io.IOException;
-
-public class ObjectiveC1_Category implements StructConverter {
-	public static final long SIZEOF = 0;
-
-	private ObjectiveC1_State _state;
-	private long _index;
-
-	private String category_name;
-	private String class_name;
-	private ObjectiveC1_MethodList instance_methods;
-	private ObjectiveC1_MethodList class_methods;
-	private ObjectiveC1_ProtocolList protocols;
-	private int unknown0;
-	private int unknown1;
-
-	public ObjectiveC1_Category(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		category_name    = reader.readAsciiString( reader.readNextInt() );
-		class_name       = reader.readAsciiString( reader.readNextInt() );
-		instance_methods = new ObjectiveC1_MethodList(state, reader.clone(reader.readNextInt()), ObjectiveC_MethodType.INSTANCE);
-		class_methods    = new ObjectiveC1_MethodList(state, reader.clone(reader.readNextInt()), ObjectiveC_MethodType.CLASS);
-		protocols        = new ObjectiveC1_ProtocolList(state, reader.clone( reader.readNextInt() ));
-
-		if (state.isARM) {
-			unknown0     = reader.readNextInt();
-			unknown1     = reader.readNextInt();
-		}
-	}
-
-	public String getCategoryName() {
-		return category_name;
-	}
-
-	public String getClassName() {
-		return class_name;
-	}
-
-	public ObjectiveC1_MethodList getInstanceMethods() {
-		return instance_methods;
-	}
-
-	public ObjectiveC1_MethodList getClassMethods() {
-		return class_methods;
-	}
-
-	public ObjectiveC1_ProtocolList getProtocols() {
-		return protocols;
-	}
-
-	public int getUnknown0() {
-		return unknown0;
-	}
-	public int getUnknown1() {
-		return unknown1;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		String name = "objc_category";
-		StructureDataType struct = new StructureDataType(name, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "category_name", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "class_name", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_MethodList.toGenericDataType(_state), _state.pointerSize), "instance_methods", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_MethodList.toGenericDataType(_state), _state.pointerSize), "class_methods", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolList.toGenericDataType(_state), _state.pointerSize), "protocols", null);
-		if (_state.isARM) {
-			struct.add(DWORD, "unknown0", null);
-			struct.add(DWORD, "unknown1", null);
-		}
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
-			return;
-		}
-		_state.beenApplied.add(_index);
-
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
-		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
-
-		Namespace namespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, "Categories", class_name+'('+category_name+')');
-
-		instance_methods.applyTo(namespace);
-		class_methods.applyTo(namespace);
-		protocols.applyTo();
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Class.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Class.java
deleted file mode 100644
index f270646ffd7..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Class.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.program.model.symbol.SourceType;
-import ghidra.util.exception.DuplicateNameException;
-
-import java.io.IOException;
-
-public class ObjectiveC1_Class implements StructConverter {
-	public final static String NAME = "objc_class";
-	public static final long SIZEOF = 0x30;
-
-	private ObjectiveC1_State _state;
-	private long _index;
-
-	private ObjectiveC1_MetaClass isa;
-	private String super_class;
-	private String name;
-	private int version;
-	private int info;
-	private int instance_size;
-	private ObjectiveC1_InstanceVariableList variable_list;
-	private ObjectiveC1_MethodList method_list;
-	private int cache;
-	private ObjectiveC1_ProtocolList protocols;
-	private int unknown0;
-	private int unknown1;
-
-	public ObjectiveC1_Class(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		isa = new ObjectiveC1_MetaClass(state, reader.clone(reader.readNextInt()));
-		super_class = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		name = reader.readAsciiString(reader.readNextInt());
-		version = reader.readNextInt();
-		info = reader.readNextInt();
-		instance_size = reader.readNextInt();
-		variable_list =
-			new ObjectiveC1_InstanceVariableList(state, reader.clone(reader.readNextInt()));
-		method_list =
-			new ObjectiveC1_MethodList(state, reader.clone(reader.readNextInt()),
-				ObjectiveC_MethodType.INSTANCE);
-		cache = reader.readNextInt();
-		protocols = new ObjectiveC1_ProtocolList(state, reader.clone(reader.readNextInt()));
-		unknown0 = reader.readNextInt();
-		unknown1 = reader.readNextInt();
-	}
-
-	public ObjectiveC1_MetaClass getISA() {
-		return isa;
-	}
-
-	public String getSuperClass() {
-		return super_class;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public int getVersion() {
-		return version;
-	}
-
-	public int getInfo() {
-		return info;
-	}
-
-	public int getInstanceSize() {
-		return instance_size;
-	}
-
-	public ObjectiveC1_InstanceVariableList getInstanceVariableList() {
-		return variable_list;
-	}
-
-	public ObjectiveC1_MethodList getMethodList() {
-		return method_list;
-	}
-
-	public int getCache() {
-		return cache;
-	}
-
-	public ObjectiveC1_ProtocolList getProtocols() {
-		return protocols;
-	}
-
-	public int getUnknown0() {
-		return unknown0;
-	}
-
-	public int getUnknown1() {
-		return unknown1;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		StructureDataType struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(isa.toDataType(), _state.pointerSize), "isa", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "super_class", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "name", null);
-		struct.add(DWORD, "version", null);
-		struct.add(DWORD, "info", null);
-		struct.add(DWORD, "instance_size", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_InstanceVariableList.toGenericDataType(),
-			_state.pointerSize), "instance_vars", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_MethodList.toGenericDataType(_state),
-			_state.pointerSize), "method_lists", null);
-		struct.add(DWORD, "cache", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolList.toGenericDataType(_state),
-			_state.pointerSize), "protocols", null);
-		struct.add(DWORD, "unknown0", null);
-		struct.add(DWORD, "unknown1", null);
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		Address address =
-			_state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
-		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength() - 1), false);
-		_state.program.getListing().createData(address, dt);
-		_state.program.getSymbolTable().createLabel(address, "objc_class_" + name,
-			SourceType.ANALYSIS);
-
-		Namespace namespace = ObjectiveC1_Utilities.getClassNamespace(_state.program, null, name);
-
-		isa.applyTo();
-		variable_list.applyTo();
-		method_list.applyTo(namespace);
-
-		//don't do protocols here... they are applied independent
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MetaClass.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MetaClass.java
deleted file mode 100644
index 517aa109a12..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_MetaClass.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.util.exception.DuplicateNameException;
-
-import java.io.IOException;
-
-public class ObjectiveC1_MetaClass implements StructConverter {
-	private ObjectiveC1_State _state;
-	private long _index;
-
-	private String isa;
-	private String super_class;
-	private String name;
-	private int version;
-	private int info;
-	private int instance_size;
-	private ObjectiveC1_InstanceVariableList variable_list;
-	private ObjectiveC1_MethodList method_list;
-	private int cache;
-	private ObjectiveC1_ProtocolList protocols;
-	private int unknown0;
-	private int unknown1;
-
-	ObjectiveC1_MetaClass(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		isa                = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		super_class        = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		name               = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		version            = reader.readNextInt();
-		info               = reader.readNextInt();
-		instance_size      = reader.readNextInt();
-		variable_list      = new ObjectiveC1_InstanceVariableList(state, reader.clone(reader.readNextInt()));
-		method_list        = new ObjectiveC1_MethodList(state, reader.clone(reader.readNextInt()), ObjectiveC_MethodType.INSTANCE);
-		cache              = reader.readNextInt();
-		protocols          = new ObjectiveC1_ProtocolList(state, reader.clone(reader.readNextInt()));
-		unknown0           = reader.readNextInt();
-		unknown1           = reader.readNextInt();
-	}
-
-	public String getISA() {
-		return isa;
-	}
-	public String getSuperClass() {
-		return super_class;
-	}
-	public String getName() {
-		return name;
-	}
-	public int getVersion() {
-		return version;
-	}
-	public int getInfo() {
-		return info;
-	}
-	public int getInstanceSize() {
-		return instance_size;
-	}
-	public ObjectiveC1_InstanceVariableList getInstanceVariableList() {
-		return variable_list;
-	}
-	public ObjectiveC1_MethodList getMethodList() {
-		return method_list;
-	}
-	public int getCache() {
-		return cache;
-	}
-	public ObjectiveC1_ProtocolList getProtocols() {
-		return protocols;
-	}
-	public int getUnknown0() {
-		return unknown0;
-	}
-	public int getUnknown1() {
-		return unknown1;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		String name = "objc_metaclass";
-		StructureDataType struct = new StructureDataType(name, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "isa", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "super_class", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "name", null);
-		struct.add(DWORD, "version", null);
-		struct.add(DWORD, "info", null);
-		struct.add(DWORD, "instance_size", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_InstanceVariableList.toGenericDataType(), _state.pointerSize), "instance_vars", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_MethodList.toGenericDataType(_state), _state.pointerSize), "method_lists", null);
-		struct.add(DWORD, "cache", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolList.toGenericDataType(_state), _state.pointerSize), "protocols", null);
-		struct.add(DWORD, "unknown0", null);
-		struct.add(DWORD, "unknown1", null);
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
-			return;
-		}
-		_state.beenApplied.add(_index);
-
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
-		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
-
-		Namespace namespace = ObjectiveC1_Utilities.createNamespace(_state.program, ObjectiveC1_Constants.NAMESPACE, "Meta-classes", name);
-
-		variable_list.applyTo();
-		method_list.applyTo(namespace);
-		protocols.applyTo();
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Protocol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Protocol.java
deleted file mode 100644
index 57633438fde..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Protocol.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.DataType;
-import ghidra.program.model.data.PointerDataType;
-import ghidra.program.model.data.StructureDataType;
-import ghidra.util.exception.DuplicateNameException;
-
-import java.io.IOException;
-
-public class ObjectiveC1_Protocol implements StructConverter {
-	public final static String NAME = "objc_protocol";
-	public final static int SIZEOF = 20;
-
-	private ObjectiveC1_State _state;
-	private long _index;
-
-	private int isa;
-	private String name;
-	private ObjectiveC1_ProtocolList protocolList;
-	private ObjectiveC1_ProtocolMethodList instanceMethods;
-	private ObjectiveC1_ProtocolMethodList classMethods;
-
-	public ObjectiveC1_Protocol(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-
-		isa             = reader.readNextInt();
-		name            = ObjectiveC1_Utilities.dereferenceAsciiString(reader, state.is32bit);
-		protocolList    = new ObjectiveC1_ProtocolList(state, reader.clone(reader.readNextInt()));
-		instanceMethods = new ObjectiveC1_ProtocolMethodList(state, reader.clone(reader.readNextInt()), ObjectiveC_MethodType.INSTANCE);
-		classMethods    = new ObjectiveC1_ProtocolMethodList(state, reader.clone(reader.readNextInt()), ObjectiveC_MethodType.CLASS);
-	}
-
-	public int getIsa() {
-		return isa;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public ObjectiveC1_ProtocolList getProtocolList() {
-		return protocolList;
-	}
-
-	public ObjectiveC1_ProtocolMethodList getInstanceMethods() {
-		return instanceMethods;
-	}
-
-	public ObjectiveC1_ProtocolMethodList getClassMethods() {
-		return classMethods;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		StructureDataType struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(DWORD, "isa", null);
-		struct.add(PointerDataType.getPointer(ASCII, _state.pointerSize), "name", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolList.toGenericDataType(_state), _state.pointerSize), "protocolList", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolMethodList.toGenericDataType(_state), _state.pointerSize), "instanceMethods", null);
-		struct.add(PointerDataType.getPointer(ObjectiveC1_ProtocolMethodList.toGenericDataType(_state), _state.pointerSize), "classMethods", null);
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		if (_state.beenApplied.contains(_index)) {
-			return;
-		}
-		_state.beenApplied.add(_index);
-
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
-		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
-
-		protocolList.applyTo();
-		instanceMethods.applyTo();
-		classMethods.applyTo();
-	}
-
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolList.java
deleted file mode 100644
index e0fc19abb8c..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_ProtocolList.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.StructConverter;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.*;
-import ghidra.util.exception.DuplicateNameException;
-
-public class ObjectiveC1_ProtocolList implements StructConverter {
-	public static final String NAME = "objc_protocol_list";
-
-	private ObjectiveC1_State _state;
-	private long _index;
-
-	private ObjectiveC1_ProtocolList next;
-	private int count;
-	private List<ObjectiveC1_Protocol> protocols = new ArrayList<ObjectiveC1_Protocol>();
-
-	ObjectiveC1_ProtocolList(ObjectiveC1_State state, BinaryReader reader) throws IOException {
-		this._state = state;
-		this._index = reader.getPointerIndex();
-		if (_index == 0) {
-			return;
-		}
-
-		next = new ObjectiveC1_ProtocolList(state, reader.clone( reader.readNextInt() ));
-
-		count = reader.readNextInt();
-
-		for (int i = 0 ; i < count ; ++i) {
-			int protocolIndex = reader.readNextInt();
-			long oldProtocolIndex = reader.getPointerIndex();
-			reader.setPointerIndex(protocolIndex);
-			protocols.add(new ObjectiveC1_Protocol(state, reader));
-			reader.setPointerIndex(oldProtocolIndex);
-		}
-	}
-
-	public ObjectiveC1_ProtocolList getNext() {
-		return next;
-	}
-
-	public int getCount() {
-		return count;
-	}
-
-	public List<ObjectiveC1_Protocol> getProtocols() {
-		return protocols;
-	}
-
-	public static DataType toGenericDataType(ObjectiveC1_State state)
-			throws DuplicateNameException {
-		Structure struct = new StructureDataType(NAME, 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(struct, state.pointerSize), "next", null);
-		struct.add(DWORD, "count", null);
-		return struct;
-	}
-
-	@Override
-	public DataType toDataType() throws DuplicateNameException, IOException {
-		StructureDataType struct = new StructureDataType(NAME+"_"+count+"_", 0);
-		struct.setCategoryPath(ObjectiveC1_Constants.CATEGORY_PATH);
-		struct.add(PointerDataType.getPointer(toGenericDataType(_state), _state.pointerSize), "next", null);
-		struct.add(DWORD, "count", null);
-		if (count > 0) {
-			DataType dt = PointerDataType.getPointer(protocols.get(0).toDataType(), _state.pointerSize);
-			struct.add(new ArrayDataType(dt, count, dt.getLength()), "protocols", null);
-		}
-		return struct;
-	}
-
-	public void applyTo() throws Exception {
-		if (_index == 0) {
-			return;
-		}
-		if (_state.beenApplied.contains(_index)) {
-			return;
-		}
-		_state.beenApplied.add(_index);
-
-		Address address = _state.program.getAddressFactory().getDefaultAddressSpace().getAddress(_index);
-		DataType dt = toDataType();
-		_state.program.getListing().clearCodeUnits(address, address.add(dt.getLength()-1), false);
-		_state.program.getListing().createData(address, dt);
-
-		for (ObjectiveC1_Protocol protocol : protocols) {
-			if (_state.monitor.isCancelled()) {
-				break;
-			}
-			protocol.applyTo();
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_State.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_State.java
deleted file mode 100644
index 83e6d225b31..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_State.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/* ###
- * IP: GHIDRA
- * REVIEWED: YES
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import ghidra.program.model.address.Address;
-import ghidra.program.model.data.CategoryPath;
-import ghidra.program.model.lang.*;
-import ghidra.program.model.listing.Program;
-import ghidra.util.task.TaskMonitor;
-
-import java.util.*;
-
-public class ObjectiveC1_State {
-
-	/**
-	 * If an index is contained in this set, then the corresponding data structure has been applied to the program.
-	 */
-	public final Set<Long> beenApplied = new HashSet<Long>();
-
-	/**
-	 * A map of method addresses to mangled signature strings.
-	 */
-	public final Map<Address, ObjectiveC_Method> methodMap = new HashMap<Address, ObjectiveC_Method>();
-
-	/**
-	 * If an address is contained in this set, then it is thumb code.
-	 */
-	public final Set<Address> thumbCodeLocations = new HashSet<Address>();
-
-	public final Program program;
-	public final boolean is32bit;
-	public final boolean is64bit;
-	public final boolean isARM;
-	public final boolean isPowerPC;
-	public final boolean isX86;
-	public final int pointerSize;
-	public final TaskMonitor monitor;
-	public final ObjectiveC1_TypeEncodings encodings;
-
-	public ObjectiveC1_State(Program program, TaskMonitor monitor, CategoryPath categoryPath) {
-		this.program       =  program;
-		this.pointerSize   =  program.getAddressFactory().getDefaultAddressSpace().getPointerSize();
-		this.is32bit       =  pointerSize * 8 == 32;
-		this.is64bit       =  pointerSize * 8 == 64;
-		this.monitor       =  monitor;
-		this.encodings     =  new ObjectiveC1_TypeEncodings(pointerSize, categoryPath);
-
-		Language language = program.getLanguage();
-		this.isARM     = language.getProcessor().equals(Processor.findOrPossiblyCreateProcessor("ARM"));
-		this.isPowerPC = language.getProcessor().equals(Processor.findOrPossiblyCreateProcessor("PowerPC"));
-		this.isX86     = language.getProcessor().equals(Processor.findOrPossiblyCreateProcessor("x86"));
-	}
-
-	public void dispose() {
-		beenApplied.clear();
-		methodMap.clear();
-		thumbCodeLocations.clear();
-	}
-
-	public List<String> getObjectiveCSectionNames() {
-		return ObjectiveC1_Constants.getObjectiveCSectionNames();
-	}
-
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java
deleted file mode 100644
index 318af1ef62c..00000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java
+++ /dev/null
@@ -1,404 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.objectiveC;
-
-import java.io.IOException;
-import java.math.BigInteger;
-import java.util.*;
-
-import ghidra.app.cmd.data.CreateDataCmd;
-import ghidra.app.cmd.disassemble.DisassembleCommand;
-import ghidra.app.cmd.function.CreateFunctionCmd;
-import ghidra.app.cmd.register.SetRegisterCmd;
-import ghidra.app.util.bin.BinaryReader;
-import ghidra.app.util.bin.format.objc2.ObjectiveC2_InstanceVariable;
-import ghidra.app.util.bin.format.objc2.ObjectiveC2_State;
-import ghidra.framework.cmd.BackgroundCommand;
-import ghidra.framework.cmd.Command;
-import ghidra.program.database.symbol.ClassSymbol;
-import ghidra.program.model.address.*;
-import ghidra.program.model.data.*;
-import ghidra.program.model.data.DataUtilities.ClearDataMode;
-import ghidra.program.model.lang.Processor;
-import ghidra.program.model.lang.Register;
-import ghidra.program.model.listing.*;
-import ghidra.program.model.mem.Memory;
-import ghidra.program.model.mem.MemoryBlock;
-import ghidra.program.model.symbol.*;
-import ghidra.program.model.util.CodeUnitInsertionException;
-import ghidra.util.Msg;
-import ghidra.util.StringUtilities;
-import ghidra.util.exception.DuplicateNameException;
-import ghidra.util.exception.InvalidInputException;
-
-public final class ObjectiveC1_Utilities {
-
-	/**
-	 * Clears the code units defined in the given memory block.
-	 */
-	public static void clear(ObjectiveC2_State state, MemoryBlock block) throws Exception {
-		state.program.getListing()
-				.clearCodeUnits(block.getStart(), block.getEnd(), false, state.monitor);
-	}
-
-	/**
-	 * Reads the next index value. If is32bit is true, then 4 bytes
-	 * will be read to form index. Otherwise, 8 bytes will be read to form index.
-	 */
-	public static long readNextIndex(BinaryReader reader, boolean is32bit) throws IOException {
-		if (is32bit) {
-			return reader.readNextUnsignedInt();
-		}
-		return reader.readNextLong();
-	}
-
-	/**
-	 * Dereferences a string pointer and returns the string.
-	 * If 32-bit only reads a 32-bit pointer.
-	 */
-	public static String dereferenceAsciiString(BinaryReader reader, boolean is32bit)
-			throws IOException {
-		if (is32bit) {
-			int stringIndex = reader.readNextInt();
-			if (stringIndex != 0) {
-				return reader.readAsciiString(stringIndex);
-			}
-			return null;
-		}
-		long stringIndex = reader.readNextLong();
-		if (stringIndex != 0) {
-			return reader.readAsciiString(stringIndex);
-		}
-		return null;
-	}
-
-	/**
-	 * Returns true if the given address is zero.
-	 */
-	public static boolean isNull(Address address) {
-		return address.getOffset() == 0x0;
-	}
-
-	/**
-	 * Returns true if the address is THUMB code.
-	 */
-	public static boolean isThumb(Program program, Address address) {
-		Processor ARM = Processor.findOrPossiblyCreateProcessor("ARM");
-		if (program.getLanguage().getProcessor().equals(ARM)) {
-			Memory memory = program.getMemory();
-			MemoryBlock block = memory.getBlock(address);
-			if (block != null && block.isExecute()) {
-				return (address.getOffset() % 2) != 0;
-			}
-		}
-		return false;
-	}
-
-	/**
-	 * Returns true if the address is THUMB code.
-	 */
-	public static boolean isThumb(Program program, long address) {
-		return isThumb(program,
-			program.getAddressFactory().getDefaultAddressSpace().getAddress(address));
-	}
-
-	/**
-	 * If needed, sets the TMode bit at the specified address.
-	 */
-	public static void setThumbBit(ObjectiveC1_State state, Address address) {
-		if (state.thumbCodeLocations.contains(address)) {
-			Register tmodeRegister = state.program.getLanguage().getRegister("TMode");
-			if (tmodeRegister != null) {
-				Command<Program> c =
-					new SetRegisterCmd(tmodeRegister, address, address, BigInteger.valueOf(1));
-				c.applyTo(state.program);
-			}
-		}
-	}
-
-	/**
-	 * Manufactures an address from the given long.
-	 */
-	public static Address toAddress(Program program, long offset) {
-		return program.getAddressFactory().getDefaultAddressSpace().getAddress(offset);
-	}
-
-	/**
-	 * Applies the data type at the specified address.
-	 */
-	public static void applyData(Program program, DataType dt, Address address)
-			throws CodeUnitInsertionException {
-		Data data = program.getListing().getDefinedDataAt(address);
-		if (data != null && data.getDataType().isEquivalent(dt)) {
-			return;
-		}
-
-		// need to clear, as pointers could have been created on import
-		// from following pointer chains
-		DataUtilities.createData(program, address, dt, -1,
-			ClearDataMode.CLEAR_ALL_DEFAULT_CONFLICT_DATA);
-	}
-
-	/**
-	 * Applies a string data type at the specified address and returns the string object.
-	 */
-	public static String createString(Program program, Address address) {
-		Data data = program.getListing().getDataAt(address);
-		if (data == null) {
-			CreateDataCmd cmd = new CreateDataCmd(address, new StringDataType());
-			cmd.applyTo(program);
-			data = program.getListing().getDefinedDataAt(address);
-		}
-		if (data == null) {
-			return null;
-		}
-		Object object = data.getValue();
-		if (object instanceof String) {
-			return (String) object;
-		}
-		Msg.error(null, "Unable to locate string at " + address);
-		return null;//error condition, a string should exist here
-	}
-
-	/**
-	 * Applies a pointer data type at the specified address and returns the address being referenced.
-	 */
-	public static Address createPointerAndReturnAddressBeingReferenced(Program program,
-			Address address) throws CodeUnitInsertionException {
-		program.getListing().createData(address, new PointerDataType());
-		Data data = program.getListing().getDefinedDataAt(address);
-		return (Address) data.getValue();
-	}
-
-	/**
-	 * Returns the name space inside the given parent name space.
-	 * If it does not exist, then create it and return it.
-	 */
-	private static Namespace getNamespace(Program program, Namespace parentNamespace,
-			String namespaceName) throws DuplicateNameException, InvalidInputException {
-		SymbolTable symbolTable = program.getSymbolTable();
-		Namespace namespace = symbolTable.getNamespace(namespaceName, parentNamespace);
-		if (namespace != null) {
-			return namespace;
-		}
-		return symbolTable.createNameSpace(parentNamespace, namespaceName, SourceType.IMPORTED);
-	}
-
-	/**
-	 * Returns the class inside the given parent name space.
-	 * If it does not exist, then create it and return it.
-	 */
-	public static Namespace getClassNamespace(Program program, Namespace parentNamespace,
-			String namespaceName) throws DuplicateNameException, InvalidInputException {
-		SymbolTable symbolTable = program.getSymbolTable();
-		Symbol symbol = symbolTable.getClassSymbol(namespaceName, parentNamespace);
-		if (symbol instanceof ClassSymbol) {
-			if (symbol.getName().equals(namespaceName)) {
-				return (GhidraClass) symbol.getObject();
-			}
-		}
-		return symbolTable.createClass(parentNamespace, namespaceName, SourceType.IMPORTED);
-	}
-
-	/**
-	 * Creates a symbol.
-	 *
-	 * TODO - make symbols primary?
-	 */
-	public static Symbol createSymbol(Program program, Namespace parentNamespace, String symbolName,
-			Address symbolAddress) throws InvalidInputException {
-		Symbol symbol = program.getSymbolTable()
-				.createLabel(symbolAddress, symbolName, parentNamespace, SourceType.IMPORTED);
-		symbol.setPrimary();
-		return symbol;
-	}
-
-	/**
-	 * Creates a namespace hierarchy using the list of strings specified in namespacePath.
-	 */
-	public static Namespace createNamespace(Program program, String... namespacePath)
-			throws DuplicateNameException, InvalidInputException {
-		Namespace parentNamespace = program.getGlobalNamespace();
-		Namespace namespace = null;
-		for (String namespaceName : namespacePath) {
-			namespace = getNamespace(program, parentNamespace, namespaceName);
-			parentNamespace = namespace;
-		}
-		return namespace;
-	}
-
-	public final static String formatAsObjectiveC(Function function,
-			ObjectiveC_MethodType methodType) {
-		return formatAsObjectiveC(function.getSignature(), methodType, false);
-	}
-
-	public final static String formatAsObjectiveC(FunctionSignature signature,
-			ObjectiveC_MethodType methodType, boolean appendSemicolon)
-			throws IllegalStateException {
-		int colonCount = StringUtilities.countOccurrences(signature.getName(), ':');
-
-		StringTokenizer tokenizer = new StringTokenizer(signature.getName(), ":");
-		StringBuffer buffer = new StringBuffer();
-		buffer.append(methodType.getIndicator());
-		buffer.append(' ');
-		buffer.append('(' + signature.getReturnType().getDisplayName() + ')');
-		buffer.append(' ');
-		ParameterDefinition[] arguments = signature.getArguments();
-		int argumentIndex = 2;//skip ID and SEL
-
-		if (arguments.length - 2 != colonCount - 1 && arguments.length - 2 != colonCount) {
-			throw new IllegalStateException("Invalid amount of arguments.");
-		}
-		List<String> tokenList = new ArrayList<String>();
-		while (tokenizer.hasMoreTokens()) {
-			tokenList.add(tokenizer.nextToken());
-		}
-		while (tokenList.size() < colonCount) {
-			tokenList.add("");
-		}
-		for (String token : tokenList) {
-			buffer.append(token);
-			if (argumentIndex < arguments.length) {
-				buffer.append(':');
-				buffer.append('(' + arguments[argumentIndex].getDataType().getDisplayName() + ')');
-				buffer.append("arg" + argumentIndex);
-				++argumentIndex;
-				if (argumentIndex < arguments.length) {
-					buffer.append(' ');
-				}
-			}
-		}
-		if (appendSemicolon) {
-			buffer.append(';');
-		}
-		return buffer.toString();
-	}
-
-	public final static void createMethods(ObjectiveC1_State state) {
-		state.monitor.setMessage("Creating Objective-C Methods...");
-		state.monitor.initialize(state.methodMap.size());
-		int progress = 0;
-
-		Set<Address> addresses = state.methodMap.keySet();
-		for (Address address : addresses) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			state.monitor.setProgress(++progress);
-
-			ObjectiveC1_Utilities.setThumbBit(state, address);
-
-			BackgroundCommand<Program> command = null;
-
-			command = new DisassembleCommand(address, null, true);
-			command.applyTo(state.program, state.monitor);
-
-			command = new CreateFunctionCmd(address);
-			command.applyTo(state.program, state.monitor);
-
-			//command = new FunctionStackAnalysisCmd(address, false);
-			//command.applyTo(state.program, state.monitor);
-
-			ObjectiveC_Method method = state.methodMap.get(address);
-
-			try {
-				state.encodings.processMethodSignature(state.program, address, method.getTypes(),
-					method.getMethodType());
-			}
-			catch (Exception e) {
-				Msg.error(ObjectiveC1_Utilities.class,
-					"Unhandled method signature: " + e.getMessage(), e);
-			}
-		}
-	}
-
-	public final static void createInstanceVariablesC2_OBJC2(ObjectiveC2_State state) {
-		state.monitor.setMessage("Creating Objective-C 2.0 Instance Variables...");
-		state.monitor.initialize(state.variableMap.size());
-		int progress = 0;
-
-		Set<Address> addresses = state.variableMap.keySet();
-		for (Address address : addresses) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			state.monitor.setProgress(++progress);
-
-			ObjectiveC2_InstanceVariable variable = state.variableMap.get(address);
-			try {
-				state.encodings.processInstanceVariableSignature(state.program, address,
-					variable.getType(), variable.getSize());
-			}
-			catch (Exception e) {
-				//System.err.println("Unhandled instance variable signature: "+e.getMessage());//TODO
-			}
-		}
-	}
-
-	/**
-	 * This method will remove references to the NULL address
-	 * and it will adjust THUMB references to no longer be offcut.
-	 */
-	public final static void fixupReferences(ObjectiveC1_State state) {
-		state.monitor.setMessage("Fixing References...");
-
-		AddressSet addressSet = new AddressSet();
-
-		List<String> sectionNames = state.getObjectiveCSectionNames();
-		for (String sectionName : sectionNames) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			MemoryBlock block = state.program.getMemory().getBlock(sectionName);
-			if (block != null) {//not all blocks will exist
-				addressSet.addRange(block.getStart(), block.getEnd());
-			}
-		}
-
-		state.monitor.initialize(addressSet.getNumAddresses());
-		int progress = 0;
-
-		ReferenceManager referenceManager = state.program.getReferenceManager();
-
-		AddressIterator referenceIterator =
-			referenceManager.getReferenceSourceIterator(addressSet, true);
-		while (referenceIterator.hasNext()) {
-			if (state.monitor.isCancelled()) {
-				break;
-			}
-			++progress;
-			if ((progress % 100) == 0) {
-				state.monitor.setProgress(progress);
-			}
-			Address sourceAddress = referenceIterator.next();
-			Reference[] references = referenceManager.getReferencesFrom(sourceAddress);
-			for (Reference reference : references) {
-				if (state.monitor.isCancelled()) {
-					break;
-				}
-				if (ObjectiveC1_Utilities.isNull(reference.getToAddress())) {
-					referenceManager.delete(reference);
-				}
-				if (ObjectiveC1_Utilities.isThumb(state.program, reference.getToAddress())) {
-					referenceManager.delete(reference);
-					referenceManager.addMemoryReference(reference.getFromAddress(),
-						reference.getToAddress().subtract(1), reference.getReferenceType(),
-						reference.getSource(), reference.getOperandIndex());
-				}
-			}
-		}
-	}
-}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java
index 02cfe326b79..5478eb466d0 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java
@@ -40,7 +40,7 @@
 import ghidra.app.util.bin.format.macho.dyld.DyldFixup;
 import ghidra.app.util.bin.format.macho.relocation.*;
 import ghidra.app.util.bin.format.macho.threadcommand.ThreadCommand;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.framework.options.Options;
 import ghidra.program.database.function.OverlappingFunctionException;
@@ -1837,14 +1837,14 @@ protected void setCompiler() throws CancelledException {
 
 	protected void renameObjMsgSendRtpSymbol()
 			throws DuplicateNameException, InvalidInputException {
-		Address address = space.getAddress(ObjectiveC1_Constants.OBJ_MSGSEND_RTP);
+		Address address = space.getAddress(Objc1Constants.OBJ_MSGSEND_RTP);
 		Symbol symbol = program.getSymbolTable().getPrimarySymbol(address);
 		if (symbol != null && symbol.isDynamic()) {
-			symbol.setName(ObjectiveC1_Constants.OBJC_MSG_SEND_RTP_NAME, SourceType.IMPORTED);
+			symbol.setName(Objc1Constants.OBJC_MSG_SEND_RTP_NAME, SourceType.IMPORTED);
 		}
 		else {
 			program.getSymbolTable()
-					.createLabel(address, ObjectiveC1_Constants.OBJC_MSG_SEND_RTP_NAME,
+					.createLabel(address, Objc1Constants.OBJC_MSG_SEND_RTP_NAME,
 						SourceType.IMPORTED);
 		}
 	}
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_DecompilerMessageAnalyzer.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_DecompilerMessageAnalyzer.java
index e421af85703..fc584e74e18 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_DecompilerMessageAnalyzer.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/ObjectiveC2_DecompilerMessageAnalyzer.java
@@ -21,8 +21,8 @@
 import ghidra.app.decompiler.parallel.*;
 import ghidra.app.services.*;
 import ghidra.app.util.bin.format.macho.SectionNames;
-import ghidra.app.util.bin.format.objc2.ObjectiveC2_Constants;
-import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants;
+import ghidra.app.util.bin.format.objc.objc1.Objc1Constants;
+import ghidra.app.util.bin.format.objc.objc2.Objc2Constants;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.address.*;
 import ghidra.program.model.data.DataType;
@@ -86,7 +86,7 @@ public boolean added(Program program, AddressSetView set, TaskMonitor monitor, M
 
 	@Override
 	public boolean canAnalyze(Program program) {
-		return ObjectiveC2_Constants.isObjectiveC2(program);
+		return Objc2Constants.isObjectiveC2(program);
 	}
 
 	/* ************************************************************************** */
@@ -581,7 +581,7 @@ private String getIvarName(Program program, Address address) {
 			Reference reference = references.next();
 			Address fromAddress = reference.getFromAddress();
 			MemoryBlock block = program.getMemory().getBlock(fromAddress);
-			if (!block.getName().equals(ObjectiveC2_Constants.OBJC2_CONST)) {
+			if (!block.getName().equals(Objc2Constants.OBJC2_CONST)) {
 				continue;
 			}
 			Data ivarList = listing.getDataContaining(fromAddress);
@@ -797,12 +797,12 @@ private boolean isObjcNameMatch(Symbol symbol) {
 			return false;
 		}
 		String name = symbol.getName();
-		return name.startsWith(ObjectiveC1_Constants.OBJC_MSG_SEND) ||
-			name.equals(ObjectiveC1_Constants.READ_UNIX2003);
+		return name.startsWith(Objc1Constants.OBJC_MSG_SEND) ||
+			name.equals(Objc1Constants.READ_UNIX2003);
 	}
 
 	private boolean isMessageRefsBlock(MemoryBlock block) {
-		return block.getName().equals(ObjectiveC2_Constants.OBJC2_MESSAGE_REFS);
+		return block.getName().equals(Objc2Constants.OBJC2_MESSAGE_REFS);
 	}
 
 	private boolean isClassNameBlock(MemoryBlock block) {
@@ -861,7 +861,7 @@ private boolean isIvarBlock(MemoryBlock block) {
 
 	private boolean isObjcConstBlock(MemoryBlock block) {
 		if (block != null) {
-			if (block.getName().equals(ObjectiveC2_Constants.OBJC2_CONST)) {
+			if (block.getName().equals(Objc2Constants.OBJC2_CONST)) {
 				return true;
 			}
 		}
```
-----------------------------------
