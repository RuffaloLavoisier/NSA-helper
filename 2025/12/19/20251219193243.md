# Commit: 8805167de3bd41f996c4c7323d2667442fe4d0f1
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
index f21c0f823b3..a392076ad23 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
@@ -2485,8 +2485,9 @@ bool ActionSetCasts::isOpIdentical(Datatype *ct1,Datatype *ct2)
 /// \param op is the given PcodeOp
 /// \param slot is index of the input slot being read
 /// \param data is the containing function
+/// \param castStrategy is used to determine if the cast is still necessary after resolution
 /// \return 1 if a PTRSUB is inserted, 0 otherwise
-int4 ActionSetCasts::resolveUnion(PcodeOp *op,int4 slot,Funcdata &data)
+int4 ActionSetCasts::resolveUnion(PcodeOp *op,int4 slot,Funcdata &data,CastStrategy *castStrategy)
 
 {
   Varnode *vn = op->getIn(slot);
@@ -2498,9 +2499,13 @@ int4 ActionSetCasts::resolveUnion(PcodeOp *op,int4 slot,Funcdata &data)
     dt->resolveInFlow(op, slot);	// Last chance to resolve data-type based on flow
   const ResolvedUnion *resUnion = data.getUnionField(dt, op,slot);
   if (resUnion != (ResolvedUnion*)0 && resUnion->getFieldNum() >= 0) {
-    // Insert specific placeholder indicating which field is accessed
     if (dt->getMetatype() == TYPE_PTR) {
-      PcodeOp *ptrsub = insertPtrsubZero(op,slot,resUnion->getDatatype(),data);
+      // Test if a cast is still needed even after resolution
+      Datatype *reqtype = vn->getTypeReadFacing(op);
+      if (castStrategy->castStandard(reqtype, resUnion->getDatatype(), true, true) != (Datatype *)0)
+	return 0;	// If cast still needed, don't do the resolve
+      // Insert specific placeholder indicating which field is accessed
+      PcodeOp *ptrsub = insertPtrsubZero(op,slot,reqtype,data);
       data.setUnionField(dt, ptrsub,-1,*resUnion);			// Attach the resolution to the PTRSUB
     }
     else if (vn->isImplied()) {
@@ -2751,7 +2756,7 @@ int4 ActionSetCasts::apply(Funcdata &data)
       }
       // Do input casts first, as output may depend on input
       for(int4 i=0;i<op->numInput();++i) {
-	count += resolveUnion(op, i, data);
+	count += resolveUnion(op, i, data, castStrategy);
 	count += castInput(op,i,data,castStrategy);
       }
       if (opc == CPUI_LOAD) {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
index d484facb7ce..d974875d7d7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
@@ -322,7 +322,7 @@ class ActionSetCasts : public Action {
   static bool testStructOffset0(Datatype *reqtype,Datatype *curtype,CastStrategy *castStrategy);
   static bool tryResolutionAdjustment(PcodeOp *op,int4 slot,Funcdata &data);
   static bool isOpIdentical(Datatype *ct1,Datatype *ct2);
-  static int4 resolveUnion(PcodeOp *op,int4 slot,Funcdata &data);
+  static int4 resolveUnion(PcodeOp *op,int4 slot,Funcdata &data,CastStrategy *castStrategy);
   static int4 castOutput(PcodeOp *op,Funcdata &data,CastStrategy *castStrategy);
   static int4 castInput(PcodeOp *op,int4 slot,Funcdata &data,CastStrategy *castStrategy);
   static PcodeOp *insertPtrsubZero(PcodeOp *op,int4 slot,Datatype *ct,Funcdata &data);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/expression.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/expression.cc
index 3298417e5a5..0ac7a61ccf5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/expression.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/expression.cc
@@ -412,7 +412,7 @@ static int4 functionalEqualityLevel0(Varnode *vn1,Varnode *vn2)
     }
     return -1;
   }
-  if (vn2->isConstant()) return -1;
+  if (vn1->isFree() || vn2->isFree()) return -1;
   return 1;
 }
 
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java b/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java
index 8bd49701794..b35d0b67f9b 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java
@@ -25,7 +25,7 @@
 import ghidra.util.Msg;
 
 /**
- * <code>ApplicationSSLSocketFactory</code> provides a replacement for the default
+ * <code>DefaultSSLSocketFactory</code> provides a replacement for the default
  * <code>SSLSocketFactory</code> which utilizes the default SSLContext established
  * by {@link DefaultSSLContextInitializer}.
  */
@@ -34,7 +34,7 @@ public class DefaultSSLSocketFactory extends SSLSocketFactory {
 	private final SSLSocketFactory socketFactory;
 
 	/**
-	 * ApplicationSSLSocketFactory constructor.  
+	 * <code>DefaultSSLSocketFactory</code> constructor.  
 	 * SSLContext initialization will be performed using {@link DefaultSSLContextInitializer}.
 	 */
 	public DefaultSSLSocketFactory() {
```
-----------------------------------
