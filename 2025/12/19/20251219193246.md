# Commit: f72ca84cd031ead2773a4842e29fbeea16a1f31d
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimControlLaunchable.java b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimControlLaunchable.java
index d6d70a5b653..ff315bf4541 100644
--- a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimControlLaunchable.java
+++ b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimControlLaunchable.java
@@ -608,7 +608,7 @@ private void generateSelfSignedCertificate(File certFile, File passFile)
 	private Connection createLocalConnection() throws SQLException, IOException {
 		Properties properties = new Properties();
 		properties.setProperty("sslmode", "require");
-		properties.setProperty("sslfactory", "ghidra.net.ApplicationSSLSocketFactory");
+		properties.setProperty("sslfactory", "ghidra.net.DefaultSSLSocketFactory");
 		properties.setProperty("user", connectingUserName);
 		StringBuilder buffer = new StringBuilder();
 		buffer.append("jdbc:postgresql://localhost");
@@ -687,6 +687,7 @@ private void enableLSHExtension() throws SQLException, IOException {
 	 */
 	private int runCommand(File directory, List<String> command, String envvar, String value)
 			throws IOException, InterruptedException {
+		System.out.println("Command: " + command);
 		ProcessBuilder processBuilder = new ProcessBuilder(command);
 		processBuilder.directory(directory);		// Set the working directory
 		if (envvar != null) {
diff --git a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimPostgresDBConnectionManager.java b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimPostgresDBConnectionManager.java
index f36aa3f756d..c0f75aeb9a3 100644
--- a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimPostgresDBConnectionManager.java
+++ b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/BSimPostgresDBConnectionManager.java
@@ -217,7 +217,7 @@ private void setDefaultProperties() {
 
 		private void setSSLProperties() {
 			bds.addConnectionProperty("sslmode", "require");
-			bds.addConnectionProperty("sslfactory", "ghidra.net.ApplicationSSLSocketFactory");
+			bds.addConnectionProperty("sslfactory", "ghidra.net.DefaultSSLSocketFactory");
 		}
 
 		@Override
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
index ba1a3b22c4a..4a6b0090a64 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -316,7 +316,7 @@ void SleighBuilder::buildEmpty(Constructor *ct,int4 secnum)
 void SleighBuilder::setUniqueOffset(const Address &addr)
 
 {
-  uniqueoffset = (addr.getOffset() & uniquemask)<<4;
+  uniqueoffset = (addr.getOffset() & uniquemask)<<8;
 }
 
 /// \brief Constructor
@@ -337,7 +337,7 @@ SleighBuilder::SleighBuilder(ParserWalker *w,DisassemblyCache *dcache,PcodeCache
   const_space = cspc;
   uniq_space = uspc;
   uniquemask = umask;
-  uniqueoffset = (walker->getAddr().getOffset() & uniquemask)<<4;
+  uniqueoffset = (walker->getAddr().getOffset() & uniquemask)<<8;
 }
 
 void SleighBuilder::appendBuild(OpTpl *bld,int4 secnum)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index d8de0d5fed5..d5ca7302c04 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -3548,73 +3548,77 @@ bool SleighCompile::forceExportSize(ConstructTpl *ct)
   return true;
 }
 
-/// \brief If the given Varnode is in the \e unique space, shift its offset up by \b sa bits
+/// \brief Insert a region of zero bits into an address offset
+///
+/// \param addr is the address offset
+/// \return the modified offset
+uintb SleighCompile::insertCrossBuildRegion(uintb addr)
+
+{
+  uintb upperbits = (addr >> UNIQUE_CROSSBUILD_POSITION) << (UNIQUE_CROSSBUILD_POSITION + UNIQUE_CROSSBUILD_NUMBITS);
+  uintb lowerbits = (addr << (8*sizeof(uintb) - UNIQUE_CROSSBUILD_POSITION)) >> (8*sizeof(uintb) - UNIQUE_CROSSBUILD_POSITION);
+  return upperbits | lowerbits;
+}
+
+/// \brief If the given Varnode is in the \e unique space, insert a region of zero bits
 ///
 /// \param vn is the given Varnode
-/// \param sa is the number of bits to shift by
-void SleighCompile::shiftUniqueVn(VarnodeTpl *vn,int4 sa)
+void SleighCompile::shiftUniqueVn(VarnodeTpl *vn)
 
 {
   if (vn->getSpace().isUniqueSpace() && (vn->getOffset().getType() == ConstTpl::real)) {
-    uintb val = vn->getOffset().getReal();
-    val <<= sa;
+    uintb val = insertCrossBuildRegion(vn->getOffset().getReal());
     vn->setOffset(val);
   }
 }
 
-/// \brief Shift the offset up by \b sa bits for any Varnode used by the given op in the \e unique space
+/// \brief Insert a region of zero bits for any Varnode used by the given op in the \e unique space
 ///
 /// \param op is the given op
-/// \param sa is the number of bits to shift by
-void SleighCompile::shiftUniqueOp(OpTpl *op,int4 sa)
+void SleighCompile::shiftUniqueOp(OpTpl *op)
 
 {
   VarnodeTpl *outvn = op->getOut();
   if (outvn != (VarnodeTpl *)0)
-    shiftUniqueVn(outvn,sa);
+    shiftUniqueVn(outvn);
   for(int4 i=0;i<op->numInput();++i)
-    shiftUniqueVn(op->getIn(i),sa);
+    shiftUniqueVn(op->getIn(i));
 }
 
-/// \brief Shift the offset up for both \e dynamic or \e static Varnode aspects in the \e unique space
+/// \brief Insert a region of zero bits for both \e dynamic or \e static Varnode aspects in the \e unique space
 ///
 /// \param hand is a handle template whose aspects should be modified
-/// \param sa is the number of bits to shift by
-void SleighCompile::shiftUniqueHandle(HandleTpl *hand,int4 sa)
+void SleighCompile::shiftUniqueHandle(HandleTpl *hand)
 
 {
   if (hand->getSpace().isUniqueSpace() && (hand->getPtrSpace().getType() == ConstTpl::real)
       && (hand->getPtrOffset().getType() == ConstTpl::real)) {
-    uintb val = hand->getPtrOffset().getReal();
-    val <<= sa;
+    uintb val = insertCrossBuildRegion(hand->getPtrOffset().getReal());
     hand->setPtrOffset(val);
   }
   else if (hand->getPtrSpace().isUniqueSpace() && (hand->getPtrOffset().getType() == ConstTpl::real)) {
-    uintb val = hand->getPtrOffset().getReal();
-    val <<= sa;
+    uintb val = insertCrossBuildRegion(hand->getPtrOffset().getReal());
     hand->setPtrOffset(val);
   }
   
   if (hand->getTempSpace().isUniqueSpace() && (hand->getTempOffset().getType() == ConstTpl::real)) {
-    uintb val = hand->getTempOffset().getReal();
-    val <<= sa;
+    uintb val = insertCrossBuildRegion(hand->getTempOffset().getReal());
     hand->setTempOffset(val);
   }
 }
 
-/// \brief Shift the offset up for any Varnode in the \e unique space for all p-code in the given section
+/// \brief Insert a region of zero bits for any Varnode in the \e unique space for all p-code in the given section
 ///
 /// \param tpl is the given p-code section
-/// \param sa is the number of bits to shift by
-void SleighCompile::shiftUniqueConstruct(ConstructTpl *tpl,int4 sa)
+void SleighCompile::shiftUniqueConstruct(ConstructTpl *tpl)
 
 {
   HandleTpl *result = tpl->getResult();
   if (result != (HandleTpl *)0)
-    shiftUniqueHandle(result,sa);
+    shiftUniqueHandle(result);
   const vector<OpTpl *> &vec( tpl->getOpvec() );
   for(int4 i=0;i<vec.size();++i)
-    shiftUniqueOp(vec[i],sa);
+    shiftUniqueOp(vec[i]);
 }
 
 /// With \b crossbuilds, temporaries may need to survive across instructions in a packet, so here we
@@ -3626,7 +3630,6 @@ void SleighCompile::checkUniqueAllocation(void)
   if (unique_allocatemask == 0) return;	// We don't have any crossbuild directives
 
   unique_allocatemask = 0xff;	// Provide 8 bits of free space
-  int4 sa = 8;
   int4 secsize = sections.size(); // This is the upper bound for section numbers
   SubtableSymbol *sym = root; // Start with the instruction table
   int4 i = -1;
@@ -3636,11 +3639,11 @@ void SleighCompile::checkUniqueAllocation(void)
       Constructor *ct = sym->getConstructor(j);
       ConstructTpl *tpl = ct->getTempl();
       if (tpl != (ConstructTpl *)0)
-	shiftUniqueConstruct(tpl,sa);
+	shiftUniqueConstruct(tpl);
       for(int4 k=0;k<secsize;++k) {
 	ConstructTpl *namedtpl = ct->getNamedTempl(k);
 	if (namedtpl != (ConstructTpl *)0)
-	  shiftUniqueConstruct(namedtpl,sa);
+	  shiftUniqueConstruct(namedtpl);
       }
     }
     i+=1;
@@ -3648,7 +3651,8 @@ void SleighCompile::checkUniqueAllocation(void)
     sym = tables[i];
   }
   uint4 ubase = getUniqueBase(); // We have to adjust the unique base
-  ubase <<= sa;
+  ubase += 1 << UNIQUE_CROSSBUILD_POSITION;
+  ubase <<= UNIQUE_CROSSBUILD_NUMBITS;
   setUniqueBase(ubase);
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
index 83e757083e4..4f55bea0b80 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
@@ -301,6 +301,8 @@ public:
 /// various set*() methods prior to calling run_compilation.
 class SleighCompile : public SleighBase {
   friend class SleighPcode;
+  static const int4 UNIQUE_CROSSBUILD_POSITION = 8;
+  static const int4 UNIQUE_CROSSBUILD_NUMBITS = 8;
 public:
   SleighPcode pcode;			///< The p-code parsing (sub)engine
 private:
@@ -351,10 +353,11 @@ private:
   bool finalizeSections(Constructor *big,SectionVector *vec);	///< Do final checks, expansions, and linking for p-code sections
   static VarnodeTpl *findSize(const ConstTpl &offset,const ConstructTpl *ct);
   static bool forceExportSize(ConstructTpl *ct);
-  static void shiftUniqueVn(VarnodeTpl *vn,int4 sa);
-  static void shiftUniqueOp(OpTpl *op,int4 sa);
-  static void shiftUniqueHandle(HandleTpl *hand,int4 sa);
-  static void shiftUniqueConstruct(ConstructTpl *tpl,int4 sa);
+  static uintb insertCrossBuildRegion(uintb addr);
+  static void shiftUniqueVn(VarnodeTpl *vn);
+  static void shiftUniqueOp(OpTpl *op);
+  static void shiftUniqueHandle(HandleTpl *hand);
+  static void shiftUniqueConstruct(ConstructTpl *tpl);
   static string formatStatusMessage(const Location* loc, const string &msg);
   void checkUniqueAllocation(void);	///< Modify temporary Varnode offsets to support \b crossbuilds
   void process(void);			///< Do all post processing on the parsed data structures
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java b/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java
new file mode 100644
index 00000000000..8bd49701794
--- /dev/null
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/net/DefaultSSLSocketFactory.java
@@ -0,0 +1,92 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.net;
+
+import java.io.IOException;
+import java.net.*;
+import java.security.NoSuchAlgorithmException;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+
+import ghidra.util.Msg;
+
+/**
+ * <code>ApplicationSSLSocketFactory</code> provides a replacement for the default
+ * <code>SSLSocketFactory</code> which utilizes the default SSLContext established
+ * by {@link DefaultSSLContextInitializer}.
+ */
+public class DefaultSSLSocketFactory extends SSLSocketFactory {
+
+	private final SSLSocketFactory socketFactory;
+
+	/**
+	 * ApplicationSSLSocketFactory constructor.  
+	 * SSLContext initialization will be performed using {@link DefaultSSLContextInitializer}.
+	 */
+	public DefaultSSLSocketFactory() {
+		SSLSocketFactory factory = null;
+		try {
+			if (DefaultSSLContextInitializer.initialize()) {
+				factory = SSLContext.getDefault().getSocketFactory();
+			}
+		}
+		catch (NoSuchAlgorithmException e) {
+			Msg.error(this, "Failed to employ default SSLContext: " + e.toString(), e);
+		}
+		this.socketFactory =
+			factory != null ? factory : (SSLSocketFactory) SSLSocketFactory.getDefault();
+	}
+
+	@Override
+	public Socket createSocket(Socket s, String host, int port, boolean autoClose)
+			throws IOException {
+		return socketFactory.createSocket(s, host, port, autoClose);
+	}
+
+	@Override
+	public String[] getDefaultCipherSuites() {
+		return socketFactory.getDefaultCipherSuites();
+	}
+
+	@Override
+	public String[] getSupportedCipherSuites() {
+		return socketFactory.getSupportedCipherSuites();
+	}
+
+	@Override
+	public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+		return socketFactory.createSocket(host, port);
+	}
+
+	@Override
+	public Socket createSocket(InetAddress host, int port) throws IOException {
+		return socketFactory.createSocket(host, port);
+	}
+
+	@Override
+	public Socket createSocket(String host, int port, InetAddress localHost, int localPort)
+			throws IOException, UnknownHostException {
+		return socketFactory.createSocket(host, port, localHost, localPort);
+	}
+
+	@Override
+	public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+			int localPort)
+			throws IOException {
+		return socketFactory.createSocket(address, port, localAddress, localPort);
+	}
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java
index dd1220a6ac4..76dd7f3b032 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -88,7 +88,7 @@ public PcodeEmit(ParserWalker walk, InstructionContext ictx, int fallOffset,
 			addressFactory = language.getAddressFactory();
 			uniq_space = addressFactory.getUniqueSpace();
 			uniquemask = language.getUniqueAllocationMask();
-			uniqueoffset = (startAddress.getOffset() & uniquemask) << 4;
+			uniqueoffset = (startAddress.getOffset() & uniquemask) << 8;
 		}
 		else {		// This can happen for CallFixup snippets, but these don't need their temporary vars patched up
 			language = null;
@@ -120,7 +120,7 @@ public PcodeEmit(ParserWalker walk, InstructionContext ictx, int fallOffset,
 	}
 
 	private void setUniqueOffset(Address addr) {
-		uniqueoffset = (addr.getOffset() & uniquemask) << 4;
+		uniqueoffset = (addr.getOffset() & uniquemask) << 8;
 	}
 
 	public Address getStartAddress() {
@@ -504,7 +504,7 @@ private void dump(OpTpl opt) throws IOException {
 		VarnodeData[] dyncache = null;
 		VarnodeTpl vn, outvn;
 		int isize = opt.getInput().length;
-		
+
 		if (isize > incache.length) {
 			incache = new VarnodeData[isize];
 		}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
index a953e401fff..332f70e6ca8 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -53,6 +53,9 @@ public class SleighCompile extends SleighBase {
 
 	static boolean yydebug = false;
 
+	private static int UNIQUE_CROSSBUILD_POSITION = 8;	// Starting bit with a unique address for crossbuild collision region
+	private static int UNIQUE_CROSSBUILD_NUMBITS = 8;	// Number of bits within a unique address for crossbuild collision region
+
 	private static boolean isLocationIsh(Object o) {
 		if (o instanceof Location) {
 			return true;
@@ -1589,64 +1592,74 @@ else if (!forceExportSize(cur.section)) {
 		return true;
 	}
 
-	private static void shiftUniqueVn(VarnodeTpl vn, int sa) {
-		entry("shiftUniqueVn", vn, sa);
+	/**
+	 * Insert a region of zero bits into an address offset
+	 * @param addr is the address offset
+	 * @return the modified offset
+	 */
+	private static long insertCrossBuildRegion(long addr) {
+		long upperbits = (addr >> UNIQUE_CROSSBUILD_POSITION) << (UNIQUE_CROSSBUILD_POSITION +
+			UNIQUE_CROSSBUILD_NUMBITS);
+		long lowerbits =
+			(addr << (64 - UNIQUE_CROSSBUILD_POSITION)) >>> (64 - UNIQUE_CROSSBUILD_POSITION);
+		return upperbits | lowerbits;
+	}
+
+	private static void shiftUniqueVn(VarnodeTpl vn) {
+		entry("shiftUniqueVn", vn);
 		// If the varnode is in the unique space, shift its offset up by -sa- bits
 		if (vn.getSpace().isUniqueSpace() &&
 			(vn.getOffset().getType() == ConstTpl.const_type.real)) {
-			long val = vn.getOffset().getReal();
-			val <<= sa;
+			long val = insertCrossBuildRegion(vn.getOffset().getReal());
+
 			vn.setOffset(val);
 		}
 	}
 
-	private static void shiftUniqueOp(OpTpl op, int sa) {
-		entry("shiftUniqueOp", op, sa);
+	private static void shiftUniqueOp(OpTpl op) {
+		entry("shiftUniqueOp", op);
 		// Shift the offset up by -sa- bits for any varnode used by this -op- in the unique space
 		VarnodeTpl outvn = op.getOut();
 		if (outvn != null) {
-			shiftUniqueVn(outvn, sa);
+			shiftUniqueVn(outvn);
 		}
 		for (int i = 0; i < op.numInput(); ++i) {
-			shiftUniqueVn(op.getIn(i), sa);
+			shiftUniqueVn(op.getIn(i));
 		}
 	}
 
-	private static void shiftUniqueHandle(HandleTpl hand, int sa) {
-		entry("shiftUniqueHandle", hand, sa);
+	private static void shiftUniqueHandle(HandleTpl hand) {
+		entry("shiftUniqueHandle", hand);
 		// Shift the offset up by -sa- bits, for either the dynamic or static varnode aspects that are in the unique space
 		if (hand.getSpace().isUniqueSpace() &&
 			(hand.getPtrSpace().getType() == ConstTpl.const_type.real) &&
 			(hand.getPtrOffset().getType() == ConstTpl.const_type.real)) {
-			long val = hand.getPtrOffset().getReal();
-			val <<= sa;
+			long val = insertCrossBuildRegion(hand.getPtrOffset().getReal());
 			hand.setPtrOffset(val);
 		}
 		else if (hand.getPtrSpace().isUniqueSpace() &&
 			(hand.getPtrOffset().getType() == ConstTpl.const_type.real)) {
-			long val = hand.getPtrOffset().getReal();
-			val <<= sa;
+			long val = insertCrossBuildRegion(hand.getPtrOffset().getReal());
 			hand.setPtrOffset(val);
 		}
 
 		if (hand.getTempSpace().isUniqueSpace() &&
 			(hand.getTempOffset().getType() == ConstTpl.const_type.real)) {
-			long val = hand.getTempOffset().getReal();
-			val <<= sa;
+			long val = insertCrossBuildRegion(hand.getTempOffset().getReal());
 			hand.setTempOffset(val);
 		}
 	}
 
-	private static void shiftUniqueConstruct(ConstructTpl tpl, int sa) {
-		entry("shiftUniqueConstruct", tpl, sa);
+	private static void shiftUniqueConstruct(ConstructTpl tpl) {
+		entry("shiftUniqueConstruct", tpl);
 		// Shift the offset up by -sa- bits, for any varnode in the unique space associated with this template
 		HandleTpl result = tpl.getResult();
 		if (result != null) {
-			shiftUniqueHandle(result, sa);
+			shiftUniqueHandle(result);
 		}
 		VectorSTL<OpTpl> vec = tpl.getOpvec();
 		for (int i = 0; i < vec.size(); ++i) {
-			shiftUniqueOp(vec.get(i), sa);
+			shiftUniqueOp(vec.get(i));
 		}
 	}
 
@@ -1659,7 +1672,6 @@ private void checkUniqueAllocation() {
 		}
 
 		unique_allocatemask = 0xff;	// Provide 8 bits of free space
-		int sa = 8;
 		int secsize = sections.size(); // This is the upper bound for section numbers
 		SubtableSymbol sym = root; // Start with the instruction table
 		int i = -1;
@@ -1669,12 +1681,12 @@ private void checkUniqueAllocation() {
 				Constructor ct = sym.getConstructor(j);
 				ConstructTpl tpl = ct.getTempl();
 				if (tpl != null) {
-					shiftUniqueConstruct(tpl, sa);
+					shiftUniqueConstruct(tpl);
 				}
 				for (int k = 0; k < secsize; ++k) {
 					ConstructTpl namedtpl = ct.getNamedTempl(k);
 					if (namedtpl != null) {
-						shiftUniqueConstruct(namedtpl, sa);
+						shiftUniqueConstruct(namedtpl);
 					}
 				}
 			}
@@ -1685,7 +1697,8 @@ private void checkUniqueAllocation() {
 			sym = tables.get(i);
 		}
 		long ubase = getUniqueBase(); // We have to adjust the unique base
-		ubase <<= sa;
+		ubase += 1 << UNIQUE_CROSSBUILD_POSITION;
+		ubase <<= UNIQUE_CROSSBUILD_NUMBITS;
 		setUniqueBase(ubase);
 	}
 
```
-----------------------------------
