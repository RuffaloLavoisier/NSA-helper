# Commit: 9a8e95e1938dd7c6faa724995de46f91f0961b48
## Message: Merge remote-tracking branch 'origin/GP-6229_ghidra1_OpBehaviorOtherInputs--SQUASHED' into patch
## Diff:
```
diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/EmulateInstructionStateModifier.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/EmulateInstructionStateModifier.java
index 18dd3f470f4..e875d23b9fd 100644
--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/EmulateInstructionStateModifier.java
+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/EmulateInstructionStateModifier.java
@@ -80,7 +80,12 @@ public final boolean executeCallOther(PcodeOp op) throws LowlevelError {
 		if (opBehaviorOther == null) {
 			return false;
 		}
-		opBehaviorOther.evaluate(emu, op.getOutput(), inputs);
+
+		// Strip-off first input before passing inputs to OpBehaviorOther
+		Varnode[] callOtherInputs = new Varnode[inputs.length - 1];
+		System.arraycopy(inputs, 1, callOtherInputs, 0, callOtherInputs.length);
+
+		opBehaviorOther.evaluate(emu, op.getOutput(), callOtherInputs);
 		return true;
 	}
 
diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/callother/OpBehaviorOther.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/callother/OpBehaviorOther.java
index c2cbde1d5d4..2bf45f65b2a 100644
--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/callother/OpBehaviorOther.java
+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emulate/callother/OpBehaviorOther.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,6 +16,7 @@
 package ghidra.pcode.emulate.callother;
 
 import ghidra.pcode.emulate.Emulate;
+import ghidra.program.model.pcode.PcodeOp;
 import ghidra.program.model.pcode.Varnode;
 
 public interface OpBehaviorOther {
@@ -28,10 +28,10 @@ public interface OpBehaviorOther {
 	 * made.  Implementation is responsible for updating memory 
 	 * state appropriately.
 	 * @param inputs input varnodes passed as parameters to this
-	 * pcodeop.  The inputs[0] value corresponds to the index value of this 
-	 * pcodeop and can generally be ignored.  The inputs[1] value
-	 * corresponds to the first (leftmost) parameter passed to 
-	 * this pcodeop within the language implementation.
+	 * pcodeop.  The original {@link PcodeOp#CALLOTHER} first input 
+	 * has been stripped (i.e., CALLOTHER index value), leaving only 
+	 * the inputs that were were specified as arguments to the named
+	 * pcodeop within the language spec. 
 	 */
 	public void evaluate(Emulate emu, Varnode out, Varnode[] inputs);
 }
diff --git a/Ghidra/Processors/68000/src/main/java/ghidra/program/emulation/m68kEmulateInstructionStateModifier.java b/Ghidra/Processors/68000/src/main/java/ghidra/program/emulation/m68kEmulateInstructionStateModifier.java
index d5c516154de..7732b5bb4be 100644
--- a/Ghidra/Processors/68000/src/main/java/ghidra/program/emulation/m68kEmulateInstructionStateModifier.java
+++ b/Ghidra/Processors/68000/src/main/java/ghidra/program/emulation/m68kEmulateInstructionStateModifier.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -116,12 +116,12 @@ public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
 				throw new LowlevelError("CALLOTHER: Find First One op missing required output");
 			}
 
-			if (inputs.length != 2 || inputs[1].getSize() == 0 || !inputs[1].isRegister()) {
+			if (inputs.length != 1 || inputs[0].getSize() == 0 || !inputs[0].isRegister()) {
 				throw new LowlevelError(
 					"CALLOTHER: Find First One op requires one register varnode input");
 			}
 
-			Varnode in = inputs[1];
+			Varnode in = inputs[0];
 			MemoryState memoryState = emu.getMemoryState();
 
 			long value = memoryState.getValue(in);
diff --git a/Ghidra/Processors/AARCH64/src/main/java/ghidra/program/emulation/AARCH64EmulateInstructionStateModifier.java b/Ghidra/Processors/AARCH64/src/main/java/ghidra/program/emulation/AARCH64EmulateInstructionStateModifier.java
index 783502fdd16..af6a59e8f27 100644
--- a/Ghidra/Processors/AARCH64/src/main/java/ghidra/program/emulation/AARCH64EmulateInstructionStateModifier.java
+++ b/Ghidra/Processors/AARCH64/src/main/java/ghidra/program/emulation/AARCH64EmulateInstructionStateModifier.java
@@ -265,7 +265,7 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 1 input
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError(this.getClass().getName() + ": requires 2 inputs (op, size), got " + numArgs);
 			}
@@ -278,8 +278,8 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the simd variable to output, the value to copy, and the offset
 
-			Varnode simdVarnode = inputs[1];
-			int esize = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int esize = (int) memoryState.getValue(inputs[1]);
 
 			if (outputVarnode.getSize() < simdVarnode.getSize()) {
 				throw new LowlevelError(this.getClass().getName() + ": input size (" + simdVarnode.getSize()
@@ -309,8 +309,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			int esize = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int esize = (int) memoryState.getValue(inputs[1]);
 
 			byte[] simdBytes = memoryState.getBigInteger(simdVarnode, true).toByteArray();
 			byte[] outBytes = varnode_to_bytes(outputVarnode, null, esize);
@@ -345,8 +345,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			int esize = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int esize = (int) memoryState.getValue(inputs[1]);
 
 			byte[] simdBytes = memoryState.getBigInteger(simdVarnode, false).toByteArray();
 			byte[] outBytes = varnode_to_bytes(outputVarnode, null, esize);
@@ -405,7 +405,7 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 2 input
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) throw new LowlevelError(this.getClass().getName() + ": requires 2 inputs (op, size), got " + numArgs);
 
 			if (outputVarnode == null) throw new LowlevelError(this.getClass().getName() + ": missing required output");
@@ -414,8 +414,8 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the simd variable to output, the value to copy, and the offset
 
-			Varnode simdVarnode = inputs[1];
-			int s_size = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int s_size = (int) memoryState.getValue(inputs[1]);
 
 			if (outputVarnode.getSize() != 2 * simdVarnode.getSize())
 				throw new LowlevelError(this.getClass().getName() + ": input size (" + simdVarnode.getSize()
@@ -449,8 +449,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			int s_size = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int s_size = (int) memoryState.getValue(inputs[1]);
 			int d_size = (s_size * outputVarnode.getSize()) / simdVarnode.getSize();
 
 			byte[] simdBytes = memoryState.getBigInteger(simdVarnode, true).toByteArray();
@@ -486,8 +486,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			int s_size = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int s_size = (int) memoryState.getValue(inputs[1]);
 			int d_size = (s_size * outputVarnode.getSize()) / simdVarnode.getSize();
 
 			byte[] simdBytes = memoryState.getBigInteger(simdVarnode, false).toByteArray();
@@ -532,7 +532,7 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 2 or 3 inputs
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2 && numArgs != 3) {
 				throw new LowlevelError(this.getClass().getName() + ": requires 3 inputs (simd, op, esize), got " + numArgs);
 			}
@@ -545,13 +545,13 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the simd variable to output, the value to copy, and the offset
 
-			Varnode simdVarnode = inputs[1];
-			Varnode opVarnode = inputs[2];
+			Varnode simdVarnode = inputs[0];
+			Varnode opVarnode = inputs[1];
 
 			int esize = opVarnode.getSize();
 			boolean opConstant = (numArgs == 2);
 			if (! opConstant) {
-				esize = (int) memoryState.getValue(inputs[3]);
+				esize = (int) memoryState.getValue(inputs[2]);
 			}
 
 			if (outputVarnode.getSize() < simdVarnode.getSize()) {
@@ -587,12 +587,12 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			Varnode opVarnode = inputs[2];
-			boolean opConstant = (inputs.length == 3);
+			Varnode simdVarnode = inputs[0];
+			Varnode opVarnode = inputs[1];
+			boolean opConstant = (inputs.length == 2);
 			int esize = opVarnode.getSize();
 			if (! opConstant) {
-				esize = (int) memoryState.getValue(inputs[3]);
+				esize = (int) memoryState.getValue(inputs[2]);
 			}
 			int opstep = (opConstant ? 0 : esize);
 
@@ -631,12 +631,12 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			Varnode simdVarnode = inputs[1];
-			Varnode opVarnode = inputs[2];
-			boolean opConstant = (inputs.length == 3);
+			Varnode simdVarnode = inputs[0];
+			Varnode opVarnode = inputs[1];
+			boolean opConstant = (inputs.length == 2);
 			int esize = opVarnode.getSize();
 			if (! opConstant) {
-				esize = (int) memoryState.getValue(inputs[3]);
+				esize = (int) memoryState.getValue(inputs[2]);
 			}
 			int opstep = (opConstant ? 0 : esize);
 
@@ -682,7 +682,7 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 2 inputs
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2 && numArgs != 3) {
 				throw new LowlevelError(this.getClass().getName() + ": requires 2 or 3 inputs (pairData*, esize), got " + numArgs);
 			}
@@ -695,15 +695,16 @@ void check_args(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the paired variables and the offset
 
-			Varnode p1Varnode = inputs[1];
+			Varnode p1Varnode = inputs[0];
 			int isize = p1Varnode.getSize();
 			Varnode p2Varnode = null;
 			if (numArgs == 3) {
-				p2Varnode = inputs[2];
+				p2Varnode = inputs[1];
 				isize += p2Varnode.getSize();
 			}
 
-			int iesize = (int) memoryState.getValue(inputs[numArgs]);
+			// TODO: The 3-input case seems suspect and should be documented
+			int iesize = (int) memoryState.getValue(inputs[numArgs - 1]);
 			int osize = outputVarnode.getSize();
 			int oesize = (iesize * osize) / isize;
 
@@ -729,16 +730,16 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			int numArgs = inputs.length - 1;
-			Varnode p1Varnode = inputs[1];
+			int numArgs = inputs.length;
+			Varnode p1Varnode = inputs[0];
 			int isize = p1Varnode.getSize();
 			Varnode p2Varnode = null;
 			if (numArgs == 3) {
-				p2Varnode = inputs[2];
+				p2Varnode = inputs[1];
 				isize += p2Varnode.getSize();
 			}
 
-			int iesize = (int) memoryState.getValue(inputs[numArgs]);
+			int iesize = (int) memoryState.getValue(inputs[numArgs - 1]);
 			int osize = outputVarnode.getSize();
 			int oesize = (iesize * osize) / isize;
 
@@ -798,16 +799,16 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			MemoryState memoryState = emu.getMemoryState();
 
-			int numArgs = inputs.length - 1;
-			Varnode p1Varnode = inputs[1];
+			int numArgs = inputs.length;
+			Varnode p1Varnode = inputs[0];
 			int isize = p1Varnode.getSize();
 			Varnode p2Varnode = null;
 			if (numArgs == 3) {
-				p2Varnode = inputs[2];
+				p2Varnode = inputs[1];
 				isize += p2Varnode.getSize();
 			}
 
-			int iesize = (int) memoryState.getValue(inputs[numArgs]);
+			int iesize = (int) memoryState.getValue(inputs[numArgs - 1]);
 			int osize = outputVarnode.getSize();
 			int oesize = (iesize * osize) / isize;
 
@@ -875,7 +876,7 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 2 inputs
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2 && numArgs != 3) throw new LowlevelError("SIMD_COPY: requires 2 or 3 inputs, got " + numArgs);
 
 			if (outputVarnode == null) throw new LowlevelError("SIMD_COPY: missing required output");
@@ -884,10 +885,11 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the init variable to output, the value to copy, and the offset
 
-			Varnode initVarnode = inputs[1];
-			Varnode valueVarnode = inputs[2];
+			Varnode initVarnode = inputs[0];
+			Varnode valueVarnode = inputs[1];
 			int offset = -1;
-			if (numArgs == 3) offset = (int) memoryState.getValue(inputs[3]);
+			if (numArgs == 3)
+				offset = (int) memoryState.getValue(inputs[2]);
 
 			if (outputVarnode.getSize() < initVarnode.getSize())
 				throw new LowlevelError("SIMD_COPY: output size (" + outputVarnode.getSize()
@@ -956,7 +958,7 @@ private class MP_INT_EQUAL implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("MP_INT_EQUAL: requires 2 (Vm, Vn), got " + numArgs);
 			}
@@ -966,8 +968,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			BigInteger cmp1 = memoryState.getBigInteger(inputs[1], false);
-			BigInteger cmp2 = memoryState.getBigInteger(inputs[2], false);
+			BigInteger cmp1 = memoryState.getBigInteger(inputs[0], false);
+			BigInteger cmp2 = memoryState.getBigInteger(inputs[1], false);
 
 			BigInteger result = (cmp1.compareTo(cmp2) == 0) ? BigInteger.ONE : BigInteger.ZERO;
 
@@ -997,7 +999,7 @@ private class MP_INT_ABS implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 1) {
 				throw new LowlevelError("MP_INT_ABS: requires 1 (Vn), got " + numArgs);
 			}
@@ -1007,7 +1009,7 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			BigInteger op = memoryState.getBigInteger(inputs[1], true);
+			BigInteger op = memoryState.getBigInteger(inputs[0], true);
 
 			BigInteger result = op.abs();
 			// System.out.print(String.format("MP_INT_ABS %s to %s (%x)\n", op.toString(), result.toString(), result.longValue()));
@@ -1055,7 +1057,7 @@ private class MP_INT_NEGATE implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 1) {
 				throw new LowlevelError("MP_INT_NEGATE: requires 1 (Vn), got " + numArgs);
 			}
@@ -1065,7 +1067,7 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			byte[] value = memoryState.getBigInteger(inputs[1], true).toByteArray();
+			byte[] value = memoryState.getBigInteger(inputs[0], true).toByteArray();
 
 			// Need to perform bitwise negation manually
 			// to get the right size
@@ -1102,7 +1104,7 @@ private class MP_INT_AND implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("MP_INT_AND: requires 2 (Vm, Vn), got " + numArgs);
 			}
@@ -1112,8 +1114,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			BigInteger value = memoryState.getBigInteger(inputs[1], false);
-			BigInteger mask = memoryState.getBigInteger(inputs[2], false);
+			BigInteger value = memoryState.getBigInteger(inputs[0], false);
+			BigInteger mask = memoryState.getBigInteger(inputs[1], false);
 
 			BigInteger result = value.and(mask);
 
@@ -1158,7 +1160,7 @@ private class MP_INT_RIGHT implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("MP_INT_RIGHT: requires 2 (Vn, shift), got " + numArgs);
 			}
@@ -1171,8 +1173,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// By extracting an unsigned value, the right shift is logical and not sign extended
 
-			BigInteger value = memoryState.getBigInteger(inputs[1], false);
-			int shift = (int) memoryState.getValue(inputs[2]);
+			BigInteger value = memoryState.getBigInteger(inputs[0], false);
+			int shift = (int) memoryState.getValue(inputs[1]);
 
 			BigInteger result = value.shiftRight(shift);
 
@@ -1201,7 +1203,7 @@ private class MP_INT_MULT implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("MP_INT_MULT: requires 2 (Vm, Vn), got " + numArgs);
 			}
@@ -1211,8 +1213,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			BigInteger value = memoryState.getBigInteger(inputs[1], true);
-			BigInteger mult = memoryState.getBigInteger(inputs[2], true);
+			BigInteger value = memoryState.getBigInteger(inputs[0], true);
+			BigInteger mult = memoryState.getBigInteger(inputs[1], true);
 
 			BigInteger result = value.multiply(mult);
 
@@ -1231,7 +1233,7 @@ private class MP_INT_UMULT implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("MP_INT_UMULT: requires 2 (Vm, Vn), got " + numArgs);
 			}
@@ -1241,8 +1243,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			BigInteger value = memoryState.getBigInteger(inputs[1], false);
-			BigInteger mult = memoryState.getBigInteger(inputs[2], false);
+			BigInteger value = memoryState.getBigInteger(inputs[0], false);
+			BigInteger mult = memoryState.getBigInteger(inputs[1], false);
 
 			BigInteger result = value.multiply(mult);
 
@@ -1505,7 +1507,7 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Requires 2 inputs
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 2) {
 				throw new LowlevelError("SIMD_PIECE: requires 2 inputs, got " + numArgs);
 			}
@@ -1518,8 +1520,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			// Get the init variable to output, the value to copy, and the offset
 
-			Varnode simdVarnode = inputs[1];
-			int offset = (int) memoryState.getValue(inputs[2]);
+			Varnode simdVarnode = inputs[0];
+			int offset = (int) memoryState.getValue(inputs[1]);
 
 			if (simdVarnode.getSize() < (offset + 1) * outputVarnode.getSize()) {
 				throw new LowlevelError("SIMD_PIECE: input size (" + simdVarnode.getSize()
@@ -1564,8 +1566,8 @@ private class a64_CONCAT implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
-			if (numArgs != 2) {
+			int numArgs = inputs.length;
+			if (inputs.length != 2) {
 				throw new LowlevelError(this.getClass().getName() + ": requires 2 inputs (Vn, Vm), got " + numArgs);
 			}
 			if (outputVarnode == null) {
@@ -1576,8 +1578,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
 			int outSize = outputVarnode.getSize();
 
-			Varnode VnVarnode = inputs[1];
-			Varnode VmVarnode = inputs[2];
+			Varnode VnVarnode = inputs[0];
+			Varnode VmVarnode = inputs[1];
 
 			if (outSize != VnVarnode.getSize() + VmVarnode.getSize()) {
 				throw new LowlevelError(this.getClass().getName() + ": output size (" + outSize
@@ -1615,7 +1617,7 @@ private class a64_TBL implements OpBehaviorOther {
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs < 3 || numArgs > 6) {
 				throw new LowlevelError("a64_TBL: requires 3 to 6 inputs (Vinit, Vn-Vn4, Vm), got " + numArgs);
 			}
@@ -1625,8 +1627,8 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			Varnode updateVarnode = inputs[1];
-			Varnode indexVarnode = inputs[numArgs];
+			Varnode updateVarnode = inputs[0];
+			Varnode indexVarnode = inputs[numArgs - 1];
 
 			// The index size must match the output size
 			if (outputVarnode.getSize() != indexVarnode.getSize()) {
diff --git a/Ghidra/Processors/PowerPC/src/main/java/ghidra/program/emulation/PPCEmulateInstructionStateModifier.java b/Ghidra/Processors/PowerPC/src/main/java/ghidra/program/emulation/PPCEmulateInstructionStateModifier.java
index 1e44af9bdb1..bd5f37d85c7 100644
--- a/Ghidra/Processors/PowerPC/src/main/java/ghidra/program/emulation/PPCEmulateInstructionStateModifier.java
+++ b/Ghidra/Processors/PowerPC/src/main/java/ghidra/program/emulation/PPCEmulateInstructionStateModifier.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -42,11 +42,11 @@ public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
 				throw new LowlevelError("CALLOTHER: Vector permute op missing required output");
 			}
 
-			if (inputs.length != 4) {
+			if (inputs.length != 3) {
 				throw new LowlevelError(
 					"CALLOTHER: Vector permute op requires three non-constant varnode input");
 			}
-			for (int i = 1; i < 4; i++) {
+			for (int i = 0; i < 3; i++) {
 				if (inputs[i].getSize() == 0 || inputs[i].isConstant()) {
 					throw new LowlevelError(
 						"CALLOTHER: Vector permute op requires three non-constant varnode input");
@@ -54,9 +54,9 @@ public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
 				}
 			}
 
-			Varnode in1 = inputs[1];
-			Varnode in2 = inputs[2];
-			Varnode in3 = inputs[3];
+			Varnode in1 = inputs[0];
+			Varnode in2 = inputs[1];
+			Varnode in3 = inputs[2];
 			if ((in1.getSize() != 16) || (in2.getSize() != 16) || (in3.getSize() != 16) ||
 				(out.getSize() != 16)) {
 				throw new LowlevelError(
diff --git a/Ghidra/Processors/Xtensa/src/main/java/ghidra/program/emulation/XtensaEmulateInstructionStateModifier.java b/Ghidra/Processors/Xtensa/src/main/java/ghidra/program/emulation/XtensaEmulateInstructionStateModifier.java
index ecd62648722..9679d0dce32 100644
--- a/Ghidra/Processors/Xtensa/src/main/java/ghidra/program/emulation/XtensaEmulateInstructionStateModifier.java
+++ b/Ghidra/Processors/Xtensa/src/main/java/ghidra/program/emulation/XtensaEmulateInstructionStateModifier.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -48,12 +48,12 @@ private class RotateRegWindow implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
-			if (inputs.length != 2) {
+			if (inputs.length != 1) {
 				throw new LowlevelError("rotateRegWindow: missing required CALLINC input");
 			}
 
 			MemoryState memoryState = emu.getMemoryState();
-			Varnode in = inputs[1];
+			Varnode in = inputs[0];
 			long callinc = memoryState.getValue(in);
 			if (callinc == 0) {
 				return;
@@ -86,7 +86,7 @@ private class RestoreRegWindow implements OpBehaviorOther {
 
 		@Override
 		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
-			if (inputs.length != 1) {
+			if (inputs.length != 0) {
 				throw new LowlevelError("restoreRegWindow: unexpected input varnodes");
 			}
 
diff --git a/Ghidra/Processors/tricore/src/main/java/ghidra/program/emulation/TRICOREEmulateInstructionStateModifier.java b/Ghidra/Processors/tricore/src/main/java/ghidra/program/emulation/TRICOREEmulateInstructionStateModifier.java
index 0b11609a01a..98e7757afbe 100644
--- a/Ghidra/Processors/tricore/src/main/java/ghidra/program/emulation/TRICOREEmulateInstructionStateModifier.java
+++ b/Ghidra/Processors/tricore/src/main/java/ghidra/program/emulation/TRICOREEmulateInstructionStateModifier.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ public TRICOREEmulateInstructionStateModifier(Emulate emu) {
 	private class tricore_SaveCallerState implements OpBehaviorOther {
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 3) throw new LowlevelError(this.getClass().getName() + ": requires 3 inputs (FCX, LCX, PCXI), got " + numArgs);
 
 			MemoryState memoryState = emu.getMemoryState();
@@ -100,7 +100,7 @@ public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
 	private class tricore_RestoreCallerState implements OpBehaviorOther {
 		@Override
 		public void evaluate(Emulate emu, Varnode outputVarnode, Varnode[] inputs) {
-			int numArgs = inputs.length - 1;
+			int numArgs = inputs.length;
 			if (numArgs != 3) throw new LowlevelError(this.getClass().getName() + ": requires 3 inputs (FCX, LCX, PCXI), got " + numArgs);
 
 			MemoryState memoryState = emu.getMemoryState();
```
-----------------------------------
