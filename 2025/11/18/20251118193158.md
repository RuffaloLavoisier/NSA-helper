# Commit: c21c812f7488b1e14595a3a302db2a79b928d85b
## Message: GP-6105: Clear RegisterRow cache on changed language. Use IdentityHashMap.
## Diff:
```
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracemgr/DebuggerCoordinates.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracemgr/DebuggerCoordinates.java
index 7f51b76abd8..cc7c433083f 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracemgr/DebuggerCoordinates.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracemgr/DebuggerCoordinates.java
@@ -28,6 +28,7 @@
 import ghidra.framework.plugintool.PluginTool;
 import ghidra.framework.store.LockException;
 import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.lang.Language;
 import ghidra.trace.database.DBTraceContentHandler;
 import ghidra.trace.model.Lifespan;
 import ghidra.trace.model.Trace;
@@ -48,7 +49,6 @@ public class DebuggerCoordinates {
 
 	/**
 	 * Coordinates that indicate no trace is active in the Debugger UI.
-	 * 
 	 * <p>
 	 * Typically, that only happens when no trace is open. Telling the trace manager to activate
 	 * {@code NOWHERE} will cause it to instead activate the most recently active trace, which may
@@ -609,6 +609,10 @@ public TracePlatform getPlatform() {
 		return platform;
 	}
 
+	public Language getLanguage() {
+		return platform == null ? null : platform.getLanguage();
+	}
+
 	public Target getTarget() {
 		return target;
 	}
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java
index 3424208868a..6de9fe339e8 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java
@@ -332,7 +332,7 @@ private void objectRestored(DomainObjectChangeRecord rec) {
 			 * It's possible an "undo" or other transaction rollback will cause the current thread
 			 * to be replaced by another object. If that's the case, we need to adjust our
 			 * coordinates.
-			 * 
+			 * <p>
 			 * If that adjustment does not otherwise cause the table to update, we have to fire that
 			 * event, since the register values may have changed, esp., if this "restored" event is
 			 * the result of many events being coalesced.
@@ -499,7 +499,7 @@ protected DataType resolveSelection(DataType dataType) {
 	final RegistersTableModel regsTableModel;
 	GhidraTable regsTable;
 	GhidraTableFilterPanel<RegisterRow> regsFilterPanel;
-	Map<Register, RegisterRow> regMap = new HashMap<>();
+	Map<Register, RegisterRow> regMap = new IdentityHashMap<>();
 
 	private final DebuggerAvailableRegistersDialog availableRegsDialog;
 
@@ -826,7 +826,7 @@ public boolean coordinatesActivated(DebuggerCoordinates coordinates) {
 
 		prepareRegisterSpace();
 		recomputeViewKnown();
-		loadRegistersAndValues();
+		loadRegistersAndValues(previous.getLanguage() != current.getLanguage());
 		contextChanged();
 		return true;
 	}
@@ -984,7 +984,6 @@ String getRegisterValueRepresentation(Register register) {
 
 	/**
 	 * Ensure the register space exists and has been populated from register object values.
-	 * 
 	 * <p>
 	 * TODO: I wish this were not necessary. Maybe I should create the space when register object
 	 * values are populated.
@@ -1080,10 +1079,8 @@ private boolean isEditsEnabled() {
 
 	/**
 	 * Gather general registers, the program counter, and the stack pointer
-	 * 
 	 * <p>
 	 * This excludes the context register
-	 * 
 	 * <p>
 	 * TODO: Several pspec files need adjustment to clean up "common registers"
 	 * 
@@ -1234,7 +1231,7 @@ public CompletableFuture<Void> setSelectedRegistersAndLoad(
 		Set<Register> selection = getSelectionFor(current.getPlatform());
 		selection.clear();
 		selection.addAll(new TreeSet<>(selectedRegisters));
-		return loadRegistersAndValues();
+		return loadRegistersAndValues(false);
 	}
 
 	public RegisterRow getRegisterRow(Register register) {
@@ -1275,12 +1272,16 @@ protected void displaySelectedRegisters(Set<Register> selected) {
 		regsTableModel.addAll(toAdd);
 	}
 
-	protected CompletableFuture<Void> loadRegistersAndValues() {
+	protected CompletableFuture<Void> loadRegistersAndValues(boolean changeLanguage) {
 		if (current.getThread() == null) {
 			regsTableModel.clear();
 			regMap.clear();
 			return AsyncUtils.nil();
 		}
+		if (changeLanguage) {
+			regsTableModel.clear();
+			regMap.clear();
+		}
 		Set<Register> selected = getSelectionFor(current.getPlatform());
 		displaySelectedRegisters(selected);
 		return loadValues();
```
-----------------------------------
