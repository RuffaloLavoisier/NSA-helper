# Commit: 90ecfe0b6cf66783cae3c16e39cedeecf82139bf
## Message: Fix for xml saving of nested save states
## Diff:
```
diff --git a/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java b/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java
index e84aba85694..deb951bb3f0 100644
--- a/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java
+++ b/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java
@@ -18,51 +18,399 @@
 import static org.junit.Assert.*;
 
 import org.jdom.Element;
-import org.junit.Before;
 import org.junit.Test;
 
-import ghidra.util.Msg;
+import generic.test.AbstractGTest;
 import ghidra.util.xml.XmlUtilities;
 
 public class SaveStateTest {
-	private SaveState saveState;
 
-	@Before
-	public void setUp() {
-		saveState = new SaveState("foo");
+	@Test
+	public void testEmptySaveState() throws Exception {
+
+		SaveState ss = new SaveState("Client_Name");
+		SaveState restored = saveAndRestoreToXml(ss);
+		assertEquals("Client_Name", restored.getName());
+	}
+
+	@Test
+	public void testEmptyNestedSaveState() throws Exception {
+
+		SaveState ss = new SaveState();
+		SaveState nestedSs = new SaveState("Client_Name2");
+		ss.putSaveState("Key", nestedSs);
+
+		SaveState restored = saveAndRestoreToXml(ss);
+		SaveState restoredNestedSs = restored.getSaveState("Key");
+		assertEquals("Client_Name2", restoredNestedSs.getName());
+	}
+
+	@Test
+	public void testRestoreFromXml_BackwardCompatibility_OldestStyleSaveState() throws Exception {
+
+		/*
+		 	Test for backwards compatibility from the original format for save state that was
+		 	around since the beginning.
+		 	
+		 	Note: the oldest style had:
+		 		- no 'KEY' attribute
+		 		- an extra layer of <SAVE_STATE> between the top layer and <STATE> element
+		 */
+
+		//@formatter:off
+		String xml = """
+			<SAVE_STATE>
+				<SAVE_STATE NAME="Bar" TYPE="SaveState">
+			        <SAVE_STATE>
+			            <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
+			        </SAVE_STATE>
+			    </SAVE_STATE>
+			</SAVE_STATE>
+				""";
+		//@formatter:on
+
+		Element element = XmlUtilities.fromString(xml);
+		SaveState rootSaveState = new SaveState(element);
+
+		SaveState saveState = rootSaveState.getSaveState("Bar");
+		assertNotNull(saveState);
+
+		// In the old style, 'NAME' was used as the key value and the state itself had no name.
+		// In this case, getName() returns the default of 'SAVE_STATE'.
+		assertEquals(SaveState.SAVE_STATE_TAG_NAME, saveState.getName());
+
+		assertEquals(3, saveState.getInt("DATED_OPTION", -1));
 	}
 
 	@Test
-	public void testSubSaveStateToXml() throws Exception {
-		SaveState subState = new SaveState("sub");
-		subState.putInt("a", 5);
-		subState.putString("foo", "bar");
+	public void testRestoreFromXml_BackwardCompatibility_OldestStyleSaveState_CustomXmlTagName()
+			throws Exception {
+
+		/*
+		 	Test for backwards compatibility from an intermediate format for save state that was
+		 	around for a few months.
+		 	
+		 	Note: the oldest style had:
+		 		- no 'KEY' attribute
+		 		- an extra layer of <SAVE_STATE> between the top layer and <STATE> element
+		 		- a custom xml tag instead of <SAVE_STATE>
+		 */
+
+		//@formatter:off
+		String xml = """
+			<SAVE_STATE>
+			    <SAVE_STATE NAME="TEST" TYPE="SaveState">
+			        <BAR>
+			            <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
+			        </BAR>
+			    </SAVE_STATE>
+			</SAVE_STATE>
+				""";
+		//@formatter:on
+
+		Element element = XmlUtilities.fromString(xml);
+		SaveState rootSaveState = new SaveState(element);
+
+		SaveState saveState = rootSaveState.getSaveState("TEST");
+		assertNotNull(saveState);
+
+		// In the old style, 'NAME' was used as the key value and the state itself had no name.
+		// In this case, getName() returns the default of 'SAVE_STATE'.
+		assertEquals(SaveState.SAVE_STATE_TAG_NAME, saveState.getName());
+		assertEquals(3, saveState.getInt("DATED_OPTION", -1));
+	}
+
+	@Test
+	public void testRestoreFromXml_BackwardCompatibility_OldestStyleSaveState_EmtpyNestdState()
+			throws Exception {
+
+		/*
+		 	Test for backwards compatibility from the original format for save state that was
+		 	around since the beginning.
+		 	
+		 	Note: the oldest style had:
+		 		- no 'KEY' attribute
+		 		- an extra layer of <SAVE_STATE> between the top layer and <STATE> element
+		 */
+
+		//@formatter:off
+		String xml = """
+			<SAVE_STATE>
+				<SAVE_STATE NAME="Bar" TYPE="SaveState" />
+			</SAVE_STATE>
+				""";
+		//@formatter:on
+
+		Element element = XmlUtilities.fromString(xml);
+		SaveState rootSaveState = new SaveState(element);
+
+		SaveState saveState = rootSaveState.getSaveState("Bar");
+		assertNotNull(saveState);
+
+		// In the old style, 'NAME' was used as the key value and the state itself had no name.
+		// In this case, getName() returns the default of 'SAVE_STATE'.
+		assertEquals(SaveState.SAVE_STATE_TAG_NAME, saveState.getName());
+	}
+
+	@Test
+	public void testRestoreFromXml_BackwardCompatibility_RecentStyleSaveState() throws Exception {
+
+		/*
+		 	Test for backwards compatibility from an intermediate format for save state that was
+		 	around for a few months.
+		 	
+		 	Note: the oldest style had:
+		 		- no 'KEY' attribute
+		 		- NO extra layer of <SAVE_STATE> between the top layer and <STATE> element
+		 */
+
+		//@formatter:off
+		String xml = """
+			<SAVE_STATE>
+			    <SAVE_STATE NAME="Bar" TYPE="SaveState">
+			        <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
+			    </SAVE_STATE>
+			</SAVE_STATE>
+				""";
+		//@formatter:on
+
+		Element element = XmlUtilities.fromString(xml);
+		SaveState rootSaveState = new SaveState(element);
+
+		SaveState saveState = rootSaveState.getSaveState("Bar");
+		assertNotNull(saveState);
+
+		// In the old style, 'NAME' was used as the key value and the state itself had no name.
+		// In this case, getName() returns the default of 'SAVE_STATE'.
+		assertEquals(SaveState.SAVE_STATE_TAG_NAME, saveState.getName());
+	}
+
+	@Test
+	public void testSaveState_Unnamed_SingleLayer_RoundTrip() throws Exception {
+
+		SaveState saveState = new SaveState();
+		saveState.putInt("Foo", 21);
+
+		SaveState restoredState = saveAndRestoreToXml(saveState);
+		assertEquals(21, restoredState.getInt("Foo", -1));
+		assertEquals(SaveState.SAVE_STATE_TAG_NAME, restoredState.getName());
+	}
+
+	@Test
+	public void testSaveState_Named_SingleLayer_RoundTrip() throws Exception {
+
+		SaveState saveState = new SaveState("Client_Name");
+		saveState.putInt("Foo", 21);
+
+		SaveState restoredState = saveAndRestoreToXml(saveState);
+		assertEquals(21, restoredState.getInt("Foo", -1));
+		assertEquals("Client_Name", restoredState.getName());
+	}
+
+	@Test
+	public void testSaveState_Unnamed_DoubleLayer_RoundTrip() throws Exception {
+
+		/*
+		 	<SAVE_STATE>
+			    <SAVE_STATE NAME="UNNAMED" KEY="LAYER_TWO" TYPE="SaveState">
+			        <STATE NAME="layer_two.aa" TYPE="int" VALUE="5" />
+			        <STATE NAME="layer_two.bb" TYPE="string" VALUE="bar" />
+			    </SAVE_STATE>
+			    <STATE NAME="layer_one.a" TYPE="string" VALUE="zzzz" />
+			</SAVE_STATE>
+		 */
 
-		saveState.putSaveState("TEST", subState);
-		saveState.putString("xxx", "zzzz");
+		// create the hierarchy inside-out for readability
+		SaveState layer2State = new SaveState();
+		layer2State.putInt("layer_two.aa", 5);
+		layer2State.putString("layer_two.bb", "bar");
 
-		SaveState restoredState = saveAndRestoreToXml();
+		SaveState rootSaveState = new SaveState();
+		rootSaveState.putSaveState("LAYER_TWO", layer2State);
+		rootSaveState.putString("layer_one.a", "zzzz");
+
+		SaveState restoredState = saveAndRestoreToXml(rootSaveState);
+
+		// make sure our value is inside
+		assertEquals("zzzz", restoredState.getString("layer_one.a", null));
+		SaveState restoredSubState = restoredState.getSaveState("LAYER_TWO");
+
+		assertEquals(SaveState.DEFAULT_NAME, restoredSubState.getName());
+
+		String[] expectedNames = { "layer_two.aa", "layer_two.bb" };
+		AbstractGTest.assertArraysEqualUnordered(expectedNames, restoredSubState.getNames());
+		assertEquals(5, restoredSubState.getInt("layer_two.aa", 0));
+		assertEquals("bar", restoredSubState.getString("layer_two.bb", ""));
+	}
+
+	@Test
+	public void testSaveState_Named_DoubleLayer_RoundTrip() throws Exception {
+
+		/*
+		 	<SAVE_STATE>
+			    <SAVE_STATE NAME="Client_Name" KEY="LAYER_TWO" TYPE="SaveState">
+			        <STATE NAME="layer_two.aa" TYPE="int" VALUE="5" />
+			        <STATE NAME="layer_two.bb" TYPE="string" VALUE="bar" />
+			    </SAVE_STATE>
+			    <STATE NAME="layer_one.a" TYPE="string" VALUE="zzzz" />
+			</SAVE_STATE>
+		 */
+
+		// create the hierarchy inside-out for readability
+		SaveState layer2State = new SaveState("Client_Name");
+		layer2State.putInt("layer_two.aa", 5);
+		layer2State.putString("layer_two.bb", "bar");
+
+		SaveState rootSaveState = new SaveState();
+		rootSaveState.putSaveState("LAYER_TWO", layer2State);
+		rootSaveState.putString("layer_one.a", "zzzz");
+
+		SaveState restoredState = saveAndRestoreToXml(rootSaveState);
+
+		// make sure our value is inside
+		assertEquals("zzzz", restoredState.getString("layer_one.a", null));
+		SaveState restoredSubState = restoredState.getSaveState("LAYER_TWO");
+
+		String[] expectedNames = { "layer_two.aa", "layer_two.bb" };
+		AbstractGTest.assertArraysEqualUnordered(expectedNames, restoredSubState.getNames());
+		assertEquals(5, restoredSubState.getInt("layer_two.aa", 0));
+		assertEquals("bar", restoredSubState.getString("layer_two.bb", ""));
+	}
+
+	@Test
+	public void testSaveState_Unnamed_TripleLayer_RoundTrip() throws Exception {
+
+		/*
+		<SAVE_STATE>
+		    <SAVE_STATE NAME="UNNAMED" KEY="LAYER_TWO" TYPE="SaveState">
+		        <SAVE_STATE NAME="UNNAMED" KEY="LAYER_THREE" TYPE="SaveState">
+		            <STATE NAME="layer_three.power_on" TYPE="boolean" VALUE="false" />
+		        </SAVE_STATE>
+		        <STATE NAME="layer_two.a" TYPE="int" VALUE="5" />
+		        <STATE NAME="layer_two.foo" TYPE="string" VALUE="bar" />
+		    </SAVE_STATE>
+		    <STATE NAME="layer_one.name" TYPE="string" VALUE="zzzz" />
+		</SAVE_STATE>
+		*/
+
+		// create the hierarchy inside-out
+		SaveState layer3State = new SaveState();
+		layer3State.putBoolean("layer_three.aaa", false);
+
+		SaveState layer2State = new SaveState();
+		layer2State.putInt("layer_two.aa", 5);
+		layer2State.putString("layer_two.bb", "bar");
+		layer2State.putSaveState("LAYER_THREE", layer3State);
+
+		SaveState rootSaveState = new SaveState();
+		rootSaveState.putSaveState("LAYER_TWO", layer2State);
+		rootSaveState.putString("layer_one.aa", "zzzz");
+
+		SaveState restoredState = saveAndRestoreToXml(rootSaveState);
+
+		// make sure our value is inside
+		assertEquals("zzzz", restoredState.getString("layer_one.aa", null));
+		SaveState restoredSubState = restoredState.getSaveState("LAYER_TWO");
+
+		assertEquals(SaveState.DEFAULT_NAME, restoredSubState.getName());
+
+		String[] expectedNames = { "LAYER_THREE", "layer_two.aa", "layer_two.bb" };
+		AbstractGTest.assertArraysEqualUnordered(expectedNames, restoredSubState.getNames());
+		assertEquals(5, restoredSubState.getInt("layer_two.aa", 0));
+		assertEquals("bar", restoredSubState.getString("layer_two.bb", ""));
+
+		SaveState restoredSubSubState = restoredSubState.getSaveState("LAYER_THREE");
+		assertEquals(SaveState.DEFAULT_NAME, restoredSubSubState.getName());
+		assertEquals(false, restoredSubSubState.getBoolean("layer_three.aaa", true));
+	}
+
+	@Test
+	public void testSaveState_Named_TripleLayer_RoundTrip() throws Exception {
+
+		/*
+		<SAVE_STATE>
+		    <SAVE_STATE NAME="Client_Name_2" KEY="LAYER_TWO" TYPE="SaveState">
+		        <SAVE_STATE NAME="Client_Name_3" KEY="LAYER_THREE" TYPE="SaveState">
+		            <STATE NAME="layer_three.power_on" TYPE="boolean" VALUE="false" />
+		        </SAVE_STATE>
+		        <STATE NAME="layer_two.a" TYPE="int" VALUE="5" />
+		        <STATE NAME="layer_two.foo" TYPE="string" VALUE="bar" />
+		    </SAVE_STATE>
+		    <STATE NAME="layer_one.name" TYPE="string" VALUE="zzzz" />
+		</SAVE_STATE>
+		*/
+
+		// create the hierarchy inside-out
+		SaveState layer3State = new SaveState("Client_Name_3");
+		layer3State.putBoolean("layer_three.aaa", false);
+
+		SaveState layer2State = new SaveState("Client_Name_2");
+		layer2State.putInt("layer_two.aa", 5);
+		layer2State.putString("layer_two.bb", "bar");
+		layer2State.putSaveState("LAYER_THREE", layer3State);
+
+		SaveState rootSaveState = new SaveState();
+		rootSaveState.putSaveState("LAYER_TWO", layer2State);
+		rootSaveState.putString("layer_one.aa", "zzzz");
+
+		SaveState restoredState = saveAndRestoreToXml(rootSaveState);
 
 		// make sure our value is inside
-		assertEquals("zzzz", restoredState.getString("xxx", null));
-		SaveState restoreSubState = restoredState.getSaveState("TEST");
-		assertEquals(2, restoreSubState.getNames().length);
-		assertEquals(5, restoreSubState.getInt("a", 0));
-		assertEquals("bar", restoreSubState.getString("foo", ""));
-
-		SaveState s1 = new SaveState("Parent");
-		SaveState c1 = new SaveState("Child1");
-		c1.putBoolean("Bool1", false);
-		c1.putString("String1", "Hey bob");
-		s1.putSaveState("MapChildName1", c1);
-		Element e = s1.saveToXml();
-		String s = XmlUtilities.toString(e);
-		Msg.debug(this, s);
+		assertEquals("zzzz", restoredState.getString("layer_one.aa", null));
+		SaveState restoredSubState = restoredState.getSaveState("LAYER_TWO");
+
+		assertEquals("Client_Name_2", restoredSubState.getName());
+
+		String[] expectedNames = { "LAYER_THREE", "layer_two.aa", "layer_two.bb" };
+		AbstractGTest.assertArraysEqualUnordered(expectedNames, restoredSubState.getNames());
+		assertEquals(5, restoredSubState.getInt("layer_two.aa", 0));
+		assertEquals("bar", restoredSubState.getString("layer_two.bb", ""));
+
+		SaveState restoredSubSubState = restoredSubState.getSaveState("LAYER_THREE");
+		assertEquals("Client_Name_3", restoredSubSubState.getName());
+		assertEquals(false, restoredSubSubState.getBoolean("layer_three.aaa", true));
+	}
+
+	@Test
+	public void testSaveState_Unnamed_SiblingSaveStates_RoundTrip() throws Exception {
+
+		/*
+		<SAVE_STATE>
+		    <SAVE_STATE NAME="Client_Name_2_1" KEY="LAYER_TWO_ONE" TYPE="SaveState">
+		        <STATE NAME="layer_two_one.a" TYPE="int" VALUE="5" />
+		    </SAVE_STATE>
+		    <SAVE_STATE NAME="Client_Name_2_2" KEY="LAYER_TWO_TWO" TYPE="SaveState">
+		        <STATE NAME="layer_two_two.a" TYPE="int" VALUE="5" />
+		    </SAVE_STATE>
+		</SAVE_STATE>
+		*/
+
+		// create the hierarchy inside-out
+		SaveState layer2_1State = new SaveState("Client_Name_2_1");
+		layer2_1State.putInt("layer_two_one.a", 5);
+
+		SaveState layer2_2State = new SaveState("Client_Name_2_2");
+		layer2_2State.putInt("layer_two_two.a", 6);
+
+		SaveState rootSaveState = new SaveState();
+		rootSaveState.putSaveState("LAYER_TWO_ONE", layer2_1State);
+		rootSaveState.putSaveState("LAYER_TWO_TWO", layer2_2State);
+
+		SaveState restoredState = saveAndRestoreToXml(rootSaveState);
+
+		// make sure our value is inside
+		SaveState restoredSubState1 = restoredState.getSaveState("LAYER_TWO_ONE");
+		assertEquals("Client_Name_2_1", restoredSubState1.getName());
+
+		SaveState restoredSubState2 = restoredState.getSaveState("LAYER_TWO_TWO");
+		assertEquals("Client_Name_2_2", restoredSubState2.getName());
 
+		assertEquals(5, restoredSubState1.getInt("layer_two_one.a", -1));
+		assertEquals(6, restoredSubState2.getInt("layer_two_two.a", -1));
 	}
 
-	private SaveState saveAndRestoreToXml() throws Exception {
-		Element saveToXml = saveState.saveToXml();
+	private SaveState saveAndRestoreToXml(SaveState ss) throws Exception {
+		Element saveToXml = ss.saveToXml();
 		return new SaveState(saveToXml);
 	}
 }
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/AttributedSaveState.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/AttributedSaveState.java
index b931938d7d8..d4f4630d2f1 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/AttributedSaveState.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/AttributedSaveState.java
@@ -89,14 +89,17 @@ private Map<String, Map<String, String>> getPropertyAttributes() {
 	}
 
 	@Override
-	protected SaveState createSaveState() {
-		return new AttributedSaveState();
+	protected SaveState createSaveState(String name) {
+		if (name == null) {
+			return new AttributedSaveState();
+		}
+		return new AttributedSaveState(name);
 	}
 
 	@Override
 	protected void initializeElement(Element e) {
 
-		String name = e.getAttributeValue(NAME);
+		String name = e.getAttributeValue(ATTRIBUTE_NAME);
 		if (name == null) {
 			return; // sub-element; properties not supported
 		}
@@ -119,7 +122,7 @@ protected void initializeElement(Element e) {
 	protected void processElement(Element element) {
 		super.processElement(element);
 
-		String name = element.getAttributeValue(NAME);
+		String name = element.getAttributeValue(ATTRIBUTE_NAME);
 		if (name == null) {
 			return; // sub-element; properties not supported
 		}
@@ -138,7 +141,7 @@ protected void processElement(Element element) {
 			String attrName = attr.getName();
 			String attrValue = switch (attrName) {
 				// ignore standard attributes, as they are managed by the parent class
-				case NAME, TYPE, VALUE -> null;
+				case ATTRIBUTE_NAME, ATTRIBUTE_TYPE, ATTRIBUTE_VALUE -> null;
 				default -> attr.getValue();
 			};
 
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/GProperties.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/GProperties.java
index 081a9bb19aa..f86ca730f64 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/GProperties.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/GProperties.java
@@ -75,12 +75,23 @@ public class GProperties {
 	private static final String GPROPERTIES_TAG = "GPROPERTIES";
 	private static final String PROPERTIES_NAME = "GPROPERTIES_NAME";
 	private static final String LEGACY_PROPERTIES_NAME = "SAVE_STATE_NAME";
-	private static final String STATE = "STATE";
-	protected static final String TYPE = "TYPE";
-	protected static final String NAME = "NAME";
-	protected static final String VALUE = "VALUE";
+	protected static final String STATE = "STATE";
+
+	/** The xml attribute for the type of the property (e.g., int, String, etc)*/
+	protected static final String ATTRIBUTE_TYPE = "TYPE";
+
+	/** The xml attribute for the 'key' in the key/value mapping */
+	protected static final String ATTRIBUTE_KEY = "KEY";
+
+	/** The xml attribute for the optional save state 'name' */
+	protected static final String ATTRIBUTE_NAME = "NAME";
+
+	/** The xml attribute for the 'value' in the key/value mapping */
+	protected static final String ATTRIBUTE_VALUE = "VALUE";
+
 	public static DateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
 	private static final String ARRAY_ELEMENT_NAME = "A";
+
 	protected TreeMap<String, Object> map; // use ordered map for deterministic serialization
 	private String propertiesName;
 
@@ -129,11 +140,15 @@ public GProperties(JsonObject root) {
 		}
 	}
 
+	/**
+	 * Called to restore this class' properties when restoring from xml.
+	 * @param elem the element
+	 */
 	protected void processElement(Element elem) {
 		String tag = elem.getName();
-		String name = elem.getAttributeValue(NAME);
-		String type = elem.getAttributeValue(TYPE);
-		String value = elem.getAttributeValue(VALUE);
+		String name = elem.getAttributeValue(ATTRIBUTE_NAME);
+		String type = elem.getAttributeValue(ATTRIBUTE_TYPE);
+		String value = elem.getAttributeValue(ATTRIBUTE_VALUE);
 		if (tag.equals("XML")) {
 			map.put(name, elem.getChildren().get(0));
 		}
@@ -209,7 +224,7 @@ else if (tag.equals("ARRAY")) {
 					short[] vals = new short[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Short.parseShort(e.getAttributeValue(VALUE));
+						vals[i++] = Short.parseShort(e.getAttributeValue(ATTRIBUTE_VALUE));
 					}
 					map.put(name, vals);
 				}
@@ -217,7 +232,7 @@ else if (type.equals("int")) {
 					int[] vals = new int[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Integer.parseInt(e.getAttributeValue(VALUE));
+						vals[i++] = Integer.parseInt(e.getAttributeValue(ATTRIBUTE_VALUE));
 					}
 					map.put(name, vals);
 				}
@@ -225,7 +240,7 @@ else if (type.equals("long")) {
 					long[] vals = new long[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Long.parseLong(e.getAttributeValue(VALUE));
+						vals[i++] = Long.parseLong(e.getAttributeValue(ATTRIBUTE_VALUE));
 					}
 					map.put(name, vals);
 				}
@@ -233,7 +248,7 @@ else if (type.equals("float")) {
 					float[] vals = new float[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Float.parseFloat(e.getAttributeValue(VALUE));
+						vals[i++] = Float.parseFloat(e.getAttributeValue(ATTRIBUTE_VALUE));
 					}
 					map.put(name, vals);
 				}
@@ -241,7 +256,7 @@ else if (type.equals("double")) {
 					double[] vals = new double[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Double.parseDouble(e.getAttributeValue(VALUE));
+						vals[i++] = Double.parseDouble(e.getAttributeValue(ATTRIBUTE_VALUE));
 					}
 					map.put(name, vals);
 				}
@@ -249,7 +264,8 @@ else if (type.equals("boolean")) {
 					boolean[] vals = new boolean[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = Boolean.valueOf(e.getAttributeValue(VALUE)).booleanValue();
+						vals[i++] =
+							Boolean.valueOf(e.getAttributeValue(ATTRIBUTE_VALUE)).booleanValue();
 					}
 					map.put(name, vals);
 				}
@@ -257,7 +273,7 @@ else if (type.equals("string")) {
 					String[] vals = new String[list.size()];
 					while (it.hasNext()) {
 						Element e = (Element) it.next();
-						vals[i++] = e.getAttributeValue(VALUE);
+						vals[i++] = e.getAttributeValue(ATTRIBUTE_VALUE);
 					}
 					map.put(name, vals);
 				}
@@ -505,6 +521,13 @@ public Element saveToXml() {
 		return root;
 	}
 
+	/**
+	 * Called to save this class' properties to xml.
+	 * 
+	 * @param propertyName the property name to save
+	 * @param value the property value
+	 * @return the xml element
+	 */
 	protected Element createElement(String propertyName, Object value) {
 		Element elem = null;
 		if (value instanceof Element) {
@@ -533,13 +556,13 @@ else if (value instanceof Boolean) {
 		}
 		else if (value instanceof String) {
 			elem = createElement(STATE, propertyName);
-			elem.setAttribute(TYPE, "string");
+			elem.setAttribute(ATTRIBUTE_TYPE, "string");
 			if (XmlUtilities.hasInvalidXMLCharacters((String) value)) {
 				elem.setAttribute("ENCODED_VALUE", NumericUtilities
 						.convertBytesToString(((String) value).getBytes(StandardCharsets.UTF_8)));
 			}
 			else {
-				elem.setAttribute(VALUE, (String) value);
+				elem.setAttribute(ATTRIBUTE_VALUE, (String) value);
 			}
 		}
 		else if (value instanceof Color) {
@@ -559,7 +582,8 @@ else if (value instanceof Font font) {
 		}
 		else if (value instanceof byte[]) {
 			elem = createElement("BYTES", propertyName);
-			elem.setAttribute(VALUE, NumericUtilities.convertBytesToString((byte[]) value));
+			elem.setAttribute(ATTRIBUTE_VALUE,
+				NumericUtilities.convertBytesToString((byte[]) value));
 		}
 		else if (value instanceof short[]) {
 			elem = setArrayAttributes(propertyName, "short", value);
@@ -585,14 +609,14 @@ else if (value instanceof String[]) {
 		else if (value instanceof Enum) {
 			Enum<?> e = (Enum<?>) value;
 			elem = createElement("ENUM", propertyName);
-			elem.setAttribute(TYPE, "enum");
+			elem.setAttribute(ATTRIBUTE_TYPE, "enum");
 			elem.setAttribute("CLASS", e.getClass().getName());
-			elem.setAttribute(VALUE, e.name());
+			elem.setAttribute(ATTRIBUTE_VALUE, e.name());
 		}
 		else if (value instanceof GProperties) {
 			Element savedElement = ((GProperties) value).saveToXml();
 			elem = createElement(GPROPERTIES_TAG, propertyName);
-			elem.setAttribute(TYPE, G_PROPERTIES_TYPE);
+			elem.setAttribute(ATTRIBUTE_TYPE, G_PROPERTIES_TYPE);
 			elem.addContent(savedElement);
 		}
 		else {
@@ -603,12 +627,12 @@ else if (value instanceof GProperties) {
 
 	private <T> Element setArrayAttributes(String propertyName, String type, Object values) {
 		Element elem = createElement("ARRAY", propertyName);
-		elem.setAttribute(TYPE, type);
+		elem.setAttribute(ATTRIBUTE_TYPE, type);
 		for (int i = 0; i < Array.getLength(values); i++) {
 			Object value = Array.get(values, i);
 			if (value != null) {
 				Element arrElem = new Element(ARRAY_ELEMENT_NAME);
-				arrElem.setAttribute(VALUE, value.toString());
+				arrElem.setAttribute(ATTRIBUTE_VALUE, value.toString());
 				elem.addContent(arrElem);
 			}
 		}
@@ -617,7 +641,7 @@ private <T> Element setArrayAttributes(String propertyName, String type, Object
 
 	protected Element createElement(String tag, String name) {
 		Element e = new Element(tag);
-		e.setAttribute(NAME, name);
+		e.setAttribute(ATTRIBUTE_NAME, name);
 		initializeElement(e);
 		return e;
 	}
@@ -628,8 +652,8 @@ protected void initializeElement(Element e) {
 
 	private Element setAttributes(String propertyName, String type, String value) {
 		Element elem = createElement(STATE, propertyName);
-		elem.setAttribute(TYPE, type);
-		elem.setAttribute(VALUE, value);
+		elem.setAttribute(ATTRIBUTE_TYPE, type);
+		elem.setAttribute(ATTRIBUTE_VALUE, value);
 		return elem;
 	}
 
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/SaveState.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/SaveState.java
index af93e7413ae..4393b479250 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/SaveState.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/options/SaveState.java
@@ -52,7 +52,10 @@
  */
 
 public class SaveState extends XmlProperties {
-	private static final String SAVE_STATE = "SAVE_STATE";
+
+	private static final String XML_TYPE = "SaveState";
+	static final String SAVE_STATE_TAG_NAME = "SAVE_STATE";
+	static final String DEFAULT_NAME = "UNNAMED";
 
 	/**
 	 * Creates a new SaveState object with a non-default name.  The name serves no real purpose
@@ -65,12 +68,11 @@ public SaveState(String name) {
 	}
 
 	/**
-	 * Default Constructor for SaveState; uses "SAVE_STATE" as the
-	 * name of the state.
+	 * Default Constructor for SaveState; uses {@value #DEFAULT_NAME} as the name of the state.
 	 * @see java.lang.Object#Object()
 	 */
 	public SaveState() {
-		this(SAVE_STATE);
+		this(SAVE_STATE_TAG_NAME);
 	}
 
 	/**
@@ -119,39 +121,75 @@ public SaveState getSaveState(String name) {
 	@Override
 	protected void processElement(Element element) {
 		String tag = element.getName();
-		if (!tag.equals("SAVE_STATE")) {
+		if (!tag.equals(SAVE_STATE_TAG_NAME)) {
 			super.processElement(element);
 			return;
 		}
 
+		if (isOldStyleSaveState(element)) {
+			restoreSaveStateWithoutKeyAttribute(element);
+			return;
+		}
+
 		/*
+		 	We are restoring a child SaveState from xml.
+		 	
 		 	When using a SaveState inside of a SaveState, we produce xml that looks like this: 
 		 	
-		 	<SAVE_STATE NAME="Bar" TYPE="SaveState">
-		        <STATE NAME="Bar" TYPE="int" VALUE="3" />
-		    </SAVE_STATE>
+		    <SAVE_STATE>
+				<SAVE_STATE KEY="Property Key" NAME="Client Name" TYPE="SaveState">
+				    <STATE NAME="a" TYPE="int" VALUE="5" />
+				</SAVE_STATE>
+			</SAVE_STATE>
 		 */
 
-		SaveState saveState = createSaveState();
+		String key = element.getAttributeValue(ATTRIBUTE_KEY);
+		String name = element.getAttributeValue(ATTRIBUTE_NAME);
+		SaveState saveState = createSaveState(name);
+
+		List<Element> children = element.getChildren();
+		for (Element e : children) {
+			saveState.processElement(e);
+		}
+
+		map.put(key, saveState);
+	}
+
+	@SuppressWarnings("unchecked")
+	private void restoreSaveStateWithoutKeyAttribute(Element element) {
 
+		String key = element.getAttributeValue(ATTRIBUTE_NAME);
+		SaveState saveState = createSaveState(null);
 		List<Element> children = element.getChildren();
 		if (children.isEmpty()) {
+			map.put(key, saveState);
 			return;
 		}
 
 		Element child = (Element) element.getChildren().get(0);
-		String childTag = child.getName();
-		if (childTag.equals("SAVE_STATE")) {
-			/*
-			 	Old style tag, with one level of extra nesting
-			 	
-			 	<SAVE_STATE NAME="Bar" TYPE="SaveState">
-			        <SAVE_STATE>
-			            <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
-			        </SAVE_STATE>
+		if (child == null) {
+			return; //  not sure if this can happen
+		}
+
+		/*
+			Old style tag, with one level of extra nesting
+			
+			<SAVE_STATE NAME="Bar" TYPE="SaveState">
+			    <SAVE_STATE>   <-- This is an intermediate 'child' tag
+			        <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
 			    </SAVE_STATE>
-			 	
-			 */
+			</SAVE_STATE>
+			
+			and another old style:
+			
+			<SAVE_STATE NAME="Bar" TYPE="SaveState">  (this has no intermediate 'child' tag)
+			    <STATE NAME="DATED_OPTION" TYPE="int" VALUE="3" />
+			</SAVE_STATE>		
+		*/
+
+		String childTag = child.getName();
+		if (!childTag.equals(STATE)) {
+			// this is the case where we have an intermediate node; we want that child's children
 			children = child.getChildren();
 		}
 
@@ -159,8 +197,21 @@ protected void processElement(Element element) {
 			saveState.processElement(e);
 		}
 
-		String parentName = element.getAttributeValue(NAME);
-		map.put(parentName, saveState);
+		map.put(key, saveState);
+	}
+
+	private boolean isOldStyleSaveState(Element element) {
+		/*
+		 	Older style save states looked like this:
+		 	
+		 		<SAVE_STATE NAME="Foo" TYPE="SaveState">
+		 	
+		 	where there is no 'KEY' attribute.  The new style looks like this (note that the value
+		 	of 'KEY' used to be the value stored in 'NAME'):
+		 	
+		 		<SAVE_STATE KEY="Foo" NAME="Client Name" TYPE="SaveState">
+		 */
+		return element.getAttribute(ATTRIBUTE_KEY) == null;
 	}
 
 	@SuppressWarnings("unchecked")
@@ -171,17 +222,28 @@ protected Element createElement(String key, Object value) {
 		}
 
 		/*
+		 	We are saving a child SaveState to xml.
+		 	
 		 	When using a SaveState inside of a SaveState, we produce xml that looks like this: 
 		 	
-		 	<SAVE_STATE NAME="Bar" TYPE="SaveState">
-		        <STATE NAME="Bar" TYPE="int" VALUE="3" />
-		    </SAVE_STATE>
+		    <SAVE_STATE>
+				<SAVE_STATE KEY="Property Key" NAME="Client Name" TYPE="SaveState">
+				    <STATE NAME="a" TYPE="int" VALUE="5" />
+				</SAVE_STATE>
+			</SAVE_STATE>
 		 */
 
 		Element savedElement = saveState.saveToXml();
-		Element element = new Element("SAVE_STATE");
-		element.setAttribute(NAME, key);
-		element.setAttribute(TYPE, "SaveState");
+		Element element = new Element(SAVE_STATE_TAG_NAME);
+
+		String name = saveState.getName();
+		if (SAVE_STATE_TAG_NAME.equals(name)) {
+			name = DEFAULT_NAME;
+		}
+
+		element.setAttribute(ATTRIBUTE_NAME, name);
+		element.setAttribute(ATTRIBUTE_KEY, key);
+		element.setAttribute(ATTRIBUTE_TYPE, XML_TYPE);
 
 		// do not write an extra <SAVE_STATE> intermediate node
 		List<Element> children = savedElement.getChildren();
@@ -194,7 +256,11 @@ protected Element createElement(String key, Object value) {
 	}
 
 	// allows subclasses to override how sub-save states are created
-	protected SaveState createSaveState() {
-		return new SaveState();
+	protected SaveState createSaveState(String name) {
+		if (name == null) {
+			// null implies an old style xml where a name was not specified
+			return new SaveState();
+		}
+		return new SaveState(name);
 	}
 }
```
-----------------------------------
