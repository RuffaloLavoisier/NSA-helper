# Commit: cddc569fe10922a2997e39363424926ec91c510b
## Message: API rate limit exceeded for 172.184.172.210. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeViewerProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeViewerProvider.java
index 06b6ef1d4ed..8a9f7fca932 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeViewerProvider.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeViewerProvider.java
@@ -72,7 +72,6 @@ public class CodeViewerProvider extends NavigatableComponentProviderAdapter
 		ChangeListener, StringSelectionListener, PopupActionProvider {
 
 	private static final String SHOW_FUNCITON_VARS_OPTIONS_NAME = "SHOW_FUNCITON_VARS";
-	private static final String OLD_NAME = "CodeBrowserPlugin";
 	private static final String NAME = "Listing";
 	private static final String TITLE = NAME + ": ";
 
@@ -131,7 +130,6 @@ public class CodeViewerProvider extends NavigatableComponentProviderAdapter
 
 	private MultiListingLayoutModel multiModel;
 	private ToggleDockingAction toggleVariablesAction;
-	private ToggleDockingAction toggleFunctionsAction;
 
 	public CodeViewerProvider(CodeBrowserPluginInterface plugin, FormatManager formatMgr,
 			boolean isConnected) {
@@ -140,9 +138,6 @@ public CodeViewerProvider(CodeBrowserPluginInterface plugin, FormatManager forma
 		this.plugin = plugin;
 		this.formatMgr = formatMgr;
 
-		// note: the owner has not changed, just the name; remove sometime after version 10
-		String owner = plugin.getName();
-		ComponentProvider.registerProviderNameOwnerChange(OLD_NAME, owner, NAME, owner);
 		registerAdjustableFontId(ListingDisplayOptionsEditor.DEFAULT_FONT_ID);
 		setConnected(isConnected);
 		setIcon(new GIcon("icon.plugin.codebrowser.provider"));
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
index 245fbeb6d19..84189c07eff 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
@@ -27,10 +27,8 @@
 import docking.widgets.OptionDialog;
 import docking.widgets.tabbedpane.DockingTabRenderer;
 import ghidra.util.HelpLocation;
-import ghidra.util.Msg;
 import ghidra.util.exception.AssertException;
 import help.HelpService;
-import utilities.util.reflection.ReflectionUtilities;
 
 /**
  * Node object for managing one or more components. If more that one managed component
@@ -265,18 +263,6 @@ JComponent getComponent() {
 		populateActiveComponents(activeComponents);
 		int count = activeComponents.size();
 		if (count == 1) {
-
-			//
-			// TODO Hack Alert!  (When this is removed, also update ComponentPlaceholder)
-			// 
-			ComponentPlaceholder nextTop = activeComponents.get(0);
-			if (nextTop.isDisposed()) {
-				// This should not happen!  We have seen this bug recently
-				Msg.debug(this, "Found disposed component that was not removed from the active " +
-					"list: " + nextTop, ReflectionUtilities.createJavaFilteredThrowable());
-				return null;
-			}
-
 			top = activeComponents.get(0);
 			comp = top.getComponent();
 			comp.setBorder(BorderFactory.createRaisedBevelBorder());
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentPlaceholder.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentPlaceholder.java
index b738f5b5364..679763e0868 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentPlaceholder.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentPlaceholder.java
@@ -27,9 +27,7 @@
 import docking.action.DockingAction;
 import docking.action.DockingActionIf;
 import generic.timer.ExpiringSwingTimer;
-import ghidra.util.Msg;
 import ghidra.util.exception.AssertException;
-import utilities.util.reflection.ReflectionUtilities;
 
 /**
  * Class to hold information about a dockable component with respect to its position within the
@@ -118,16 +116,6 @@ boolean isHeaderShowing() {
 	 * @param node the component node containing this placeholder.
 	 */
 	void setNode(ComponentNode node) {
-
-		if (node != null && disposed) {
-			//
-			// TODO Hack Alert!  (When this is removed, also update ComponentNode)
-			//
-			// This should not happen!  We have seen this bug recently
-			Msg.debug(this, "Found disposed component that was not removed from the hierarchy " +
-				"list: " + this, ReflectionUtilities.createJavaFilteredThrowable());
-		}
-
 		compNode = node;
 	}
 
@@ -277,11 +265,18 @@ private void disposeComponent() {
 		comp = null;
 	}
 
+	/**
+	 * {@return true if this placeholder has a component that can take focus.  This placeholder 
+	 * cannot take focus if it does not yet have a DockableComponent.}
+	 */
+	boolean canTakeFocus() {
+		return comp != null;
+	}
+
 	void toFront() {
 		if (comp != null) {
 			compNode.makeSelectedTab(this);
 		}
-
 	}
 
 	/**
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
index a40ca33520a..47e91bbdd41 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
@@ -929,7 +929,6 @@ public synchronized void dispose() {
 	}
 
 	void showComponent(ComponentProvider provider, boolean visibleState, boolean shouldEmphasize) {
-
 		ComponentPlaceholder placeholder = getActivePlaceholder(provider);
 		if (placeholder != null) {
 			showComponent(placeholder, visibleState, true, shouldEmphasize);
@@ -993,7 +992,15 @@ void showComponent(ComponentPlaceholder placeholder, final boolean visibleState,
 	}
 
 	private void movePlaceholderToFront(ComponentPlaceholder placeholder, boolean emphasisze) {
-		placeholder.toFront();
+
+		if (!placeholder.canTakeFocus()) {
+			// If we move the parent window to the front when the placeholder is not ready, then
+			// some other placeholder will get focus when the window is activated, which we do not
+			// want to happen.  Later, when the placeholder is fully constructed, the window will 
+			// brought to the front.
+			return;
+		}
+
 		toFront(root.getWindow(placeholder));
 		if (emphasisze) {
 			placeholder.emphasize();
@@ -1519,6 +1526,7 @@ void setActive(Window window, boolean active) {
 		if (root == null) {
 			return;
 		}
+
 		actionToGuiMapper.setActive(active);
 		if (active) {
 			setActiveManager(this);
@@ -1540,6 +1548,7 @@ static void requestFocus(Component component) {
 			pendingRequestFocusComponent = null; // only do it once so that we don't get stuck in this state
 			return;
 		}
+
 		pendingRequestFocusComponent = component;
 		pendingRequestFocusComponent.requestFocus();
 	}
```
-----------------------------------
