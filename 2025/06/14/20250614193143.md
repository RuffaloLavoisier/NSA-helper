# Commit: 5ac69075e3b950f39960801bf6cd68c84a4638fd
## Message: GP-0: Fixing deprecated calls to Conv
## Diff:
```
diff --git a/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java b/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
index 94e58a27145..7dfca64accb 100644
--- a/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,7 +32,6 @@
 import ghidra.app.util.bin.format.pe.PortableExecutable.SectionLayout;
 import ghidra.app.util.bin.format.pe.RichHeader;
 import ghidra.app.util.bin.format.pe.rich.*;
-import ghidra.util.Conv;
 
 public class PortableExecutableRichPrintScript extends GhidraScript {
 
@@ -170,7 +169,7 @@ private static int checksumDosHeader(ByteProvider provider, int programLength)
 		data[0x3d] = 0;
 
 		for (int i = 0; i < DOSHeader.SIZEOF_DOS_HEADER + programLength; i++) {
-			int b = data[i] & Conv.BYTE_MASK;
+			int b = Byte.toUnsignedInt(data[i]);
 			checksum += rol32(b, (i & 0x1f));
 		}
 		return checksum;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/label/RemoveLabelAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/label/RemoveLabelAction.java
index a595a55188f..862076adefa 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/label/RemoveLabelAction.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/label/RemoveLabelAction.java
@@ -22,8 +22,6 @@
 import docking.action.*;
 import ghidra.app.context.ListingActionContext;
 import ghidra.app.context.ListingContextAction;
-import ghidra.program.database.symbol.CodeSymbol;
-import ghidra.program.database.symbol.FunctionSymbol;
 import ghidra.program.model.symbol.*;
 
 /**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTable.java
index 11de9e6d90e..3098e548129 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent a new-executable entry table.
@@ -37,7 +36,7 @@ public class EntryTable {
      */
 	EntryTable(BinaryReader reader, short index, short byteCount) throws IOException {
         long oldIndex = reader.getPointerIndex();
-        reader.setPointerIndex(Conv.shortToInt(index));
+		reader.setPointerIndex(Short.toUnsignedInt(index));
 
         ArrayList<EntryTableBundle> list = new ArrayList<EntryTableBundle>();
         while (true) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTableBundle.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTableBundle.java
index a7928bdfc3d..1de2cb37cb2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTableBundle.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/EntryTableBundle.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent a new-executable entry table bundle.
@@ -55,7 +54,7 @@ public class EntryTableBundle {
         type = reader.readNextByte();
         if (type == 0) return; //unused bundle...
 
-        int count_int = Conv.byteToInt(count);
+		int count_int = Byte.toUnsignedInt(count);
 
         entryPoints = new EntryPoint[count_int];
         for (int i = 0 ; i < count_int ; ++i) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ImportedNameTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ImportedNameTable.java
index 1b7d9d7959b..9b1e79a7630 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ImportedNameTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ImportedNameTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the new-executable imported name table.
@@ -49,7 +48,7 @@ public class ImportedNameTable {
      */
     public LengthStringSet getNameAt(short offset) throws IOException {
         long oldIndex = reader.getPointerIndex();
-        int newIndex = Conv.shortToInt(index)+Conv.shortToInt(offset);
+		int newIndex = Short.toUnsignedInt(index) + Short.toUnsignedInt(offset);
         reader.setPointerIndex(newIndex);
         LengthStringSet lss = new LengthStringSet(reader);
         reader.setPointerIndex(oldIndex);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java
index b074f927995..16683db187b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * <p>
@@ -198,7 +197,7 @@ public class InformationBlock {
 	InformationBlock(BinaryReader reader, short index)
 			throws InvalidWindowsHeaderException, IOException {
 		long oldIndex = reader.getPointerIndex();
-		reader.setPointerIndex(Conv.shortToInt(index));
+		reader.setPointerIndex(Short.toUnsignedInt(index));
 
 		ne_magic = reader.readNextShort();
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/LengthStringSet.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/LengthStringSet.java
index c2ff43e4266..6d4d4c787d3 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/LengthStringSet.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/LengthStringSet.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to store a length/string set,
@@ -34,16 +33,17 @@ public class LengthStringSet {
     private String name;
 
     /**
-     * Constructs a new length/string set.
-     * @param reader the binary reader
-     */
+	 * Constructs a new length/string set.
+	 * @param reader the binary reader
+	 * @throws IOException if there was an IO-related error
+	 */
 	LengthStringSet(BinaryReader reader) throws IOException {
         index = reader.getPointerIndex();
 
         length = reader.readNextByte();
         if (length == 0) return;
 
-        name = reader.readNextAsciiString(Conv.byteToInt(length)); //not null-terminated
+		name = reader.readNextAsciiString(Byte.toUnsignedInt(length)); //not null-terminated
     }
 
     /**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ModuleReferenceTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ModuleReferenceTable.java
index 1ca55925f3b..8175f272409 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ModuleReferenceTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ModuleReferenceTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the new-executable module reference table.
@@ -40,9 +39,9 @@ public class ModuleReferenceTable {
 	ModuleReferenceTable(BinaryReader reader, short index, short count, ImportedNameTable imp)
 			throws IOException {
         long oldIndex = reader.getPointerIndex();
-        reader.setPointerIndex(Conv.shortToInt(index));
+		reader.setPointerIndex(Short.toUnsignedInt(index));
 
-        offsets = new short[Conv.shortToInt(count)];
+		offsets = new short[Short.toUnsignedInt(count)];
         for (short i = 0 ; i < count ; ++i) {
             offsets[i] = reader.readNextShort();
         }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResidentNameTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResidentNameTable.java
index a4a639df8c0..61f9fba77c9 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResidentNameTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResidentNameTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the new-executable resident name table.
@@ -30,7 +29,7 @@ public class ResidentNameTable {
 
 	ResidentNameTable(BinaryReader reader, short index) throws IOException {
         long oldIndex = reader.getPointerIndex();
-        reader.setPointerIndex(Conv.shortToInt(index));
+        reader.setPointerIndex(Short.toUnsignedInt(index));
 
         ArrayList<LengthStringOrdinalSet> list = new ArrayList<LengthStringOrdinalSet>();
         while (true) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Resource.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Resource.java
index 4405e69f57c..4147060f2d4 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Resource.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Resource.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -131,8 +131,8 @@ public boolean isPreload() {
 	 * @return the shifted file offset of this resource
 	 */
 	public int getFileOffsetShifted() {
-		int shift_int = Conv.shortToInt(rt.getAlignmentShiftCount());
-		int offset_int = Conv.shortToInt(fileOffset);
+		int shift_int = Short.toUnsignedInt(rt.getAlignmentShiftCount());
+		int offset_int = Short.toUnsignedInt(fileOffset);
 		return offset_int << shift_int;
 	}
 
@@ -142,8 +142,8 @@ public int getFileOffsetShifted() {
 	 * @return the shifted file length of this resource
 	 */
 	public int getFileLengthShifted() {
-		int shift_int = Conv.shortToInt(rt.getAlignmentShiftCount());
-		int length_int = Conv.shortToInt(fileLength);
+		int shift_int = Short.toUnsignedInt(rt.getAlignmentShiftCount());
+		int length_int = Short.toUnsignedInt(fileLength);
 		return length_int << shift_int;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceStringTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceStringTable.java
index 710cc446d13..3b06f080392 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceStringTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceStringTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class for storing new-executable resource string tables.
@@ -33,9 +32,10 @@ public class ResourceStringTable extends Resource {
     private LengthStringSet [] strings;
 
 	/**
-	 * Constucts a new resource string table.
+	 * Constructs a new resource string table.
 	 * @param reader the binary reade
 	 * @param rt the resource table where this resource string table is defined
+	 * @throws IOException if there was an IO-related error
 	 */
 	ResourceStringTable(BinaryReader reader, ResourceTable rt) throws IOException {
         super(reader, rt);
@@ -49,7 +49,7 @@ public class ResourceStringTable extends Resource {
                 LengthStringSet lss = new LengthStringSet(reader);
                 if (lss.getLength() == 0) break;
                 list.add(lss);
-                i += (Conv.byteToInt(lss.getLength())+1);
+				i += (Byte.toUnsignedInt(lss.getLength()) + 1);
                 reader.setPointerIndex(oldIndex);
             }
             else {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceTable.java
index 15e77283506..1eb9f6b5184 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class for storing the new-executable resource table.
@@ -44,7 +43,7 @@ public class ResourceTable {
         this.index = index;
 
         long oldIndex = reader.getPointerIndex();
-        reader.setPointerIndex(Conv.shortToInt(index));
+        reader.setPointerIndex(Short.toUnsignedInt(index));
 
         alignmentShiftCount = reader.readNextShort();
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceType.java
index 011da7e9f6c..a7f43a580e7 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceType.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/ResourceType.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * An implementation of the TTYPEINFO structure.
@@ -80,7 +79,7 @@ public class ResourceType {
 
 		ArrayList<Resource> list = new ArrayList<Resource>();
 
-		int count_int = Conv.shortToInt(count);
+		int count_int = Short.toUnsignedInt(count);
 		for (int i = 0; i < count_int; ++i) {
 			if ((short) (typeID & 0x7fff) == RT_STRING) {
 				list.add(new ResourceStringTable(reader, rt));
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Segment.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Segment.java
index faec08a28bd..4582553924f 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Segment.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/Segment.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent a new-executable segment.
@@ -69,11 +68,11 @@ public class Segment {
         flagword     = reader.readNextShort();
         minAllocSize = reader.readNextShort();
 
-        offsetAlign  = Conv.shortToInt(offset) * Conv.shortToInt(segmentAlignment);
+        offsetAlign  = Short.toUnsignedInt(offset) * Short.toUnsignedInt(segmentAlignment);
 
         ArrayList<SegmentRelocation> list = new ArrayList<SegmentRelocation>();
         if (hasRelocation()) {
-            int relocPos = offsetAlign + Conv.shortToInt(length);
+            int relocPos = offsetAlign + Short.toUnsignedInt(length);
 
             long oldIndex = reader.getPointerIndex();
             reader.setPointerIndex(relocPos);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/SegmentTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/SegmentTable.java
index 925a3669a82..9da5e7b2a26 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/SegmentTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/SegmentTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,6 @@
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.program.model.address.SegmentedAddress;
 import ghidra.program.model.address.SegmentedAddressSpace;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the new-executable segment table.
@@ -32,12 +31,12 @@ public class SegmentTable {
 	SegmentTable(BinaryReader reader, SegmentedAddress baseAddr, short index, short segmentCount,
 			short shiftAlignCount) throws IOException {
         long oldIndex = reader.getPointerIndex();
-        reader.setPointerIndex(Conv.shortToInt(index));
+        reader.setPointerIndex(Short.toUnsignedInt(index));
 
         //create a value of the shift count...
         shiftAlignCount = (short)(0x01 << shiftAlignCount);
 
-        int segmentCountInt = Conv.shortToInt(segmentCount);
+        int segmentCountInt = Short.toUnsignedInt(segmentCount);
 
         segments = new Segment[segmentCountInt];
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java
index b65bba65b88..20e09b991b4 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ClassRW.java
@@ -15,17 +15,16 @@
  */
 package ghidra.app.util.bin.format.objc2;
 
+import java.io.IOException;
+
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.objectiveC.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.symbol.Namespace;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
-import java.io.IOException;
-
 public class ObjectiveC2_ClassRW implements StructConverter {
 	public final static String NAME = "class_rw_t";
 
@@ -51,15 +50,15 @@ public ObjectiveC2_ClassRW(ObjectiveC2_State state, BinaryReader reader) throws
 		this._index = reader.getPointerIndex();
 
 		if (state.is32bit) {
-			flags         = reader.readNextInt() & Conv.INT_MASK;
-			instanceStart = reader.readNextInt() & Conv.INT_MASK;
-			instanceSize  = reader.readNextInt() & Conv.INT_MASK;
-			reserved      = reader.readNextInt() & Conv.INT_MASK;
+			flags = reader.readNextUnsignedInt();
+			instanceStart = reader.readNextUnsignedInt();
+			instanceSize = reader.readNextUnsignedInt();
+			reserved = reader.readNextUnsignedInt();
 		}
 		else {
-			flags         = reader.readNextLong();
+			flags = reader.readNextLong();
 			instanceStart = reader.readNextLong();
-			instanceSize  = reader.readNextLong();
+			instanceSize = reader.readNextLong();
 		}
 
 		readName(reader);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java
index a390618938c..f9965436cf6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Implementation.java
@@ -21,7 +21,6 @@
 import ghidra.app.util.bin.StructConverter;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.TypedefDataType;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
 public class ObjectiveC2_Implementation implements StructConverter {
@@ -42,7 +41,7 @@ public ObjectiveC2_Implementation(ObjectiveC2_State state, BinaryReader reader,
 		}
 		else {
 			if (state.is32bit) {
-				imp = reader.readNextInt() & Conv.INT_MASK;
+				imp = reader.readNextUnsignedInt();
 			}
 			else {
 				imp = reader.readNextLong();
@@ -75,6 +74,7 @@ else if (_is32bit) {
 	}
 
 	public void applyTo() throws Exception {
+		// do nothing
 	}
 
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java
index 7c315ca9e52..3dcee0386eb 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_InstanceVariable.java
@@ -15,17 +15,16 @@
  */
 package ghidra.app.util.bin.format.objc2;
 
+import java.io.IOException;
+
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.symbol.Namespace;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
-import java.io.IOException;
-
 public class ObjectiveC2_InstanceVariable implements StructConverter {
 	private ObjectiveC2_State _state;
 
@@ -39,7 +38,7 @@ public ObjectiveC2_InstanceVariable(ObjectiveC2_State state, BinaryReader reader
 		this._state = state;
 
 		if (state.is32bit) {
-			offset = reader.readNextInt() & Conv.INT_MASK;
+			offset = reader.readNextUnsignedInt();
 		}
 		else {
 			offset = reader.readNextLong();
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java
index ab26fc56d1f..15ac5e544c2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_MessageReference.java
@@ -15,15 +15,14 @@
  */
 package ghidra.app.util.bin.format.objc2;
 
+import java.io.IOException;
+
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Utilities;
 import ghidra.program.model.data.*;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
-import java.io.IOException;
-
 public class ObjectiveC2_MessageReference implements StructConverter {
 	public static final String NAME = "message_ref";
 
@@ -40,7 +39,7 @@ public ObjectiveC2_MessageReference(ObjectiveC2_State state, BinaryReader reader
 		this._state = state;
 
 		if (state.is32bit) {
-			implementation = reader.readNextInt() & Conv.INT_MASK;
+			implementation = reader.readNextUnsignedInt();
 		}
 		else {
 			implementation = reader.readNextLong();
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java
index b84798cdeff..f1ffeb0042e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Protocol.java
@@ -15,17 +15,16 @@
  */
 package ghidra.app.util.bin.format.objc2;
 
+import java.io.IOException;
+
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.objectiveC.*;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.symbol.Namespace;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
-import java.io.IOException;
-
 public class ObjectiveC2_Protocol implements StructConverter {
 	public final static String NAME = "protocol_t";
 
@@ -58,8 +57,8 @@ public ObjectiveC2_Protocol(ObjectiveC2_State state, BinaryReader reader) throws
 		readInstanceProperties(reader);
 
 		if (state.is32bit) {
-			unknown0 = reader.readNextInt() & Conv.INT_MASK;
-			unknown1 = reader.readNextInt() & Conv.INT_MASK;
+			unknown0 = reader.readNextUnsignedInt();
+			unknown1 = reader.readNextUnsignedInt();
 		}
 		else {
 			unknown0 = reader.readNextLong();
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java
index 913285e6c75..6386b19d215 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_ProtocolList.java
@@ -26,7 +26,6 @@
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
 import ghidra.program.model.symbol.Namespace;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
 public class ObjectiveC2_ProtocolList implements StructConverter {
@@ -41,7 +40,7 @@ public ObjectiveC2_ProtocolList(ObjectiveC2_State state, BinaryReader reader) th
 		this._state = state;
 		this._index = reader.getPointerIndex();
 
-		long count = state.is32bit ? reader.readNextInt() & Conv.INT_MASK : reader.readNextLong();
+		long count = state.is32bit ? reader.readNextUnsignedInt() : reader.readNextLong();
 
 		for (long i = 0 ; i < count ; ++i) {
 			long protocolIndex = ObjectiveC1_Utilities.readNextIndex(reader, state.is32bit);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java
index 49c892e6299..72e133b4489 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Utilities.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,7 +25,6 @@
 import ghidra.program.model.mem.Memory;
 import ghidra.program.model.mem.MemoryBlock;
 import ghidra.program.model.symbol.*;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 import ghidra.util.exception.InvalidInputException;
 
@@ -37,7 +36,7 @@ final class ObjectiveC2_Utilities {
 	 */
 	static long readNextIndex(BinaryReader reader, boolean is32bit) throws IOException {
 		if (is32bit) {
-			return reader.readNextInt() & Conv.INT_MASK;
+			return reader.readNextUnsignedInt();
 		}
 		return reader.readNextLong();
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java
index ba77697b8a0..3654d8796ca 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Method.java
@@ -15,13 +15,12 @@
  */
 package ghidra.app.util.bin.format.objectiveC;
 
+import java.io.IOException;
+
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.program.model.data.*;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
-import java.io.IOException;
-
 public class ObjectiveC1_Method extends ObjectiveC_Method {
 	private String name;
 	private String signature;
@@ -45,7 +44,7 @@ public String getTypes() {
 	}
 	@Override
 	public long getImplementation() {
-		return address & Conv.INT_MASK;
+		return Integer.toUnsignedLong(address);
 	}
 
 	@Override
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java
index 1d2021ff7a5..318af1ef62c 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC1_Utilities.java
@@ -39,7 +39,8 @@
 import ghidra.program.model.mem.MemoryBlock;
 import ghidra.program.model.symbol.*;
 import ghidra.program.model.util.CodeUnitInsertionException;
-import ghidra.util.*;
+import ghidra.util.Msg;
+import ghidra.util.StringUtilities;
 import ghidra.util.exception.DuplicateNameException;
 import ghidra.util.exception.InvalidInputException;
 
@@ -59,7 +60,7 @@ public static void clear(ObjectiveC2_State state, MemoryBlock block) throws Exce
 	 */
 	public static long readNextIndex(BinaryReader reader, boolean is32bit) throws IOException {
 		if (is32bit) {
-			return reader.readNextInt() & Conv.INT_MASK;
+			return reader.readNextUnsignedInt();
 		}
 		return reader.readNextLong();
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFLineNumber.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFLineNumber.java
index c66138f41a1..a95778c6d83 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFLineNumber.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFLineNumber.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the COFF Line number data structure.
@@ -47,7 +46,7 @@ public DebugCOFFLineNumber(BinaryReader reader, int index) throws IOException {
         symbolTableIndex = reader.readInt(index);
         virtualAddress   = reader.readInt(index);
         index += BinaryReader.SIZEOF_INT;
-		lineNumber = Conv.shortToInt(reader.readShort(index));
+		lineNumber = Short.toUnsignedInt(reader.readShort(index));
     }
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbol.java
index 3c194a704c0..c961c5b4873 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbol.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbol.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 
 import ghidra.app.util.bin.*;
 import ghidra.program.model.data.*;
-import ghidra.util.Conv;
 import ghidra.util.exception.DuplicateNameException;
 
 /**
@@ -158,7 +157,7 @@ public DebugCOFFSymbol(BinaryReader reader, int index, long stringTableIndex)
         numberOfAuxSymbols = reader.readByte (index); index += BinaryReader.SIZEOF_BYTE;
 
         // process auxiliary symbols...
-        auxSymbols = new DebugCOFFSymbolAux[Conv.byteToInt(numberOfAuxSymbols)];
+		auxSymbols = new DebugCOFFSymbolAux[Byte.toUnsignedInt(numberOfAuxSymbols)];
 
         for (int i = 0 ; i < numberOfAuxSymbols ; ++i) {
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugMisc.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugMisc.java
index aea4bf97b59..ddaad89ca02 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugMisc.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugMisc.java
@@ -21,7 +21,6 @@
 import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.pe.OffsetValidator;
 import ghidra.program.model.data.*;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 import ghidra.util.exception.DuplicateNameException;
 
@@ -68,7 +67,7 @@ public class DebugMisc implements StructConverter {
 
 		long oldIndex = reader.getPointerIndex();
 
-		long index = debugDir.getPointerToRawData() & Conv.INT_MASK;
+		long index = Integer.toUnsignedLong(debugDir.getPointerToRawData());
 		if (!validator.checkPointer(index)) {
 			Msg.error(this, "Invalid file index " + Long.toHexString(index));
 			return;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFFileIndex.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFFileIndex.java
index da93c758be7..ba48fee572e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFFileIndex.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFFileIndex.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) File Index data structure.
@@ -51,31 +50,31 @@ public class OMFFileIndex {
 		cRef = reader.readShort(index);
 		index += BinaryReader.SIZEOF_SHORT;
 
-		modStart = new short[Conv.shortToInt(cMod)];
+		modStart = new short[Short.toUnsignedInt(cMod)];
 		for (int i = 0; i < cMod; ++i) {
 			modStart[i] = reader.readShort(index);
 			index += BinaryReader.SIZEOF_SHORT;
 		}
 
-		cRefCnt = new short[Conv.shortToInt(cMod)];
+		cRefCnt = new short[Short.toUnsignedInt(cMod)];
 		for (int i = 0; i < cMod; i++) {
 			cRefCnt[i] = reader.readShort(index);
 			index += BinaryReader.SIZEOF_SHORT;
 		}
 
-		nameRef = new int[Conv.shortToInt(cRef)];
+		nameRef = new int[Short.toUnsignedInt(cRef)];
 		for (int i = 0; i < cRef; ++i) {
 			nameRef[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 		}
 
 		ArrayList<String> namesList = new ArrayList<String>();
-		for (int i = 0; i < Conv.shortToInt(cRef); ++i) {
+		for (int i = 0; i < Short.toUnsignedInt(cRef); ++i) {
 			int nameIndex = index + nameRef[i];
 
 			byte len = reader.readByte(nameIndex);
 			nameIndex += BinaryReader.SIZEOF_BYTE;
-			int length = Conv.byteToInt(len);
+			int length = Byte.toUnsignedInt(len);
 
 			String name = reader.readAsciiString(nameIndex, length);
 			namesList.add(name);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFGlobal.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFGlobal.java
index 1be34e44043..edbc92b97cd 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFGlobal.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFGlobal.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,6 @@
 import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) Global data structure.
@@ -57,7 +56,7 @@ public class OMFGlobal {
 			if (sym != null) {
 				symbols.add(sym);
 
-				int recLen = Conv.shortToInt(sym.getLength());
+				int recLen = Short.toUnsignedInt(sym.getLength());
 				bytesLeft -= recLen;
 				ptr += recLen - 2;
 			}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFLibrary.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFLibrary.java
index 55b69e471d2..cdbbccf7d31 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFLibrary.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFLibrary.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) Library data structure.
@@ -34,7 +33,7 @@ public class OMFLibrary {
 			byte len = reader.readByte(ptr);
 			ptr += BinaryReader.SIZEOF_BYTE;
 			numBytes -= BinaryReader.SIZEOF_BYTE;
-			int length = Conv.byteToInt(len);
+			int length = Byte.toUnsignedInt(len);
 			String lib = reader.readAsciiString(ptr, length);
 			ptr += length;
 			numBytes -= length;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModule.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModule.java
index a3557c34e3f..24f6589def8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModule.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModule.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) Source Module data structure.
@@ -55,29 +54,29 @@ public class OMFSrcModule {
 		cSeg = reader.readShort(index);
 		index += BinaryReader.SIZEOF_SHORT;
 
-		baseSrcFile = new int[Conv.shortToInt(cFile)];
-		for (int i = 0; i < Conv.shortToInt(cFile); ++i) {
+		baseSrcFile = new int[Short.toUnsignedInt(cFile)];
+		for (int i = 0; i < Short.toUnsignedInt(cFile); ++i) {
 			baseSrcFile[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 		}
 
-		starts = new int[Conv.shortToInt(cSeg)];
-		ends = new int[Conv.shortToInt(cSeg)];
+		starts = new int[Short.toUnsignedInt(cSeg)];
+		ends = new int[Short.toUnsignedInt(cSeg)];
 
-		for (int i = 0; i < Conv.shortToInt(cSeg); ++i) {
+		for (int i = 0; i < Short.toUnsignedInt(cSeg); ++i) {
 			starts[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 			ends[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 		}
 
-		segs = new short[Conv.shortToInt(cSeg)];
-		for (int i = 0; i < Conv.shortToInt(cSeg); ++i) {
+		segs = new short[Short.toUnsignedInt(cSeg)];
+		for (int i = 0; i < Short.toUnsignedInt(cSeg); ++i) {
 			segs[i] = reader.readShort(index);
 			index += BinaryReader.SIZEOF_SHORT;
 		}
 
-		for (int i = 0; i < Conv.shortToInt(cFile); ++i) {
+		for (int i = 0; i < Short.toUnsignedInt(cFile); ++i) {
 			moduleFileList.add(new OMFSrcModuleFile(reader, ptr, ptr + baseSrcFile[i]));
 		}
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleFile.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleFile.java
index 64d6d1ef4ff..f0595d34ebb 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleFile.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleFile.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,12 +15,10 @@
  */
 package ghidra.app.util.bin.format.pe.debug;
 
-import java.util.ArrayList;
-
 import java.io.IOException;
+import java.util.ArrayList;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) Source Module File data structure. 
@@ -62,16 +60,16 @@ public class OMFSrcModuleFile {
 		pad = reader.readShort(index);
 		index += BinaryReader.SIZEOF_SHORT;
 
-		baseSrcLn = new int[Conv.shortToInt(cSeg)];
+		baseSrcLn = new int[Short.toUnsignedInt(cSeg)];
 		for (int i = 0; i < cSeg; ++i) {
 			baseSrcLn[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 		}
 
-		starts = new int[Conv.shortToInt(cSeg)];
-		ends = new int[Conv.shortToInt(cSeg)];
+		starts = new int[Short.toUnsignedInt(cSeg)];
+		ends = new int[Short.toUnsignedInt(cSeg)];
 
-		for (int i = 0; i < Conv.shortToInt(cSeg); ++i) {
+		for (int i = 0; i < Short.toUnsignedInt(cSeg); ++i) {
 			starts[i] = reader.readInt(index);
 			index += BinaryReader.SIZEOF_INT;
 			ends[i] = reader.readInt(index);
@@ -84,7 +82,7 @@ public class OMFSrcModuleFile {
 		name = reader.readAsciiString(index, Byte.toUnsignedInt(cbName));
 		index += Byte.toUnsignedInt(cbName);
 
-		for (int i = 0; i < Conv.shortToInt(cSeg); ++i) {
+		for (int i = 0; i < Short.toUnsignedInt(cSeg); ++i) {
 			//OMFSrcModuleLine line = new OMFSrcModuleLine(reader, index);
 			OMFSrcModuleLine line = new OMFSrcModuleLine(reader, moduleBase + baseSrcLn[i]);
 			moduleLineList.add(line);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleLine.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleLine.java
index a5a9a484a13..969dddf5a02 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleLine.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/OMFSrcModuleLine.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the Object Module Format (OMF) Source Module Line data structure.
@@ -45,13 +44,13 @@ public class OMFSrcModuleLine {
 		seg   = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
 		cPair = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
 		
-		offsets = new int[Conv.shortToInt(cPair)];
-		for (int i = 0 ; i < Conv.shortToInt(cPair) ; ++i) {
+		offsets = new int[Short.toUnsignedInt(cPair)];
+		for (int i = 0 ; i < Short.toUnsignedInt(cPair) ; ++i) {
 			offsets[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
 		}
 		
-		linenumbers = new short[Conv.shortToInt(cPair)];
-		for (int i = 0 ; i < Conv.shortToInt(cPair) ; ++i) {
+		linenumbers = new short[Short.toUnsignedInt(cPair)];
+		for (int i = 0 ; i < Short.toUnsignedInt(cPair) ; ++i) {
 			linenumbers[i] = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
 		}
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_BPREL32_NEW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_BPREL32_NEW.java
index c04fe621399..3231723eb67 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_BPREL32_NEW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_BPREL32_NEW.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 /**
  * A class to represent the S_BPREL32_NEW data structure.
@@ -41,7 +40,7 @@ public class S_BPREL32_NEW extends DebugSymbol {
 		byte nameLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
 
-		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 	}
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_CONSTANT32.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_CONSTANT32.java
index 2f6cb6c50d3..4267cb31b40 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_CONSTANT32.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_CONSTANT32.java
@@ -18,10 +18,10 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_CONSTANT32 extends DebugSymbol {
 
+	@SuppressWarnings("unused")
 	S_CONSTANT32(short length, short type, BinaryReader reader, int ptr) throws IOException {
 		processDebugSymbol(length, type);
 
@@ -33,7 +33,7 @@ class S_CONSTANT32 extends DebugSymbol {
 		byte nameLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
 
-		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 	}
 
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_GDATA32_NEW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_GDATA32_NEW.java
index 06bf3dbd94c..b8dbb072b05 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_GDATA32_NEW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_GDATA32_NEW.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 class S_GDATA32_NEW extends DebugSymbol {
@@ -37,7 +36,7 @@ class S_GDATA32_NEW extends DebugSymbol {
 		byte nameLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
 
-		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 
 		Msg.debug(this, "S_DATA32_NEW: " + unknown);
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LABEL32.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LABEL32.java
index c7b96a7f26c..9b5b9e4c707 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LABEL32.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LABEL32.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 class S_LABEL32 extends DebugSymbol {
@@ -36,7 +35,7 @@ class S_LABEL32 extends DebugSymbol {
 
 		byte nameLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
-		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 		Msg.debug(this, "Created label symbol: " + name);
     }
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LDATA32_NEW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LDATA32_NEW.java
index 5c0f8c01dd1..2f83d933c89 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LDATA32_NEW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_LDATA32_NEW.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_LDATA32_NEW extends DebugSymbol{
     private int reserved;
@@ -35,13 +34,13 @@ class S_LDATA32_NEW extends DebugSymbol{
 		this.name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 		ptr += Byte.toUnsignedInt(nameLen);
 
-		int sizeOfPadding = Conv.shortToInt(length) - 
-							BinaryReader.SIZEOF_SHORT - 
-							BinaryReader.SIZEOF_INT - 
-							BinaryReader.SIZEOF_INT - 
-							BinaryReader.SIZEOF_SHORT - 
-							BinaryReader.SIZEOF_BYTE - 
-							Conv.byteToInt(nameLen);
+		int sizeOfPadding = Short.toUnsignedInt(length) -
+			BinaryReader.SIZEOF_SHORT -
+			BinaryReader.SIZEOF_INT -
+			BinaryReader.SIZEOF_INT -
+			BinaryReader.SIZEOF_SHORT -
+			BinaryReader.SIZEOF_BYTE -
+			Byte.toUnsignedInt(nameLen);
 		
 		padding = reader.readByteArray(ptr, sizeOfPadding);
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_OBJNAME.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_OBJNAME.java
index 4065bbf5450..afe76b36f49 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_OBJNAME.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_OBJNAME.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_OBJNAME extends DebugSymbol {
     private int signature;
@@ -33,12 +32,12 @@ class S_OBJNAME extends DebugSymbol {
 		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 		ptr += Byte.toUnsignedInt(nameLen) + 1;
 
-		int sizeOfPadding = BinaryReader.SIZEOF_SHORT+ 
-							BinaryReader.SIZEOF_INT+
-							BinaryReader.SIZEOF_INT+
-							BinaryReader.SIZEOF_INT+
-							BinaryReader.SIZEOF_BYTE+
-							Conv.byteToInt(nameLen)+1;
+		int sizeOfPadding = BinaryReader.SIZEOF_SHORT +
+			BinaryReader.SIZEOF_INT +
+			BinaryReader.SIZEOF_INT +
+			BinaryReader.SIZEOF_INT +
+			BinaryReader.SIZEOF_BYTE +
+			Byte.toUnsignedInt(nameLen) + 1;
 
 		padding = reader.readByteArray(ptr, sizeOfPadding);
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_PROCREF.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_PROCREF.java
index 691205739b4..530340de3ca 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_PROCREF.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_PROCREF.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_PROCREF extends DebugSymbol {
     private int module;
@@ -39,9 +38,9 @@ class S_PROCREF extends DebugSymbol {
 		if (checksum == 0) {
 			byte nameLen = reader.readByte (ptr); ptr += BinaryReader.SIZEOF_BYTE;
 
-			name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+			name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 
-			ptr += Conv.byteToInt(nameLen);
+			ptr += Byte.toUnsignedInt(nameLen);
 
 			int val = ptr & 0xf; 
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32.java
index 6ad17f02201..332afc88edc 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_UDT32 extends DebugSymbol {
     private int checksum;
@@ -35,7 +34,7 @@ class S_UDT32 extends DebugSymbol {
 		ptr += BinaryReader.SIZEOF_INT;
 		this.typeLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
-		this.name = reader.readAsciiString(ptr, Conv.byteToInt(typeLen));
+		this.name = reader.readAsciiString(ptr, Byte.toUnsignedInt(typeLen));
 	}
 
 	public int getChecksum() {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32_NEW.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32_NEW.java
index c84c74c5d86..bdef427a545 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32_NEW.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/S_UDT32_NEW.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 
 class S_UDT32_NEW extends DebugSymbol {
     private int symType;
@@ -32,7 +31,7 @@ class S_UDT32_NEW extends DebugSymbol {
 		byte nameLen = reader.readByte(ptr);
 		ptr += BinaryReader.SIZEOF_BYTE;
 
-		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
+		name = reader.readAsciiString(ptr, Byte.toUnsignedInt(nameLen));
 	}
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/UnknownSymbol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/UnknownSymbol.java
index 37b0f743303..3c5d29db0b5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/UnknownSymbol.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/UnknownSymbol.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 
 import ghidra.app.util.bin.BinaryReader;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 class UnknownSymbol extends DebugSymbol{
@@ -27,7 +26,7 @@ class UnknownSymbol extends DebugSymbol{
 	UnknownSymbol(short length, short type, BinaryReader reader, int ptr) throws IOException {
 		processDebugSymbol(length, type);
 		try {
-			unknown = reader.readByteArray(ptr, Conv.shortToInt(length));
+			unknown = reader.readByteArray(ptr, Short.toUnsignedInt(length));
 		}
 		catch (RuntimeException e) {
 		    Msg.error(this, "Unexpected Exception: " + e.getMessage(), e);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractPeDebugLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractPeDebugLoader.java
index 0a6e29fb2fb..56459113cf8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractPeDebugLoader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractPeDebugLoader.java
@@ -234,7 +234,7 @@ private void processDebugCodeView(DebugCodeView dcv, NTHeader ntHeader,
 
 				Address address = sectionToAddress.get(fileHeader.getSectionHeader(segVal - 1));
 				if (address != null) {
-					address = address.add(Conv.intToLong(offVal));
+					address = address.add(Integer.toUnsignedLong(offVal));
 
 					try {
 						symTable.createLabel(address, name, SourceType.IMPORTED);
@@ -293,11 +293,11 @@ private void processFiles(OMFSrcModuleFile file, short[] segments, FileHeader fi
 				continue;
 			}
 
-			Address startAddr = addr.add(Conv.intToLong(starts[k]));
+			Address startAddr = addr.add(Integer.toUnsignedLong(starts[k]));
 			String cmt = "START-> " + file.getName() + ": " + "?";
 			setComment(CommentType.PRE, startAddr, cmt);
 
-			Address endAddr = addr.add(Conv.intToLong(ends[k]));
+			Address endAddr = addr.add(Integer.toUnsignedLong(ends[k]));
 			cmt = "END-> " + file.getName() + ": " + "?";
 			setComment(CommentType.PRE, endAddr, cmt);
 
@@ -327,8 +327,8 @@ private void processLineNumbers(FileHeader fileHeader,
 						return;
 					}
 					if (offsets[j] > 0) {
-						addLineComment(addr.add(Conv.intToLong(offsets[j])),
-							Conv.shortToInt(lineNumbers[j]));
+						addLineComment(addr.add(Integer.toUnsignedLong(offsets[j])),
+							Short.toUnsignedInt(lineNumbers[j]));
 					}
 				}
 			}
@@ -372,7 +372,8 @@ private void processDebugCOFF(DebugCOFFSymbolsHeader dcsh, NTHeader ntHeader,
 				}
 				else {
 					addLineComment(
-						program.getImageBase().add(Conv.intToLong(lineNumber.getVirtualAddress())),
+						program.getImageBase()
+								.add(Integer.toUnsignedLong(lineNumber.getVirtualAddress())),
 						lineNumber.getLineNumber());
 				}
 			}
@@ -502,18 +503,14 @@ private void addLineComment(Address addr, int line) {
 	}
 
 	protected boolean hasComment(CommentType type, Address address) {
-		switch (type) {
-			case PLATE:
-				return plateCommentMap.get(address) != null;
-			case PRE:
-				return preCommentMap.get(address) != null;
-			case POST:
-				return postCommentMap.get(address) != null;
-			case EOL:
-				return eolCommentMap.get(address) != null;
-			default:
-				throw new IllegalArgumentException("Unsupported comment type: " + type.name());
-		}
+		return switch (type) {
+			case PLATE -> plateCommentMap.get(address) != null;
+			case PRE -> preCommentMap.get(address) != null;
+			case POST -> postCommentMap.get(address) != null;
+			case EOL -> eolCommentMap.get(address) != null;
+			default -> throw new IllegalArgumentException(
+				"Unsupported comment type: " + type.name());
+		};
 	}
 
 	protected void setComment(CommentType type, Address address, String comment) {
@@ -550,11 +547,9 @@ protected void setComment(CommentType type, Address address, String comment) {
 			default:
 				throw new IllegalArgumentException("Unsupported comment type: " + type.name());
 		}
-		if (buffer != null) {
-			if (buffer.length() > 0) {
-				buffer.append('\n');
-			}
-			buffer.append(comment);
+		if (buffer.length() > 0) {
+			buffer.append('\n');
 		}
+		buffer.append(comment);
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DbgLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DbgLoader.java
index d3f4d59fe3f..a65fc3166b5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DbgLoader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DbgLoader.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,7 +27,6 @@
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.listing.Program;
-import ghidra.util.Conv;
 import ghidra.util.task.TaskMonitor;
 
 /**
@@ -55,7 +54,7 @@ public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws
 		}
 		SeparateDebugHeader debug = new SeparateDebugHeader(provider);
 		if (debug.getSignature() == SeparateDebugHeader.IMAGE_SEPARATE_DEBUG_SIGNATURE) {
-			long imageBase = Conv.intToLong(debug.getImageBase());
+			long imageBase = Integer.toUnsignedLong(debug.getImageBase());
 			String machineName = debug.getMachineName();
 			for (QueryResult result : QueryOpinionService.query(getName(), machineName, null)) {
 				loadSpecs.add(new LoadSpec(this, imageBase, result));
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/listing/ExternalProgramMergerTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/listing/ExternalProgramMergerTest.java
index de4311f5040..8e71eec575d 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/listing/ExternalProgramMergerTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/listing/ExternalProgramMergerTest.java
@@ -17,7 +17,6 @@
 
 import static org.junit.Assert.*;
 
-import java.io.File;
 import java.util.Arrays;
 
 import org.junit.Assert;
@@ -35,10 +34,6 @@
  */
 public class ExternalProgramMergerTest extends AbstractListingMergeManagerTest {
 
-	/**
-	 *
-	 * @param arg0
-	 */
 	public ExternalProgramMergerTest() {
 		super();
 	}
@@ -422,7 +417,6 @@ public void testRemoveLibRenameExtSymConflictRemoveBoth() throws Exception {
 			public void modifyLatest(ProgramDB program) {
 				try {
 					removeExternalLibrary(program, "ADVAPI32.DLL");
-					String[] names = program.getExternalManager().getExternalLibraryNames();
 					Reference[] refs =
 						program.getReferenceManager().getReferencesFrom(addr(program, "0x10011e4")); // SetCursor
 					SymbolTable symTab = program.getSymbolTable();
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
index e1c251fd142..c6126275e00 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,7 +24,6 @@
 import ghidra.program.model.scalar.Scalar;
 import ghidra.program.model.symbol.RefType;
 import ghidra.program.model.symbol.Reference;
-import ghidra.util.Conv;
 
 public class ResolveReferencesRelativeToEbxScript extends GhidraScript {
 
@@ -91,7 +89,8 @@ private void loopOverInstructionsInFunction(Function function) {
 
 						if ( register.equals( EBX ) ) {
 
-							Address address = toAddr( (ebx + scalar.getUnsignedValue()) & Conv.INT_MASK );
+							Address address =
+								toAddr((ebx + scalar.getUnsignedValue()) & 0x00000000ffffffffL);
 
 							if ( isValid( address ) ) {
 
diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbUtil.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbUtil.java
index 189b144213a..17c1adcdf9d 100644
--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbUtil.java
+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbUtil.java
@@ -23,7 +23,6 @@
 import ghidra.program.model.data.Structure;
 import ghidra.program.model.listing.CommentType;
 import ghidra.program.model.listing.Program;
-import ghidra.util.Conv;
 
 final class PdbUtil {
 
@@ -34,7 +33,7 @@ final class PdbUtil {
 	 * @return the calculated {@link Address}
 	 */
 	final static Address reladdr(Program program, int relativeOffset) {
-		return reladdr(program, relativeOffset & Conv.INT_MASK);
+		return reladdr(program, Integer.toUnsignedLong(relativeOffset));
 	}
 
 	/**
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/Conv.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/Conv.java
index 322fc795a3f..bb0a8bf2edb 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/Conv.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/Conv.java
@@ -48,16 +48,16 @@ private Conv() {
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static final long INT_MASK = 0x00000000ffffffffL;
 
-    /**
+	/**
 	 * @param b the byte
 	 * @return the short equivalent of the byte
 	 * @deprecated Use other built-ins like {@link Byte#toUnsignedInt(byte)}
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static short byteToShort(byte b) {
-        return (short)(b & BYTE_MASK);
-    }
-    
+		return (short) (b & 0xff);
+	}
+
 	/**
 	 * Converts a byte to an integer.
 	 * 
@@ -67,9 +67,9 @@ public static short byteToShort(byte b) {
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static int byteToInt(byte b) {
-        return (b & BYTE_MASK);
-    }
-    
+		return Byte.toUnsignedInt(b);
+	}
+
 	/**
 	 * Converts a byte to a long.
 	 * @param b the byte
@@ -78,8 +78,8 @@ public static int byteToInt(byte b) {
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static long byteToLong(byte b) {
-        return intToLong(b & BYTE_MASK);
-    }
+		return Byte.toUnsignedLong(b);
+	}
     
 	/**
 	 * Converts a short to an integer.
@@ -89,18 +89,18 @@ public static long byteToLong(byte b) {
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static int shortToInt(short s) {
-        return (s & SHORT_MASK);
-    }
+		return Short.toUnsignedInt(s);
+	}
     
 	/**
 	 * Converts a short to a long.
 	 * @param s the short
-	 * @return the long eqivalent of the short
+	 * @return the long equivalent of the short
 	 * @deprecated Use {@link Short#toUnsignedLong(short)} instead
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static long shortToLong(short s) {
-        return intToLong(s & SHORT_MASK);
+		return Short.toUnsignedLong(s);
     }
     
 	/**
@@ -111,26 +111,25 @@ public static long shortToLong(short s) {
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static long intToLong(int i) {
-        return (i & INT_MASK);
+		return Integer.toUnsignedLong(i);
     }
 
 	/**
-	 * <p>
 	 * Old and <b>incorrect</b> way to convert bytes to a String by casting their
 	 * values to chars.  Do not use.  Does not seem to be used in current codebase.
 	 * 
-	 * @param array
-	 * @return
+	 * @param array The bytes to convert
+	 * @return The converted bytes
 	 * @deprecated Use {@link String#String(byte[], java.nio.charset.Charset) new String(bytes, StandardCharSets.US_ASCII)}
 	 * instead
 	 */
 	@Deprecated(forRemoval = true, since = "10.2")
 	public static String toString(byte [] array) {
-		StringBuilder buffer = new StringBuilder();
+		StringBuilder builder = new StringBuilder();
     	for (byte b : array) {
-			buffer.append((char)b);
+			builder.append((char) b);
 		}
-    	return buffer.toString();
+		return builder.toString();
     }
 
     /**
@@ -142,7 +141,7 @@ public static String toString(byte [] array) {
 	 * @return the padded hex string
 	 */
 	public static String toHexString(byte b) {
-        return zeropad(Integer.toHexString(byteToInt(b)), 2);
+		return zeropad(Integer.toHexString(Byte.toUnsignedInt(b)), 2);
     }
 
     /**
@@ -154,7 +153,7 @@ public static String toHexString(byte b) {
 	 * @return the padded hex string
 	 */
 	public static String toHexString(short s) {
-        return zeropad(Integer.toHexString(shortToInt(s)), 4);
+		return zeropad(Integer.toHexString(Short.toUnsignedInt(s)), 4);
     }
     
 	/**
@@ -190,12 +189,12 @@ public static String toHexString(long l) {
 	 */
 	public static String zeropad(String s, int len) {
         if (s == null) s = "";
-        StringBuffer buffer = new StringBuffer(s);
+		StringBuilder builder = new StringBuilder(s);
         int zerosNeeded = len - s.length();
         for (int i = 0 ; i < zerosNeeded ; ++i) {
-            buffer.insert(0, '0');
+			builder.insert(0, '0');
         }
-        return buffer.toString();
+		return builder.toString();
     }
 
 }
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/xml/XmlAttributes.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/xml/XmlAttributes.java
index f6009d197af..c4d76eda1ff 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/xml/XmlAttributes.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/xml/XmlAttributes.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,8 +15,6 @@
  */
 package ghidra.util.xml;
 
-import ghidra.util.Conv;
-
 import java.math.BigInteger;
 
 /**
@@ -106,7 +104,7 @@ public void addAttribute(String name, byte value) {
 	 * @param hex   true if value should be written in hex
 	 */
 	public void addAttribute(String name, byte value, boolean hex) {
-		addAttribute(name, hex ? Conv.byteToInt(value) : (int) value, hex);
+		addAttribute(name, hex ? Byte.toUnsignedInt(value) : (int) value, hex);
 	}
 
 	/**
@@ -125,7 +123,7 @@ public void addAttribute(String name, short value) {
 	 * @param hex   true if value should be written in hex
 	 */
 	public void addAttribute(String name, short value, boolean hex) {
-		addAttribute(name, hex ? Conv.shortToInt(value) : (int) value, hex);
+		addAttribute(name, hex ? Short.toUnsignedInt(value) : (int) value, hex);
 	}
 
 	/**
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CountedDynamicDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CountedDynamicDataType.java
index 200bb5c8ef5..35fe4c7dee5 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CountedDynamicDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CountedDynamicDataType.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressOverflowException;
 import ghidra.program.model.mem.*;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 /**
@@ -157,13 +156,13 @@ private long getCount(Memory memory, Address loc) {
 		try {
 			switch (counterSize) {
 				case 1:
-					test = Conv.byteToLong(memory.getByte(loc));
+					test = Byte.toUnsignedLong(memory.getByte(loc));
 					break;
 				case 2:
-					test = Conv.shortToLong(memory.getShort(loc));
+					test = Short.toUnsignedLong(memory.getShort(loc));
 					break;
 				case 4:
-					test = Conv.intToLong(memory.getInt(loc));
+					test = Integer.toUnsignedLong(memory.getInt(loc));
 					break;
 				case 8:
 					test = memory.getLong(loc);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/IndexedDynamicDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/IndexedDynamicDataType.java
index 9b99f1bbfbc..ef0b4e2da8d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/IndexedDynamicDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/IndexedDynamicDataType.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,7 +21,6 @@
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressOverflowException;
 import ghidra.program.model.mem.*;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 /**
@@ -239,13 +238,13 @@ private long getIndex(Memory memory, Address loc) {
 		try {
 			switch (indexSize) {
 				case 1:
-					test = Conv.byteToLong(memory.getByte(loc));
+					test = Byte.toUnsignedLong(memory.getByte(loc));
 					break;
 				case 2:
-					test = Conv.shortToLong(memory.getShort(loc));
+					test = Short.toUnsignedLong(memory.getShort(loc));
 					break;
 				case 4:
-					test = Conv.intToLong(memory.getInt(loc));
+					test = Integer.toUnsignedLong(memory.getInt(loc));
 					break;
 				case 8:
 					test = memory.getLong(loc);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/RepeatedDynamicDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/RepeatedDynamicDataType.java
index c43a33001ff..b9af14f2892 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/RepeatedDynamicDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/RepeatedDynamicDataType.java
@@ -21,7 +21,6 @@
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressOverflowException;
 import ghidra.program.model.mem.*;
-import ghidra.util.Conv;
 import ghidra.util.Msg;
 
 /**
@@ -158,13 +157,13 @@ private boolean moreComponents(Memory memory, Address loc) {
 		try {
 			switch (terminatorSize) {
 				case 1:
-					test = Conv.byteToLong(memory.getByte(loc));
+					test = Byte.toUnsignedLong(memory.getByte(loc));
 					break;
 				case 2:
-					test = Conv.shortToLong(memory.getShort(loc));
+					test = Short.toUnsignedLong(memory.getShort(loc));
 					break;
 				case 4:
-					test = Conv.intToLong(memory.getInt(loc));
+					test = Integer.toUnsignedLong(memory.getInt(loc));
 					break;
 				case 8:
 					test = memory.getLong(loc);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/BlockStartLocation.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/BlockStartLocation.java
index a3135f8f1d2..c2b3ab9a984 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/BlockStartLocation.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/BlockStartLocation.java
@@ -18,7 +18,6 @@
 package ghidra.program.util;
 
 import ghidra.program.model.address.Address;
-import ghidra.program.model.listing.CodeUnit;
 import ghidra.program.model.listing.Program;
 
 /**
diff --git a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/macho/relocation/AARCH64_MachoRelocationHandler.java b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/macho/relocation/AARCH64_MachoRelocationHandler.java
index cbed3c3902b..37636d39e59 100644
--- a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/macho/relocation/AARCH64_MachoRelocationHandler.java
+++ b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/macho/relocation/AARCH64_MachoRelocationHandler.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,7 +23,6 @@
 import ghidra.program.model.mem.MemoryAccessException;
 import ghidra.program.model.reloc.Relocation.Status;
 import ghidra.program.model.reloc.RelocationResult;
-import ghidra.util.Conv;
 
 /** 
  * A {@link MachoRelocationHandler} for AARCH64
@@ -133,7 +132,7 @@ public RelocationResult relocate(MachoRelocation relocation)
 				break;
 			}
 			case ARM64_RELOC_AUTHENTICATED_POINTER: {
-				long addend = orig & Conv.INT_MASK;
+				long addend = orig & 0x00000000ffffffffL;
 				long value = targetAddr.getOffset() + addend;
 				byteLength = write(relocation, value);
 				break;
```
-----------------------------------
