# Commit: ab849887aaea6e71c9fff74d468dc8c544b22658
## Message: Merge remote-tracking branch
'origin/GP-3952-ghidra_blue-update-script-categories--SQUASHED'
## Diff:
```
diff --git a/Ghidra/Debug/Debugger/ghidra_scripts/ComputeUnwindInfoScript.java b/Ghidra/Debug/Debugger/ghidra_scripts/ComputeUnwindInfoScript.java
index f7342f931a9..f70535b6339 100644
--- a/Ghidra/Debug/Debugger/ghidra_scripts/ComputeUnwindInfoScript.java
+++ b/Ghidra/Debug/Debugger/ghidra_scripts/ComputeUnwindInfoScript.java
@@ -19,7 +19,7 @@
 //script is more for diagnostic and demonstration purposes, since the application of unwind
 //information is already integrated into the Debugger.
 //@author
-//@category Stack
+//@category
 //@keybinding
 //@menupath
 //@toolbar
diff --git a/Ghidra/Extensions/MachineLearning/ghidra_scripts/FindFunctionsRFExampleScript.java b/Ghidra/Extensions/MachineLearning/ghidra_scripts/FindFunctionsRFExampleScript.java
index 60803cffd30..f44bb261bb0 100644
--- a/Ghidra/Extensions/MachineLearning/ghidra_scripts/FindFunctionsRFExampleScript.java
+++ b/Ghidra/Extensions/MachineLearning/ghidra_scripts/FindFunctionsRFExampleScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Example script for training random forests to find function starts
-//@category    machineLearning
+//@category Training
 
 import java.util.*;
 import java.util.Map.Entry;
diff --git a/Ghidra/Extensions/MachineLearning/ghidra_scripts/TurnOffFuncStartSearch.java b/Ghidra/Extensions/MachineLearning/ghidra_scripts/TurnOffFuncStartSearch.java
index 3d1d460c065..6b3620d2136 100644
--- a/Ghidra/Extensions/MachineLearning/ghidra_scripts/TurnOffFuncStartSearch.java
+++ b/Ghidra/Extensions/MachineLearning/ghidra_scripts/TurnOffFuncStartSearch.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +15,7 @@
  */
 // Turns off function start searching (intended for use with the 
 // headless analyzer as a prescript)
-//@category machineLearning
+//@category Search
 
 import ghidra.app.script.GhidraScript;
 
diff --git a/Ghidra/Features/BSim/ghidra_scripts/DumpBSimDebugSignaturesScript.py b/Ghidra/Features/BSim/ghidra_scripts/DumpBSimDebugSignaturesScript.py
index 430f4cf77ea..ee2efbe21ec 100755
--- a/Ghidra/Features/BSim/ghidra_scripts/DumpBSimDebugSignaturesScript.py
+++ b/Ghidra/Features/BSim/ghidra_scripts/DumpBSimDebugSignaturesScript.py
@@ -1,21 +1,21 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Generate the BSim signature for the function at the current address, 
 # then dump the signature hashes and debug information to the console
-# @category: BSim.python
+# @category: BSim.Python
 # @runtime Jython
 
 import ghidra.app.decompiler.DecompInterface as DecompInterface
diff --git a/Ghidra/Features/BSim/ghidra_scripts/DumpBSimSignaturesScript.py b/Ghidra/Features/BSim/ghidra_scripts/DumpBSimSignaturesScript.py
index 15114469f33..5a0f9849459 100755
--- a/Ghidra/Features/BSim/ghidra_scripts/DumpBSimSignaturesScript.py
+++ b/Ghidra/Features/BSim/ghidra_scripts/DumpBSimSignaturesScript.py
@@ -1,21 +1,21 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Generate the BSim signature for the function at the current address, then dump the 
 # signature hashes to the console 
-# @category: BSim.python
+# @category: BSim.Python
 # @runtime Jython
 
 import ghidra.app.decompiler.DecompInterface as DecompInterface
diff --git a/Ghidra/Features/BSim/ghidra_scripts/ExampleOverviewQueryScript.py b/Ghidra/Features/BSim/ghidra_scripts/ExampleOverviewQueryScript.py
index c92ee8603b2..6bdf93561a3 100755
--- a/Ghidra/Features/BSim/ghidra_scripts/ExampleOverviewQueryScript.py
+++ b/Ghidra/Features/BSim/ghidra_scripts/ExampleOverviewQueryScript.py
@@ -1,20 +1,20 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Example of how to perform an overview query in a script
-# @category BSim.python
+# @category BSim.Python
 # @runtime Jython
 
 import ghidra.features.bsim.query.facade.SFOverviewInfo as SFOverviewInfo
diff --git a/Ghidra/Features/BSim/ghidra_scripts/GenerateSignatures.py b/Ghidra/Features/BSim/ghidra_scripts/GenerateSignatures.py
index e518e776b7e..1ee4abb9460 100755
--- a/Ghidra/Features/BSim/ghidra_scripts/GenerateSignatures.py
+++ b/Ghidra/Features/BSim/ghidra_scripts/GenerateSignatures.py
@@ -1,20 +1,20 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 #Generate signatures for every function in the current program and write them to an XML file in a user-specified directory
-#@category BSim.python
+#@category BSim.Python
 #@runtime Jython
 
 import java.lang.System as System
diff --git a/Ghidra/Features/BSim/ghidra_scripts/QueryFunction.py b/Ghidra/Features/BSim/ghidra_scripts/QueryFunction.py
index a57e4f99184..a3292ff6bd4 100755
--- a/Ghidra/Features/BSim/ghidra_scripts/QueryFunction.py
+++ b/Ghidra/Features/BSim/ghidra_scripts/QueryFunction.py
@@ -1,20 +1,20 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Example of performing a BSim query on a single function
-# @category BSim.python  
+# @category BSim.Python  
 # @runtime Jython
 
 import ghidra.features.bsim.query.BSimClientFactory as BSimClientFactory
diff --git a/Ghidra/Features/Base/developer_scripts/BuildResultState.java b/Ghidra/Features/Base/developer_scripts/BuildResultState.java
index ecd3aa0367f..00cbba8ce5e 100644
--- a/Ghidra/Features/Base/developer_scripts/BuildResultState.java
+++ b/Ghidra/Features/Base/developer_scripts/BuildResultState.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 // Build ResultState for current function
-// @category Experimental
+// @category
 
 import java.util.*;
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/AddSourceFileScript.java b/Ghidra/Features/Base/ghidra_scripts/AddSourceFileScript.java
index cfdcd2d687e..87cc8a330ef 100644
--- a/Ghidra/Features/Base/ghidra_scripts/AddSourceFileScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/AddSourceFileScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 // Adds a SourceFile with a user-defined path and name to the program.
-//@category SourceMapping
+//@category Source Mapping
 import java.util.HexFormat;
 
 import org.apache.commons.lang3.StringUtils;
diff --git a/Ghidra/Features/Base/ghidra_scripts/AddSourceMapEntryScript.java b/Ghidra/Features/Base/ghidra_scripts/AddSourceMapEntryScript.java
index de72e8707e9..1e2fe2cda3a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/AddSourceMapEntryScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/AddSourceMapEntryScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 // Add a source map entry for the current selection.
 // The current selection must consist of a single address range.
 // If there is no selection, a length 0 entry will be added at the current address.
-//@category SourceMapping
+//@category Source Mapping
 import java.util.*;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/AsciiToBinaryScript.java b/Ghidra/Features/Base/ghidra_scripts/AsciiToBinaryScript.java
index b9e313a4469..e5986b8924f 100644
--- a/Ghidra/Features/Base/ghidra_scripts/AsciiToBinaryScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/AsciiToBinaryScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 //Converts an ascii hex file into binary file. Works for files with spaces and without. Assumes hex bytes are zero padded so all values are two bytes long.
-//@category Conversion
-
-import ghidra.app.script.GhidraScript;
+//@category
 
 import java.io.*;
 
+import ghidra.app.script.GhidraScript;
+
 public class AsciiToBinaryScript extends GhidraScript {
 
 	private static final String EMPTY_STRING = "";
@@ -37,8 +37,9 @@ public void run() throws Exception {
 		File outBinaryFile = askFile("Select Binary File", "Binary File");
 
 		if (outBinaryFile.equals(inAsciiFile)) {
-			popup("Input file and output file are the same. Please choose a different file for the output." +
-				inAsciiFile.getAbsolutePath());
+			popup(
+				"Input file and output file are the same. Please choose a different file for the output." +
+					inAsciiFile.getAbsolutePath());
 			return;
 		}
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/BatchRename.java b/Ghidra/Features/Base/ghidra_scripts/BatchRename.java
index 9ee650d6e79..782fc77ca1a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/BatchRename.java
+++ b/Ghidra/Features/Base/ghidra_scripts/BatchRename.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Recursively finds a folder that matches a string and renames it to a new name.
-//@category Project
+//@category Program
 //@menupath
 
 import ghidra.app.script.GhidraScript;
@@ -26,7 +26,6 @@ public class BatchRename extends GhidraScript {
 	public BatchRename() {
 	}
 
-
 	@Override
 	public void run() throws Exception {
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/BatchSegregate64bit.java b/Ghidra/Features/Base/ghidra_scripts/BatchSegregate64bit.java
index 3e1ed4a9bc9..91f7a0895ac 100644
--- a/Ghidra/Features/Base/ghidra_scripts/BatchSegregate64bit.java
+++ b/Ghidra/Features/Base/ghidra_scripts/BatchSegregate64bit.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Separates co-mingled n-bit and 64-bit binaries into two folder trees. 
-//@category Project
+//@category Program
 //@menupath
 
 import java.io.IOException;
diff --git a/Ghidra/Features/Base/ghidra_scripts/BinaryToAsciiScript.java b/Ghidra/Features/Base/ghidra_scripts/BinaryToAsciiScript.java
index f86dec57357..f6beaecb8d2 100644
--- a/Ghidra/Features/Base/ghidra_scripts/BinaryToAsciiScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/BinaryToAsciiScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,13 +14,12 @@
  * limitations under the License.
  */
 //Converts a binary file into an ascii hex file.
-//@category Conversion
-
-import ghidra.app.script.GhidraScript;
-import ghidra.util.Conv;
+//@category
 
 import java.io.*;
 
+import ghidra.app.script.GhidraScript;
+import ghidra.util.Conv;
 
 public class BinaryToAsciiScript extends GhidraScript {
 
@@ -37,12 +35,13 @@ public void run() throws Exception {
 		File outAsciiFile = askFile("Select Ascii File", "Ascii File");
 
 		if (inputBinaryFile.equals(outAsciiFile)) {
-			popup("Input file and output file are the same. "+inputBinaryFile.getAbsolutePath());
+			popup("Input file and output file are the same. " + inputBinaryFile.getAbsolutePath());
 			return;
 		}
 
 		if (outAsciiFile.exists()) {
-			if (!askYesNo("Ascii File Already Exists", "The ascii file already exists.\nDo you want to overwrite it?")) {
+			if (!askYesNo("Ascii File Already Exists",
+				"The ascii file already exists.\nDo you want to overwrite it?")) {
 				return;
 			}
 		}
@@ -51,7 +50,7 @@ public void run() throws Exception {
 
 		if (bytesPerLine < 1) {
 			popup("Invalid bytes per line quantity: " + bytesPerLine + ".\n " +
-					"Value must be greater than zero.");
+				"Value must be greater than zero.");
 			return;
 		}
 
@@ -59,7 +58,7 @@ public void run() throws Exception {
 
 		PrintWriter out = new PrintWriter(outAsciiFile);
 
-		byte [] buffer = new byte[4096];
+		byte[] buffer = new byte[4096];
 
 		int bytesWritten = 0;
 		while (true) {
@@ -73,7 +72,7 @@ public void run() throws Exception {
 				break;
 			}
 
-			for (int i = 0 ; i < nRead ; ++i) {
+			for (int i = 0; i < nRead; ++i) {
 				if (monitor.isCancelled()) {
 					break;
 				}
@@ -82,7 +81,7 @@ public void run() throws Exception {
 					out.append('\n');
 				}
 
-				out.write( Conv.toHexString(buffer[i]) );
+				out.write(Conv.toHexString(buffer[i]));
 
 				++bytesWritten;
 			}
diff --git a/Ghidra/Features/Base/ghidra_scripts/CallotherCensusScript.java b/Ghidra/Features/Base/ghidra_scripts/CallotherCensusScript.java
index 7baeaf64fbd..32b1d4e45d6 100644
--- a/Ghidra/Features/Base/ghidra_scripts/CallotherCensusScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/CallotherCensusScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 // Produces a list of instructions whose pcode contains a CALLOTHER pcode op.  The list is
 // sorted by number of occurrences of an instruction. When run headlessly, the list is displayed 
 // each time a program is processed and the counts are cumulative.
-// @category sleigh
+// @category Sleigh
 
 import java.util.HashMap;
 import java.util.Map;
diff --git a/Ghidra/Features/Base/ghidra_scripts/CountAndSaveStrings.java b/Ghidra/Features/Base/ghidra_scripts/CountAndSaveStrings.java
index a9d41d739e2..73bfa93da49 100644
--- a/Ghidra/Features/Base/ghidra_scripts/CountAndSaveStrings.java
+++ b/Ghidra/Features/Base/ghidra_scripts/CountAndSaveStrings.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,14 +15,14 @@
  */
 //Counts the number of defined strings in the current selection, or current program if no selection is made,
 //and saves the results to a file.
-//@category CustomerSubmission.Strings
+//@category Customer Submission.Strings
+
+import java.io.*;
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.listing.*;
 import ghidra.program.util.ProgramSelection;
 
-import java.io.*;
-
 public class CountAndSaveStrings extends GhidraScript {
 	private Listing listing;
 	private File saveFile;
@@ -46,8 +46,8 @@ public void run() throws Exception {
 	private File getSaveFile() throws Exception {
 		File file = askFile("Choose File Location", "Save");
 		if (file.exists()) {
-			if (!askYesNo("File Already Exists", "A file already exists with the name you "
-				+ "chose.\nDo you want to overwrite it?")) {
+			if (!askYesNo("File Already Exists", "A file already exists with the name you " +
+				"chose.\nDo you want to overwrite it?")) {
 				return null;
 			}
 		}
diff --git a/Ghidra/Features/Base/ghidra_scripts/CreateExportFileForDLL.java b/Ghidra/Features/Base/ghidra_scripts/CreateExportFileForDLL.java
index 4805d3df71f..ce0a11fab8e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/CreateExportFileForDLL.java
+++ b/Ghidra/Features/Base/ghidra_scripts/CreateExportFileForDLL.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,7 +21,7 @@
 //
 //   The name of the .exports file will be printed when the script finishes.
 //
-//@category Windows
+//@category
 //@keybinding 
 //@menupath 
 //@toolbar 
diff --git a/Ghidra/Features/Base/ghidra_scripts/CreateStringScript.java b/Ghidra/Features/Base/ghidra_scripts/CreateStringScript.java
index e1fdd69964a..8e1aa178738 100644
--- a/Ghidra/Features/Base/ghidra_scripts/CreateStringScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/CreateStringScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //finds and creates strings that end with  '\n'
-//@category Memory
+//@category Data Types
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
diff --git a/Ghidra/Features/Base/ghidra_scripts/DebugSleighInstructionParse.java b/Ghidra/Features/Base/ghidra_scripts/DebugSleighInstructionParse.java
index 990c384e145..48baf1c19a6 100644
--- a/Ghidra/Features/Base/ghidra_scripts/DebugSleighInstructionParse.java
+++ b/Ghidra/Features/Base/ghidra_scripts/DebugSleighInstructionParse.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,60 +15,62 @@
  */
 // Attempt to parse single instruction from memory bytes at current location.
 // Parse trace output written to Tool Console.
-// @category sleigh
+// @category Sleigh
 import ghidra.app.plugin.processors.sleigh.SleighDebugLogger;
 import ghidra.app.plugin.processors.sleigh.SleighDebugLogger.SleighDebugMode;
 import ghidra.app.script.GhidraScript;
 import ghidra.util.StringUtilities;
 
-
 public class DebugSleighInstructionParse extends GhidraScript {
 
 	@Override
 	public void run() throws Exception {
-		
+
 		if (currentProgram == null || currentAddress == null) {
 			return;
 		}
 
 		try {
-			SleighDebugLogger logger = new SleighDebugLogger(currentProgram, currentAddress, SleighDebugMode.VERBOSE);
+			SleighDebugLogger logger =
+				new SleighDebugLogger(currentProgram, currentAddress, SleighDebugMode.VERBOSE);
 
 			if (!logger.parseFailed()) {
 				logger.append("\n");
-				
+
 				byte[] mask = logger.getInstructionMask();
 				byte[] value = logger.getMaskedBytes(mask);
-				
+
 				logger.append("Instr Mask:  ");
 				logger.append(mask, -1, -1);
 				logger.append("\nInstr Value: ");
 				logger.append(value, -1, -1);
-				
+
 				for (int i = 0; i < logger.getNumOperands(); i++) {
 					mask = logger.getOperandValueMask(i);
 					logger.append("\nOp-" + i + " Mask:   " + getFormattedBytes(mask));
-					logger.append("\nOp-" + i + " Value:  " + getFormattedBytes(logger.getMaskedBytes(mask)));
+					logger.append(
+						"\nOp-" + i + " Value:  " + getFormattedBytes(logger.getMaskedBytes(mask)));
 				}
 			}
 			println(logger.toString());
-			
-		} catch (Exception e) {
+
+		}
+		catch (Exception e) {
 			println(e.getMessage());
 		}
 
 	}
-	
-	 private String getFormattedBytes(byte[] value) {
-			StringBuffer buf = new StringBuffer();
-			for (int i = 0; i < value.length; i++) {
+
+	private String getFormattedBytes(byte[] value) {
+		StringBuffer buf = new StringBuffer();
+		for (int i = 0; i < value.length; i++) {
 			String byteStr = StringUtilities.pad(Integer.toBinaryString(value[i] & 0xff), '0', 8);
-				buf.append(byteStr);
-				if (i < (value.length-1)) {
-					buf.append(".");
-				}
+			buf.append(byteStr);
+			if (i < (value.length - 1)) {
+				buf.append(".");
 			}
-			return buf.toString();
 		}
-	
+		return buf.toString();
+	}
+
 }
diff --git a/Ghidra/Features/Base/ghidra_scripts/EditBytesScript.java b/Ghidra/Features/Base/ghidra_scripts/EditBytesScript.java
index 77184736cfa..e2aebf534e0 100644
--- a/Ghidra/Features/Base/ghidra_scripts/EditBytesScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/EditBytesScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Convenience script to quickly clear, edit, and recreate the code or data at the current cursor location.
-//@category Memory
+//@category Update
 //@keybinding
 //@menupath 
 //@toolbar 
diff --git a/Ghidra/Features/Base/ghidra_scripts/ExportImagesScript.java b/Ghidra/Features/Base/ghidra_scripts/ExportImagesScript.java
index 9c6243eaf64..ac5fadd5e4b 100644
--- a/Ghidra/Features/Base/ghidra_scripts/ExportImagesScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/ExportImagesScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +15,7 @@
  */
 //Looks for already defined graphic image data in the program 
 //and writes all selected images to a directory. 
-//@category Images
+//@category 
 
 import java.awt.image.BufferedImage;
 import java.io.File;
diff --git a/Ghidra/Features/Base/ghidra_scripts/FFsBeGoneScript.java b/Ghidra/Features/Base/ghidra_scripts/FFsBeGoneScript.java
index 7a8e02c0d5d..105b8b5569a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/FFsBeGoneScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/FFsBeGoneScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 //Rid us of those pesky FF's that become bad instructions
-//@category Cleanup
+//@category 
+
+import java.util.Arrays;
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.CategoryPath;
 import ghidra.program.model.data.DataType;
 
-import java.util.Arrays;
-
 public class FFsBeGoneScript extends GhidraScript {
 	private Address addr;
 	byte[] bytes = new byte[10];
@@ -83,11 +83,17 @@ private void advance() {
 			if (!isUndefinedData(addr)) {
 				if (currentProgram.getListing().getInstructionContaining(addr) != null) {
 					addr =
-						currentProgram.getListing().getInstructionContaining(addr).getMaxAddress().next();
+						currentProgram.getListing()
+								.getInstructionContaining(addr)
+								.getMaxAddress()
+								.next();
 				}
 				else if (currentProgram.getListing().getDefinedDataContaining(addr) != null) {
 					addr =
-						currentProgram.getListing().getDefinedDataContaining(addr).getMaxAddress().next();
+						currentProgram.getListing()
+								.getDefinedDataContaining(addr)
+								.getMaxAddress()
+								.next();
 				}
 				advance();
 			}
diff --git a/Ghidra/Features/Base/ghidra_scripts/FindAudioInProgramScript.java b/Ghidra/Features/Base/ghidra_scripts/FindAudioInProgramScript.java
index 3b04838e243..41d6bf82b79 100644
--- a/Ghidra/Features/Base/ghidra_scripts/FindAudioInProgramScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/FindAudioInProgramScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Finds programs containing various audio resources such as WAV's 
-//@category Resources
+//@category Search
 import java.util.ArrayList;
 import java.util.List;
 
@@ -109,7 +109,8 @@ List<Address> scanForAudioData(byte[] imageBytes, byte[] mask) {
 						break;
 					}
 					found =
-						memory.findBytes(start, blocks[i].getEnd(), imageBytes, mask, true, monitor);
+						memory.findBytes(start, blocks[i].getEnd(), imageBytes, mask, true,
+							monitor);
 					if (found != null) {
 						foundImages.add(found);
 						start = found.add(1);
diff --git a/Ghidra/Features/Base/ghidra_scripts/FindImagesScript.java b/Ghidra/Features/Base/ghidra_scripts/FindImagesScript.java
index 89b242facdb..976fb41600b 100644
--- a/Ghidra/Features/Base/ghidra_scripts/FindImagesScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/FindImagesScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,10 @@
  * limitations under the License.
  */
 //Finds PNG and GIF images and applies data type if not already applied
-//@category Images
+//@category Search
+import java.util.ArrayList;
+import java.util.List;
+
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.GifDataType;
@@ -23,9 +26,6 @@
 import ghidra.program.model.mem.Memory;
 import ghidra.program.model.mem.MemoryBlock;
 
-import java.util.ArrayList;
-import java.util.List;
-
 public class FindImagesScript extends GhidraScript {
 
 	@Override
diff --git a/Ghidra/Features/Base/ghidra_scripts/FindUndefinedFunctionsFollowUpScript.java b/Ghidra/Features/Base/ghidra_scripts/FindUndefinedFunctionsFollowUpScript.java
index 792c79a737b..a12eac709db 100644
--- a/Ghidra/Features/Base/ghidra_scripts/FindUndefinedFunctionsFollowUpScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/FindUndefinedFunctionsFollowUpScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +25,7 @@
 //          problems with it.  Still, it did a pretty good job of cleaning up after 
 //          FindUndefinedFunctionsScript.
 //
-//@category CustomerSubmission.Analysis.Repair
+//@category Customer Submission.Analysis.Repair
 
 import ghidra.app.script.GhidraScript;
 import ghidra.app.util.PseudoDisassembler;
diff --git a/Ghidra/Features/Base/ghidra_scripts/FixElfExternalOffsetDataRelocationScript.java b/Ghidra/Features/Base/ghidra_scripts/FixElfExternalOffsetDataRelocationScript.java
index 8fcf7e5c492..2617d8b48f4 100644
--- a/Ghidra/Features/Base/ghidra_scripts/FixElfExternalOffsetDataRelocationScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/FixElfExternalOffsetDataRelocationScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,7 +27,7 @@
 //
 // Script may be constrained by a selection.
 //
-//@category ELF Relocations
+//@category DWARF
 import java.util.Iterator;
 
 import ghidra.app.script.GhidraScript;
@@ -82,18 +82,19 @@ protected void run() throws Exception {
 		}
 	}
 
-	private boolean updateExternalDataRelocation(Bookmark relocErrorBookmark, MessageLog log) throws Exception {
-		
+	private boolean updateExternalDataRelocation(Bookmark relocErrorBookmark, MessageLog log)
+			throws Exception {
+
 		Address address = relocErrorBookmark.getAddress();
 		String bookmarkComment = relocErrorBookmark.getComment();
-		
+
 		int byteSize = address.getAddressSpace().getPointerSize();
-		
+
 		int index = bookmarkComment.lastIndexOf("0x");
 		if (index < 0) {
 			return false;
 		}
-		
+
 		char signChar = bookmarkComment.charAt(index - 1);
 		int offset;
 		try {
@@ -108,16 +109,18 @@ private boolean updateExternalDataRelocation(Bookmark relocErrorBookmark, Messag
 		else if (signChar != '+') {
 			return false;
 		}
-		
+
 		Memory memory = currentProgram.getMemory();
 		DumbMemBufferImpl buf = new DumbMemBufferImpl(memory, address);
-		
-		Address symbolAddr = PointerDataType.getAddressValue(buf, byteSize, address.getAddressSpace());
+
+		Address symbolAddr =
+			PointerDataType.getAddressValue(buf, byteSize, address.getAddressSpace());
 		if (symbolAddr == null) {
 			return false; // invalid pointer data
 		}
-		
-		String symbolName = bookmarkComment.substring(EXT_RELO_BOOKMARK_TEXT_PREFIX.length(), index - 1).trim();
+
+		String symbolName =
+			bookmarkComment.substring(EXT_RELO_BOOKMARK_TEXT_PREFIX.length(), index - 1).trim();
 		if (currentProgram.getSymbolTable().getSymbol(symbolName, symbolAddr, null) == null) {
 			return false; // EXTERNAL block symbol not found at stored address
 		}
@@ -136,23 +139,24 @@ else if (signChar != '+') {
 			!canFixupStructure(dt, componentOffset, address.getPointerSize())) {
 			return false; // unsupported datatype applied
 		}
-		
+
 		long newValue = symbolAddr.getOffset() + offset;
-		
+
 		GhidraDataConverter converter = GhidraDataConverter.getInstance(buf.isBigEndian());
 		byte[] bytes = new byte[byteSize];
 		converter.putValue(newValue, byteSize, bytes, 0);
 		memory.setBytes(address, bytes);
 
 		currentProgram.getBookmarkManager().removeBookmark(relocErrorBookmark);
-		
-		ElfRelocationHandler.warnExternalOffsetRelocation(currentProgram, address, symbolAddr, symbolName, offset, log);
-		
+
+		ElfRelocationHandler.warnExternalOffsetRelocation(currentProgram, address, symbolAddr,
+			symbolName, offset, log);
+
 		DataType offsetPtrDt =
 			currentProgram.getDataTypeManager()
 					.resolve(new PointerTypedef(null, null, -1, currentProgram.getDataTypeManager(),
 						offset), null);
-		
+
 		if (isDefaultTypeApplied) {
 			// Replace undefined/default data with offset-pointer
 			DataUtilities.createData(currentProgram, address, offsetPtrDt, -1,
diff --git a/Ghidra/Features/Base/ghidra_scripts/InstructionSearchScript.java b/Ghidra/Features/Base/ghidra_scripts/InstructionSearchScript.java
index 7911f2905be..6f932f09cbe 100644
--- a/Ghidra/Features/Base/ghidra_scripts/InstructionSearchScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/InstructionSearchScript.java
@@ -16,7 +16,7 @@
 //
 //Example script illustrating how to launch the Instruction Pattern Search dialog from a script.
 //
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 
 import java.util.List;
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/IterateDataScript.java b/Ghidra/Features/Base/ghidra_scripts/IterateDataScript.java
index 5f04b788996..dba128c4449 100644
--- a/Ghidra/Features/Base/ghidra_scripts/IterateDataScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/IterateDataScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +14,7 @@
  * limitations under the License.
  */
 //Iterates over all defined data in the current program.
-//@category Iteration
+//@category Examples
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.listing.Data;
diff --git a/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsByAddressScript.java b/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsByAddressScript.java
index 164997fb4c4..fa13ec9f45e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsByAddressScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsByAddressScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //Iterates over all functions in the current program
 //starting at the minimum address of the program.
 //
-//@category Iteration
+//@category Examples
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
@@ -29,7 +29,8 @@ public class IterateFunctionsByAddressScript extends GhidraScript {
 	public void run() throws Exception {
 
 		boolean forward =
-			askYesNo("Iterate Function", "Do you want to iterate from low address to high address?");
+			askYesNo("Iterate Function",
+				"Do you want to iterate from low address to high address?");
 
 		if (forward) {
 			iterateForward();
diff --git a/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsScript.java b/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsScript.java
index fcc447954d6..deb9cfae9c8 100644
--- a/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/IterateFunctionsScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +14,7 @@
  * limitations under the License.
  */
 //Iterates over all functions in the current program.
-//@category Iteration
+//@category Examples
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.listing.Function;
@@ -26,7 +25,8 @@ public class IterateFunctionsScript extends GhidraScript {
 	public void run() throws Exception {
 
 		boolean forward =
-			askYesNo("Iterate Function", "Do you want to iterate from low address to high address?");
+			askYesNo("Iterate Function",
+				"Do you want to iterate from low address to high address?");
 
 		if (forward) {
 			iterateForward();
diff --git a/Ghidra/Features/Base/ghidra_scripts/IterateInstructionsScript.java b/Ghidra/Features/Base/ghidra_scripts/IterateInstructionsScript.java
index ca144dd5cd9..15a979d34ef 100644
--- a/Ghidra/Features/Base/ghidra_scripts/IterateInstructionsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/IterateInstructionsScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +14,7 @@
  * limitations under the License.
  */
 //Iterates over all instructions in the current program.
-//@category Iteration
+//@category Examples
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.listing.Instruction;
@@ -46,7 +45,7 @@ public void run() throws Exception {
 
 			int nOperands = instruction.getNumOperands();
 
-			for (int i = 0 ; i < nOperands ; ++i) {
+			for (int i = 0; i < nOperands; ++i) {
 				String operand = instruction.getDefaultOperandRepresentation(i);
 				buffer.append(operand);
 				buffer.append(' ');
diff --git a/Ghidra/Features/Base/ghidra_scripts/LinuxSystemMapImportScript.java b/Ghidra/Features/Base/ghidra_scripts/LinuxSystemMapImportScript.java
index 99f33b5c643..77da9514dd2 100644
--- a/Ghidra/Features/Base/ghidra_scripts/LinuxSystemMapImportScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/LinuxSystemMapImportScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,7 +27,7 @@
 //  /proc/ksyms eliminates the middle column, and may add the name of the module
 //  in square brackets at the end of the line.
 
-//@category CustomerSubmission.Linux
+//@category Customer Submission.Linux
 
 import java.io.*;
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/MakeStackRefs.java b/Ghidra/Features/Base/ghidra_scripts/MakeStackRefs.java
index 316c82125c0..df02a1c22e7 100644
--- a/Ghidra/Features/Base/ghidra_scripts/MakeStackRefs.java
+++ b/Ghidra/Features/Base/ghidra_scripts/MakeStackRefs.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +19,7 @@
 // specified data type and symbol name and converts all "offset(base_register)"
 // references to "symbol_name(base_register)" references.
 //
-//@category CustomerSubmission.Analysis
+//@category Customer Submission.Analysis
 //@keybinding alt S
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/MarkCallOtherPcode.java b/Ghidra/Features/Base/ghidra_scripts/MarkCallOtherPcode.java
index 59e25c702b0..0d8d8e0bcc3 100644
--- a/Ghidra/Features/Base/ghidra_scripts/MarkCallOtherPcode.java
+++ b/Ghidra/Features/Base/ghidra_scripts/MarkCallOtherPcode.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 // Generate WARNING Bookmarks at instructions whose pcode contains a CALLOTHER op.
 // This is useful to find PseudoOps that need to be implemented to yield better
 // emulation or decompilation.
-// @category sleigh
+// @category Sleigh
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.disassemble.Disassembler;
diff --git a/Ghidra/Features/Base/ghidra_scripts/MarkUnimplementedPcode.java b/Ghidra/Features/Base/ghidra_scripts/MarkUnimplementedPcode.java
index d3378c2844c..38b3c020194 100644
--- a/Ghidra/Features/Base/ghidra_scripts/MarkUnimplementedPcode.java
+++ b/Ghidra/Features/Base/ghidra_scripts/MarkUnimplementedPcode.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 // Generate WARNING Bookmarks on instructions which have unimplemented pcode.
 // Similar to disassembler's built-in marking but allows for refresh after 
 // language update.
-// @category sleigh
+// @category Sleigh
 import ghidra.app.script.GhidraScript;
 import ghidra.program.disassemble.Disassembler;
 import ghidra.program.model.address.AddressSetView;
@@ -60,8 +60,9 @@ public void run() throws Exception {
 	}
 
 	private void markUnimplementedPcode(Instruction instr) {
-		currentProgram.getBookmarkManager().setBookmark(instr.getAddress(), BookmarkType.WARNING,
-			Disassembler.UNIMPL_BOOKMARK_CATEGORY,
-			"Instruction pcode is unimplemented: " + instr.getMnemonicString());
+		currentProgram.getBookmarkManager()
+				.setBookmark(instr.getAddress(), BookmarkType.WARNING,
+					Disassembler.UNIMPL_BOOKMARK_CATEGORY,
+					"Instruction pcode is unimplemented: " + instr.getMnemonicString());
 	}
 }
diff --git a/Ghidra/Features/Base/ghidra_scripts/MarkupWallaceSrcScript.java b/Ghidra/Features/Base/ghidra_scripts/MarkupWallaceSrcScript.java
index 5c73e5119e8..a49b353636e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/MarkupWallaceSrcScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/MarkupWallaceSrcScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,149 +14,158 @@
  * limitations under the License.
  */
 //This script applies labels and comments to the WallaceSrc.exe program for use with GhidraClass exercises 
-//@category Training.GhidraClass
-
+//@category Training.Ghidra Class
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
-import ghidra.program.model.data.ArrayDataType;
-import ghidra.program.model.data.BooleanDataType;
-import ghidra.program.model.data.CharDataType;
-import ghidra.program.model.data.IntegerDataType;
-import ghidra.program.model.data.PointerDataType;
-import ghidra.program.model.data.Structure;
-import ghidra.program.model.data.StructureDataType;
-import ghidra.program.model.listing.Function;
+import ghidra.program.model.data.*;
+import ghidra.program.model.listing.*;
 import ghidra.program.model.listing.Function.FunctionUpdateType;
-import ghidra.program.model.listing.Parameter;
-import ghidra.program.model.listing.ParameterImpl;
-import ghidra.program.model.symbol.Namespace;
-import ghidra.program.model.symbol.SourceType;
-import ghidra.program.model.symbol.SymbolTable;
+import ghidra.program.model.symbol.*;
 import ghidra.util.exception.InvalidInputException;
 
 public class MarkupWallaceSrcScript extends GhidraScript {
-	
 
 	@Override
 	public void run() throws Exception {
-		
-		if(!currentProgram.getName().contains("WallaceSrc") || (!currentProgram.getExecutableMD5().equals("2527c463a079c81af7b3bc1d26bd3b5d"))) {
-			println("This script is only meant to work on the WallaceSrc executable with md5 hash 2527c463a079c81af7b3bc1d26bd3b5d.");
+
+		if (!currentProgram.getName().contains("WallaceSrc") ||
+			(!currentProgram.getExecutableMD5().equals("2527c463a079c81af7b3bc1d26bd3b5d"))) {
+			println(
+				"This script is only meant to work on the WallaceSrc executable with md5 hash 2527c463a079c81af7b3bc1d26bd3b5d.");
 			return;
-		}																							
-		
+		}
+
 		//Create Person structure
 		Structure personStruct = new StructureDataType("Person", 0);
-		personStruct.add(new IntegerDataType(), "id", "");		
+		personStruct.add(new IntegerDataType(), "id", "");
 		ArrayDataType adt = new ArrayDataType(new CharDataType(), 32, 1);
 		personStruct.add(adt, "name", "");
 		personStruct.add(new BooleanDataType(), "likesCheese", "");
 		PointerDataType ptrPersonStruct = new PointerDataType(personStruct);
 		personStruct.add(ptrPersonStruct, "next", "");
-		
+
 		//Create Gadget structure	
 		Structure gadgetStruct = new StructureDataType("Gadget", 0);
 		PointerDataType charPtr = new PointerDataType(new CharDataType());
-		gadgetStruct.add(charPtr,"name","");
-		gadgetStruct.add(new IntegerDataType(),"type", "");
-		gadgetStruct.add(new BooleanDataType(), "deployed","");
-		gadgetStruct.add(ptrPersonStruct, "workingOn","");
-		
+		gadgetStruct.add(charPtr, "name", "");
+		gadgetStruct.add(new IntegerDataType(), "type", "");
+		gadgetStruct.add(new BooleanDataType(), "deployed", "");
+		gadgetStruct.add(ptrPersonStruct, "workingOn", "");
+
 		//apply data types to function parameters, locals, and returns
-		
+
 		//Gadget::Gadget(Gadget * this, undefined4 param_1)
 		Function gadgetFunction = getFunctionAt(toAddr(0x00411440));
 		Parameter[] parameters = gadgetFunction.getParameters();
-		parameters[0] = new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);		
-		gadgetFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);
-					
+		parameters[0] =
+			new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);
+		gadgetFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		//deployGadget - return type = Gadget * 
 		Function deployGadgetFunction = getFunctionAt(toAddr(0x004118f0));
-		deployGadgetFunction.setReturnType(new PointerDataType(gadgetStruct), SourceType.USER_DEFINED);
-				
+		deployGadgetFunction.setReturnType(new PointerDataType(gadgetStruct),
+			SourceType.USER_DEFINED);
+
 		//initializePeople(Person *) 
 		Function initPeopleFunction = getFunctionAt(toAddr(0x004117c0));
 		parameters = initPeopleFunction.getParameters();
-		parameters[0] = new ParameterImpl("people", new PointerDataType(personStruct), currentProgram);
-		initPeopleFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);		
-		
+		parameters[0] =
+			new ParameterImpl("people", new PointerDataType(personStruct), currentProgram);
+		initPeopleFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		//use(Gadget *this, Person *person)
 		Function useFunction = getFunctionAt(toAddr(0x00411570));
 		parameters = useFunction.getParameters();
-		parameters[0] = new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);	
-		parameters[1] = new ParameterImpl("person", new PointerDataType(personStruct), currentProgram);	
-		useFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);
-		
+		parameters[0] =
+			new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);
+		parameters[1] =
+			new ParameterImpl("person", new PointerDataType(personStruct), currentProgram);
+		useFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		//addPerson(Person ** list, char * name)
 		Function addPersonFunction = getFunctionAt(toAddr(0x00411860));
 		parameters = addPersonFunction.getParameters();
-		parameters[0] = new ParameterImpl("list", new PointerDataType(new PointerDataType(personStruct)), currentProgram);	
-		parameters[1] = new ParameterImpl("name", new PointerDataType(new CharDataType()), currentProgram);	
-		addPersonFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);
-		
+		parameters[0] = new ParameterImpl("list",
+			new PointerDataType(new PointerDataType(personStruct)), currentProgram);
+		parameters[1] =
+			new ParameterImpl("name", new PointerDataType(new CharDataType()), currentProgram);
+		addPersonFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		//addPeople(Person ** list)
 		Function addPeopleFunction = getFunctionAt(toAddr(0x00411700));
 		parameters = addPeopleFunction.getParameters();
-		parameters[0] = new ParameterImpl("list", new PointerDataType(new PointerDataType(personStruct)), currentProgram);	
-		addPeopleFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);
-		
+		parameters[0] = new ParameterImpl("list",
+			new PointerDataType(new PointerDataType(personStruct)), currentProgram);
+		addPeopleFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		//print(Gadget * pGadget)
 		Function printFunction = getFunctionAt(toAddr(0x004115d0));
 		parameters = printFunction.getParameters();
-		parameters[0] = new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);		
-		printFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,true, SourceType.USER_DEFINED, parameters);
-		
+		parameters[0] =
+			new ParameterImpl("this", new PointerDataType(gadgetStruct), currentProgram);
+		printFunction.replaceParameters(FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true,
+			SourceType.USER_DEFINED, parameters);
+
 		// Create labels for some of the functions
 		SymbolTable symbolTable = currentProgram.getSymbolTable();
 
-		
 		//create the Class "Gadget" to put most function symbols in
 		Namespace namespace = null;
 		namespace = symbolTable.getNamespace("Gadget", null);
-		if(namespace == null) {
-			 namespace = symbolTable.createClass(null, "Gadget", SourceType.USER_DEFINED);
+		if (namespace == null) {
+			namespace = symbolTable.createClass(null, "Gadget", SourceType.USER_DEFINED);
 		}
-				
+
 		//Functions in Gadget class
 		createNewLabel(toAddr(0x00411440), "Gadget", namespace, SourceType.USER_DEFINED);
-		createNewLabel(toAddr(0x004115d0), "print", namespace, SourceType.USER_DEFINED);		
-		createNewLabel(toAddr(0x00411570), "use", namespace, SourceType.USER_DEFINED);	
-		
+		createNewLabel(toAddr(0x004115d0), "print", namespace, SourceType.USER_DEFINED);
+		createNewLabel(toAddr(0x00411570), "use", namespace, SourceType.USER_DEFINED);
+
 		//Functions not in class
 		createNewLabel(toAddr(0x004117c0), "initializePeople", namespace, SourceType.USER_DEFINED);
-		createNewLabel(toAddr(0x004118f0), "deployGadget", namespace, SourceType.USER_DEFINED);		
+		createNewLabel(toAddr(0x004118f0), "deployGadget", namespace, SourceType.USER_DEFINED);
 		createNewLabel(toAddr(0x00411700), "addPeople", namespace, SourceType.USER_DEFINED);
 		createNewLabel(toAddr(0x00411860), "addPerson", namespace, SourceType.USER_DEFINED);
 		createNewLabel(toAddr(0x00418138), "personList", namespace, SourceType.USER_DEFINED);
-		createNewLabel(toAddr(0x00411a30), "main", null, SourceType.USER_DEFINED);		
-		
+		createNewLabel(toAddr(0x00411a30), "main", null, SourceType.USER_DEFINED);
+
 		// Add other labels
-		Function function = currentProgram.getFunctionManager().getFunctionAt(toAddr(0x004117c0));	
+		Function function = currentProgram.getFunctionManager().getFunctionAt(toAddr(0x004117c0));
 		createNewLabel(toAddr(0x004117e5), "LoopOverPeople", function, SourceType.USER_DEFINED);
-		if(getSymbolAt(toAddr(0x00418138)).getSource().equals(SourceType.DEFAULT)){
-			createLabel(toAddr(0x00418138),"personList", true);
+		if (getSymbolAt(toAddr(0x00418138)).getSource().equals(SourceType.DEFAULT)) {
+			createLabel(toAddr(0x00418138), "personList", true);
 		}
-		
+
 		// Add comments
-	    setPlateComment(toAddr(0x00411440), "This is the init method for the Gadget class");
-	    setPlateComment(toAddr(0x004115d0), "This method prints the status of a Person -- whether they are deployed or not and who they are deployed on. ");
-	    setPlateComment(toAddr(0x00411700), "This function adds all the people to the Person list.");
-	    setPlateComment(toAddr(0x004117c0), "This function initializes each person's record with whether or not they like cheese, their id, and a pointer to the next person.");
-	    setPlateComment(toAddr(0x00411860), "This function adds a person to the Person list.");
-	    setPlateComment(toAddr(0x004118f0), "This function checks to see if the person on the list is Wallace and if so, it deploys the Infrared Garden Gnome.");
-	    setEOLComment(toAddr(0x004117e7), "Randomly assign whether each person likes cheese or not.");	
+		setPlateComment(toAddr(0x00411440), "This is the init method for the Gadget class");
+		setPlateComment(toAddr(0x004115d0),
+			"This method prints the status of a Person -- whether they are deployed or not and who they are deployed on. ");
+		setPlateComment(toAddr(0x00411700),
+			"This function adds all the people to the Person list.");
+		setPlateComment(toAddr(0x004117c0),
+			"This function initializes each person's record with whether or not they like cheese, their id, and a pointer to the next person.");
+		setPlateComment(toAddr(0x00411860), "This function adds a person to the Person list.");
+		setPlateComment(toAddr(0x004118f0),
+			"This function checks to see if the person on the list is Wallace and if so, it deploys the Infrared Garden Gnome.");
+		setEOLComment(toAddr(0x004117e7),
+			"Randomly assign whether each person likes cheese or not.");
 	}
-	
+
 	void createNewLabel(Address address, String name, Namespace namespace, SourceType sourceType) {
 		SymbolTable symbolTable = currentProgram.getSymbolTable();
-		if(getSymbolAt(address).getSource().equals(SourceType.DEFAULT)){
+		if (getSymbolAt(address).getSource().equals(SourceType.DEFAULT)) {
 			try {
 				symbolTable.createLabel(address, name, namespace, sourceType);
-			} catch (InvalidInputException e) {
+			}
+			catch (InvalidInputException e) {
 				println("Invalid input to create label.");
 			}
 		}
 	}
 }
-
diff --git a/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInEclipseScript.java b/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInEclipseScript.java
index 2f495aff1af..2c672532a17 100644
--- a/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInEclipseScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInEclipseScript.java
@@ -25,7 +25,7 @@
 // Edit -> Tool Options -> Eclipse Integration
 //
 // from the Ghidra Project Manager.
-//@category SourceMapping
+//@category Source Mapping
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
diff --git a/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInVSCodeScript.java b/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInVSCodeScript.java
index 55a13c3ac1f..20a198c580a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInVSCodeScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/OpenSourceFileAtLineInVSCodeScript.java
@@ -25,7 +25,7 @@
 // Edit -> Tool Options -> Visual Studio Code Integration
 //
 // from the Ghidra Project Manager.
-//@category SourceMapping
+//@category Source Mapping
 
 import java.io.File;
 import java.io.FileNotFoundException;
diff --git a/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java b/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
index 7dfca64accb..dd371f1c21e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/PortableExecutableRichPrintScript.java
@@ -16,7 +16,7 @@
 // This script displays data about Microsoft development tools (compilers, linkers, etc.) 
 // used to build objects within program as stored in the Rich header and table.
 //
-//@category Windows
+//@category
 //@keybinding 
 //@menupath 
 //@toolbar 
@@ -80,8 +80,12 @@ public void run() throws Exception {
 			MSProductType prodType = prod == null ? MSProductType.Unknown : prod.getProductType();
 
 			if (prodType != MSProductType.Unknown) {
-				sb.append(prodType).append(" from ").append(prodVersion).append(", build ").append(
-					compid.getBuildNumber());
+				sb.append(prodType)
+						.append(" from ")
+						.append(prodVersion)
+						.append(", build ")
+						.append(
+							compid.getBuildNumber());
 			}
 			else {
 				sb.append(prodVersion);
@@ -154,7 +158,7 @@ private static boolean isToolchainVersionAfterV5(RichHeader rich) {
 				.filter(id -> id > LINKER_VERSION_5_PRODUCTID)
 				.collect(Collectors.counting());		
 		// @formatter:on
-		
+
 		return version5OrGreater != 0;
 	}
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/RecursiveStringFinder.py b/Ghidra/Features/Base/ghidra_scripts/RecursiveStringFinder.py
index efe9182bfe9..756f38986ae 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RecursiveStringFinder.py
+++ b/Ghidra/Features/Base/ghidra_scripts/RecursiveStringFinder.py
@@ -1,20 +1,20 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 #Given a function, find all strings used within all called funtions.
-# @category: Strings
+# @category: Functions
 # @runtime Jython
 
 # Handles only functions, not subroutines, as of now.  Hopefully this will change later
diff --git a/Ghidra/Features/Base/ghidra_scripts/ReloadSleighLanguage.java b/Ghidra/Features/Base/ghidra_scripts/ReloadSleighLanguage.java
index b65be066ee9..8ccef503150 100644
--- a/Ghidra/Features/Base/ghidra_scripts/ReloadSleighLanguage.java
+++ b/Ghidra/Features/Base/ghidra_scripts/ReloadSleighLanguage.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 // Reloads the language specification associated with a program at runtime.
-// @category sleigh
+// @category Sleigh
 import java.io.IOException;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/RemoveSourceMapEntryScript.java b/Ghidra/Features/Base/ghidra_scripts/RemoveSourceMapEntryScript.java
index 00a2c159353..3ddd1ac3e3e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RemoveSourceMapEntryScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RemoveSourceMapEntryScript.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 // Select and remove a source map entry at the current address.
-//@category SourceMapping
+//@category Source Mapping
 import java.util.*;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/RemoveUserCheckoutsScript.java b/Ghidra/Features/Base/ghidra_scripts/RemoveUserCheckoutsScript.java
index c6d6e7b8d8e..79ded1fc29a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RemoveUserCheckoutsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RemoveUserCheckoutsScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Script to allow repository admins the ability to terminate multiple file checkouts belonging to a single user.
-//@category MultiUser
+//@category Update
 
 import java.io.IOException;
 
@@ -33,25 +33,25 @@ public class RemoveUserCheckoutsScript extends GhidraScript {
 
 	@Override
 	protected void run() throws Exception {
-		
+
 		Project project = state.getProject();
-		
+
 		ProjectData projectData = project.getProjectData();
-		
+
 		RepositoryAdapter repository = projectData.getRepository();
 		if (repository == null) {
 			printerr("Project is not a shared project");
 			return;
 		}
-		
+
 		User currentUser = repository.getUser();
 		if (!currentUser.isAdmin()) {
 			printerr("You are not a repository administrator for " + repository.getName());
 			return;
 		}
-		
-		String uname = askString("Remove User Checkouts" , "Enter user ID to be cleared");
-		
+
+		String uname = askString("Remove User Checkouts", "Enter user ID to be cleared");
+
 		boolean found = false;
 		for (User u : repository.getUserList()) {
 			if (uname.equals(u.getName())) {
@@ -61,31 +61,34 @@ protected void run() throws Exception {
 		}
 		if (!found) {
 			if (OptionDialog.showYesNoDialogWithNoAsDefaultButton(null, "User Name Confirmation",
-					"User '" + uname + "' not a registered server user.\nDo you still want to search for and remove checkouts for this user?") != OptionDialog.YES_OPTION) {
+				"User '" + uname +
+					"' not a registered server user.\nDo you still want to search for and remove checkouts for this user?") != OptionDialog.YES_OPTION) {
 				return;
 			}
 		}
-		
+
 		if (projectData.getFileCount() > 1000) {
-			if (OptionDialog.showYesNoDialogWithNoAsDefaultButton(null, "Large Repository Confirmation",
-					"Repository contains a large number of failes and could be slow to search.\nDo you still want to search for and remove checkouts?") != OptionDialog.YES_OPTION) {
+			if (OptionDialog.showYesNoDialogWithNoAsDefaultButton(null,
+				"Large Repository Confirmation",
+				"Repository contains a large number of failes and could be slow to search.\nDo you still want to search for and remove checkouts?") != OptionDialog.YES_OPTION) {
 				return;
 			}
 		}
-		
+
 		int count = removeCheckouts(repository, "/", uname, monitor);
 		popup("Removed " + count + " checkouts");
-		
+
 	}
-	
+
 	private String getPath(String folderPath, String childName) {
 		if (!folderPath.endsWith("/")) {
 			folderPath += "/";
 		}
 		return folderPath + childName;
 	}
-	
-	private int removeCheckouts(RepositoryAdapter repository, String folderPath, String uid, TaskMonitor monitor) throws IOException, CancelledException {
+
+	private int removeCheckouts(RepositoryAdapter repository, String folderPath, String uid,
+			TaskMonitor monitor) throws IOException, CancelledException {
 		int count = 0;
 		for (RepositoryItem item : repository.getItemList(folderPath)) {
 			monitor.checkCancelled();
@@ -96,16 +99,20 @@ private int removeCheckouts(RepositoryAdapter repository, String folderPath, Str
 		}
 		return count;
 	}
-	
-	private int removeCheckouts(RepositoryAdapter repository, RepositoryItem item, String uid) throws IOException {
+
+	private int removeCheckouts(RepositoryAdapter repository, RepositoryItem item, String uid)
+			throws IOException {
 		int count = 0;
-		ItemCheckoutStatus[] checkouts = repository.getCheckouts(item.getParentPath(), item.getName());
+		ItemCheckoutStatus[] checkouts =
+			repository.getCheckouts(item.getParentPath(), item.getName());
 		for (ItemCheckoutStatus checkout : checkouts) {
 			if (uid.equals(checkout.getUser())) {
 				try {
-					repository.terminateCheckout(item.getParentPath(), item.getName(), checkout.getCheckoutId(), false);
+					repository.terminateCheckout(item.getParentPath(), item.getName(),
+						checkout.getCheckoutId(), false);
 					++count;
-				} catch (IOException e) {
+				}
+				catch (IOException e) {
 					printerr("Failed to remove checkout: " + e.getMessage());
 				}
 			}
diff --git a/Ghidra/Features/Base/ghidra_scripts/RenameStructMembers.java b/Ghidra/Features/Base/ghidra_scripts/RenameStructMembers.java
index ec64a3db8cd..5aa70709fac 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RenameStructMembers.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RenameStructMembers.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,14 +22,14 @@
 // Note: Script does not verify that no other member within the structure
 //       is already using the new name.
 //
-//@category CustomerSubmission.Search
+//@category Customer Submission.Search
+
+import java.util.Iterator;
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.data.DataTypeComponent;
 import ghidra.program.model.data.Structure;
 
-import java.util.Iterator;
-
 public class RenameStructMembers extends GhidraScript {
 
 	@Override
diff --git a/Ghidra/Features/Base/ghidra_scripts/RenameVariable.java b/Ghidra/Features/Base/ghidra_scripts/RenameVariable.java
index ebe49365a6e..b43fdc7634c 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RenameVariable.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RenameVariable.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,12 +19,10 @@
 // Note: Script does not verify that no other variable within the
 //       function is already using the new name.
 //
-//@category CustomerSubmission.Search
+//@category Customer Submission.Search
 
 import ghidra.app.script.GhidraScript;
-import ghidra.program.model.listing.Function;
-import ghidra.program.model.listing.FunctionIterator;
-import ghidra.program.model.listing.Variable;
+import ghidra.program.model.listing.*;
 import ghidra.program.model.symbol.SourceType;
 
 public class RenameVariable extends GhidraScript {
diff --git a/Ghidra/Features/Base/ghidra_scripts/RepairFuncDefinitionUsageScript.java b/Ghidra/Features/Base/ghidra_scripts/RepairFuncDefinitionUsageScript.java
index 407a9f6c9bc..ec85cad3380 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RepairFuncDefinitionUsageScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RepairFuncDefinitionUsageScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +18,10 @@
 // Function Definition.  This resolves variable size errors which
 // result from this bad data state.
 //
-//@category Repair
+//@category
+import java.util.Arrays;
+import java.util.Comparator;
+
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.data.*;
@@ -28,9 +30,6 @@
 import ghidra.util.Msg;
 import ghidra.util.exception.InvalidInputException;
 
-import java.util.Arrays;
-import java.util.Comparator;
-
 public class RepairFuncDefinitionUsageScript extends GhidraScript {
 
 	private static class MyVariableOffsetComparator implements Comparator<Variable> {
diff --git a/Ghidra/Features/Base/ghidra_scripts/ReplaceInComments.java b/Ghidra/Features/Base/ghidra_scripts/ReplaceInComments.java
index 0b1206ea1e6..020d00a84ca 100644
--- a/Ghidra/Features/Base/ghidra_scripts/ReplaceInComments.java
+++ b/Ghidra/Features/Base/ghidra_scripts/ReplaceInComments.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,13 +29,11 @@
 //    - Script scans every address within the program, so it is slow.
 //    - Script doesn't scan param comments.
 //
-//@category CustomerSubmission.Search
+//@category Customer Submission.Search
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
-import ghidra.program.model.listing.Function;
-import ghidra.program.model.listing.FunctionIterator;
-import ghidra.program.model.listing.Variable;
+import ghidra.program.model.listing.*;
 import ghidra.program.model.mem.MemoryBlock;
 
 public class ReplaceInComments extends GhidraScript {
diff --git a/Ghidra/Features/Base/ghidra_scripts/RepositoryFileUpgradeScript.java b/Ghidra/Features/Base/ghidra_scripts/RepositoryFileUpgradeScript.java
index 774e2e277a4..3445104b53e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RepositoryFileUpgradeScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/RepositoryFileUpgradeScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,7 @@
 // the script will optionally list any existing checkouts prior to starting
 // the batch upgrade.
 //
-//@category Upgrade
+//@category Program
 import java.io.IOException;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/RunYARAFromGhidra.py b/Ghidra/Features/Base/ghidra_scripts/RunYARAFromGhidra.py
index 5e142ba9fb8..42f27b73233 100644
--- a/Ghidra/Features/Base/ghidra_scripts/RunYARAFromGhidra.py
+++ b/Ghidra/Features/Base/ghidra_scripts/RunYARAFromGhidra.py
@@ -1,17 +1,17 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # This Ghidra script runs YARA on the file associated with the current program in the Ghidra Code Browser.
 # The user supplies a YARA rule file.  Upon a match, the YARA rule name is reported in the comment at
@@ -23,7 +23,7 @@
 # 2. The user has imported the file into Ghidra and the user has since deleted the file.  This Ghidra script attempts to
 # generate the original bytes of the imported file and asks the user to provide a filename to store the bytes.  YARA then runs on that file.
 
-#@category Memory.YARA
+#@category Search.YARA
 #@runtime Jython
 
 import os.path
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchBaseExtended.java b/Ghidra/Features/Base/ghidra_scripts/SearchBaseExtended.java
index cc128ad66bc..478bbd19b21 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchBaseExtended.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchBaseExtended.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,7 +17,7 @@
 //that called it) and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchGuiMulti.java b/Ghidra/Features/Base/ghidra_scripts/SearchGuiMulti.java
index 7108bc886da..210af652671 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchGuiMulti.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchGuiMulti.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //The script will use a selection of multiple instructions and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 
 import java.awt.Color;
 import java.awt.Component;
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchGuiSingle.java b/Ghidra/Features/Base/ghidra_scripts/SearchGuiSingle.java
index 3c9126bf609..fa4dac13c3e 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchGuiSingle.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchGuiSingle.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //The script will use the first instructions in a selection and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
@@ -56,11 +56,13 @@ private void initComponents() {
 		GroupLayout jPanel1Layout = new GroupLayout(jPanel1);
 		jPanel1.setLayout(jPanel1Layout);
 		jPanel1Layout.setHorizontalGroup(
-			jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGap(0, 100,
-				Short.MAX_VALUE));
+			jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
+					.addGap(0, 100,
+						Short.MAX_VALUE));
 		jPanel1Layout.setVerticalGroup(
-			jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGap(0, 100,
-				Short.MAX_VALUE));
+			jPanel1Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
+					.addGap(0, 100,
+						Short.MAX_VALUE));
 
 		frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
 
@@ -77,45 +79,51 @@ public void actionPerformed(ActionEvent evt) {
 		GroupLayout layout = new GroupLayout(frame.getContentPane());
 		frame.getContentPane().setLayout(layout);
 		layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) //
-			.addGroup(layout.createSequentialGroup() //
-				.addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) //
-					.addGroup(layout.createSequentialGroup() //
-						.addContainerGap() //
+				.addGroup(layout.createSequentialGroup() //
 						.addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) //
-							.addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING) //
-								.addComponent(opTwoCheckBox) //
-								.addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) //
-									.addComponent(mnemonicCheckBox) //
-									.addComponent(opOneCheckBox) //
+								.addGroup(layout.createSequentialGroup() //
+										.addContainerGap() //
+										.addGroup(layout
+												.createParallelGroup(GroupLayout.Alignment.LEADING) //
+												.addGroup(layout
+														.createParallelGroup(
+															GroupLayout.Alignment.TRAILING) //
+														.addComponent(opTwoCheckBox) //
+														.addGroup(layout
+																.createParallelGroup(
+																	GroupLayout.Alignment.LEADING) //
+																.addComponent(mnemonicCheckBox) //
+																.addComponent(opOneCheckBox) //
+														) //
+												) //
+												.addComponent(constCheckBox) //
+												.addComponent(jLabel1) //
+										) //
+								) //
+								.addGroup(layout.createSequentialGroup() //
+										.addGap(32, 32, 32) //
+										.addComponent(searchButton) //
 								) //
-							) //
-							.addComponent(constCheckBox) //
-							.addComponent(jLabel1) //
 						) //
-					) //
-					.addGroup(layout.createSequentialGroup() //
-						.addGap(32, 32, 32) //
-						.addComponent(searchButton) //
-					) //
+						.addContainerGap(12, Short.MAX_VALUE) //
 				) //
-				.addContainerGap(12, Short.MAX_VALUE) //
-			) //
 		);
 		layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) //
-			.addGroup(layout.createSequentialGroup() //
-				.addContainerGap() //
-				.addComponent(jLabel1) //
-				.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
-				.addComponent(mnemonicCheckBox) //
-				.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
-				.addComponent(opOneCheckBox) //
-				.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
-				.addComponent(opTwoCheckBox) //
-				.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
-				.addComponent(constCheckBox) //
-				.addGap(18, 18, 18).addComponent(searchButton) //
-				.addContainerGap(27, Short.MAX_VALUE) //
-			) //
+				.addGroup(layout.createSequentialGroup() //
+						.addContainerGap() //
+						.addComponent(jLabel1) //
+						.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
+						.addComponent(mnemonicCheckBox) //
+						.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
+						.addComponent(opOneCheckBox) //
+						.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
+						.addComponent(opTwoCheckBox) //
+						.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) //
+						.addComponent(constCheckBox) //
+						.addGap(18, 18, 18)
+						.addComponent(searchButton) //
+						.addContainerGap(27, Short.MAX_VALUE) //
+				) //
 		);
 
 		frame.pack();
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsNoOpsNoConstScript.java b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsNoOpsNoConstScript.java
index 7244506d29b..836cf03f3b8 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsNoOpsNoConstScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsNoOpsNoConstScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //The script will use the selected instructions and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 
 public class SearchMnemonicsNoOpsNoConstScript extends SearchBaseExtended {
 
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsConstScript.java b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsConstScript.java
index c803a56aa6a..9d3ee90b38a 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsConstScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsConstScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //The script will use the selected instructions and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 public class SearchMnemonicsOpsConstScript extends SearchBaseExtended {
 
 	@Override
diff --git a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsNoConstScript.java b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsNoConstScript.java
index 656f6077fbe..1674eb44530 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsNoConstScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SearchMnemonicsOpsNoConstScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,7 @@
 //The script will use the selected instructions and build a combined mask/value buffer.
 //Memory is then searched looking for this combined value buffer that represents the selected instructions.
 //This automates the process of searching through memory for a particular ordering of instructions by hand.
-//@category Search.InstructionPattern
+//@category Search.Instruction Pattern
 public class SearchMnemonicsOpsNoConstScript extends SearchBaseExtended {
 
 	@Override
diff --git a/Ghidra/Features/Base/ghidra_scripts/SelectAddressesMappedToSourceFileScript.java b/Ghidra/Features/Base/ghidra_scripts/SelectAddressesMappedToSourceFileScript.java
index c555f557b89..09ddd0bbc46 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SelectAddressesMappedToSourceFileScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SelectAddressesMappedToSourceFileScript.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 // Sets the current selection based on source file and line number parameters
-//@category SourceMapping
+//@category Source Mapping
 import java.util.*;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/Base/ghidra_scripts/SelectFunctionsScript.java b/Ghidra/Features/Base/ghidra_scripts/SelectFunctionsScript.java
index e41693b04df..affb13ce7a9 100644
--- a/Ghidra/Features/Base/ghidra_scripts/SelectFunctionsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/SelectFunctionsScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,27 +15,27 @@
  */
 //Creates a selection in the current program consisting of the sum 
 //of all function bodies.
-//@category Selection
+//@category
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.AddressSet;
 import ghidra.program.model.listing.*;
 
 public class SelectFunctionsScript extends GhidraScript {
-    @Override
-    public void run() {
-        monitor.setMessage("Selecting functions...");
-        AddressSet set = new AddressSet();
-        Listing listing = state.getCurrentProgram().getListing();
-        FunctionIterator iter = listing.getFunctions(true);
-        int functionCount = 0;
-        while (iter.hasNext() && !monitor.isCancelled()) {
-            functionCount++;
-            Function f = iter.next();
-            set.add(f.getBody());
-            println("Function Entry: "+f.getEntryPoint());
-        }
-        println("Function Count: "+functionCount);
-        createSelection(set);
-    }
+	@Override
+	public void run() {
+		monitor.setMessage("Selecting functions...");
+		AddressSet set = new AddressSet();
+		Listing listing = state.getCurrentProgram().getListing();
+		FunctionIterator iter = listing.getFunctions(true);
+		int functionCount = 0;
+		while (iter.hasNext() && !monitor.isCancelled()) {
+			functionCount++;
+			Function f = iter.next();
+			set.add(f.getBody());
+			println("Function Entry: " + f.getEntryPoint());
+		}
+		println("Function Count: " + functionCount);
+		createSelection(set);
+	}
 }
diff --git a/Ghidra/Features/Base/ghidra_scripts/ShowSourceMapEntryStartsScript.java b/Ghidra/Features/Base/ghidra_scripts/ShowSourceMapEntryStartsScript.java
index 2f454043877..85a87863743 100644
--- a/Ghidra/Features/Base/ghidra_scripts/ShowSourceMapEntryStartsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/ShowSourceMapEntryStartsScript.java
@@ -16,7 +16,7 @@
 
 // This script displays a table showing the base address of each source map entry
 // in the program along with a count of the number of entries starting at the address.
-// @category SourceMapping
+// @category Source Mapping
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -28,7 +28,6 @@
 import ghidra.program.model.sourcemap.SourceMapEntryIterator;
 import ghidra.util.datastruct.Counter;
 
-
 public class ShowSourceMapEntryStartsScript extends GhidraScript {
 
 	@Override
diff --git a/Ghidra/Features/Base/ghidra_scripts/TranslateStringsScript.java b/Ghidra/Features/Base/ghidra_scripts/TranslateStringsScript.java
index 73bd7d42032..230f95e1e06 100644
--- a/Ghidra/Features/Base/ghidra_scripts/TranslateStringsScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/TranslateStringsScript.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Example skeleton script that iterates over all strings and sets the translation value for each
-//@category Strings
+//@category Data Types
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.data.StringDataInstance;
diff --git a/Ghidra/Features/Base/ghidra_scripts/XorMemoryScript.java b/Ghidra/Features/Base/ghidra_scripts/XorMemoryScript.java
index f546c740b1e..3be4ae9f22d 100644
--- a/Ghidra/Features/Base/ghidra_scripts/XorMemoryScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/XorMemoryScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,47 +14,44 @@
  * limitations under the License.
  */
 //XOR's the memory of the current program.
-//@category Memory
+//@category Analysis
 
 import ghidra.app.script.GhidraScript;
-import ghidra.program.model.address.Address;
-import ghidra.program.model.address.AddressIterator;
-import ghidra.program.model.address.AddressSet;
-import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.address.*;
 import ghidra.program.model.mem.Memory;
 import ghidra.program.model.mem.MemoryBlock;
 
 public class XorMemoryScript extends GhidraScript {
 
-    @Override
-    public void run() throws Exception {
-    	
-    	// default to the current memory block
-    	Memory memory = currentProgram.getMemory();
-    	MemoryBlock block = memory.getBlock(currentAddress);
-    	AddressSetView set = new AddressSet(block.getStart(),block.getEnd());
-    	
-    	if (currentSelection != null && !currentSelection.isEmpty()) {
-    		set = currentSelection;
-    	}
-    	
-    	byte[] xorValues = askBytes("XorValue", "Values to xor with selected memory:");
-    	
-    	int valueLength = xorValues.length;
-    	int xorIndex = 0;
-    	
-    	AddressIterator aIter = set.getAddresses(true);
-    	
-    	while (aIter.hasNext() && !monitor.isCancelled()) {
-    		Address addr = aIter.next();
-    		monitor.setMessage(addr.toString());
-    		byte xorValue = xorValues[xorIndex];
-    		byte b = memory.getByte(addr);
-    		b = (byte) (b ^ xorValue);
-    		memory.setByte(addr, b);
-    		xorIndex += 1;
-    		xorIndex = xorIndex % valueLength;
-    	}
-    }
+	@Override
+	public void run() throws Exception {
+
+		// default to the current memory block
+		Memory memory = currentProgram.getMemory();
+		MemoryBlock block = memory.getBlock(currentAddress);
+		AddressSetView set = new AddressSet(block.getStart(), block.getEnd());
+
+		if (currentSelection != null && !currentSelection.isEmpty()) {
+			set = currentSelection;
+		}
+
+		byte[] xorValues = askBytes("XorValue", "Values to xor with selected memory:");
+
+		int valueLength = xorValues.length;
+		int xorIndex = 0;
+
+		AddressIterator aIter = set.getAddresses(true);
+
+		while (aIter.hasNext() && !monitor.isCancelled()) {
+			Address addr = aIter.next();
+			monitor.setMessage(addr.toString());
+			byte xorValue = xorValues[xorIndex];
+			byte b = memory.getByte(addr);
+			b = (byte) (b ^ xorValue);
+			memory.setByte(addr, b);
+			xorIndex += 1;
+			xorIndex = xorIndex % valueLength;
+		}
+	}
 
 }
diff --git a/Ghidra/Features/Base/ghidra_scripts/ZapBCTRScript.java b/Ghidra/Features/Base/ghidra_scripts/ZapBCTRScript.java
index 6d52da9d968..177530d946b 100644
--- a/Ghidra/Features/Base/ghidra_scripts/ZapBCTRScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/ZapBCTRScript.java
@@ -31,7 +31,7 @@
 //
 // NOTE:  Adresses must be hex values -- without "0x" prefixes.
 //
-//@category CustomerSubmission.Analysis
+//@category Customer Submission.Analysis
 //@keybinding alt Z
 
 import java.util.List;
@@ -62,6 +62,7 @@ public void run() throws Exception {
 		// first try input as class and search for symbol "<class>::__vtbl"
 		List<Symbol> symbols = currentProgram.getSymbolTable()
 				.getSymbols("__vtbl", getNamespace(null, classNameOrAddr));
+		
 		// if symbol found, then vtblAddr is the symbol's address
 		if (symbols.size() == 1) {
 			vtblAddr = symbols.get(0).getAddress();
diff --git a/Ghidra/Features/Base/ghidra_scripts/mark_in_out.py b/Ghidra/Features/Base/ghidra_scripts/mark_in_out.py
index 40b2b3070ec..17543e24b95 100644
--- a/Ghidra/Features/Base/ghidra_scripts/mark_in_out.py
+++ b/Ghidra/Features/Base/ghidra_scripts/mark_in_out.py
@@ -1,20 +1,20 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Sets up IOPORT IN/OUT references for the Program
-#@category Instructions
+#@category
 #@runtime Jython
 # Before running this script, you should have created an OVERLAY memory
 # space called IOMEM, starting at address 0, size 0x10000.
diff --git a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionBitPatternInfoForCurrentFunctionScript.java b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionBitPatternInfoForCurrentFunctionScript.java
index 7b9107d7741..1d48c036f3b 100644
--- a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionBitPatternInfoForCurrentFunctionScript.java
+++ b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionBitPatternInfoForCurrentFunctionScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +15,7 @@
  */
 //Use this script to dump the information about the function bit patterns for the 
 // current function to the ghidra console.
-//@category FunctionStartPatterns
+//@category Functions
 import java.util.List;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionPatternInfoScript.java b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionPatternInfoScript.java
index d78a4c93133..8a90c35da03 100644
--- a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionPatternInfoScript.java
+++ b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpFunctionPatternInfoScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,8 +15,8 @@
  */
 //This script dumps information about byte and instructions in neighborhoods around function starts
 //and returns to an XML file
-//@category FunctionStartPatterns
-import java.io.*;
+//@category Functions
+import java.io.File;
 import java.util.List;
 
 import ghidra.app.script.GhidraScript;
diff --git a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpMissedStarts.java b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpMissedStarts.java
index 60e463bfcb4..bc5278a474d 100644
--- a/Ghidra/Features/BytePatterns/ghidra_scripts/DumpMissedStarts.java
+++ b/Ghidra/Features/BytePatterns/ghidra_scripts/DumpMissedStarts.java
@@ -4,16 +4,16 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-//@category CodeAnalysis
+//@category 
 
 import java.io.*;
 import java.util.ArrayList;
diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/SwitchOverride.java b/Ghidra/Features/Decompiler/ghidra_scripts/SwitchOverride.java
index bb29b513c47..bbc73a52416 100644
--- a/Ghidra/Features/Decompiler/ghidra_scripts/SwitchOverride.java
+++ b/Ghidra/Features/Decompiler/ghidra_scripts/SwitchOverride.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@
 //
 //  You can also pre-add the COMPUTED_JUMP references to the branch instruction before running the
 //  script, and simply put the cursor on the computed branching instruction.
-//@category Repair
+//@category
 
 import java.util.ArrayList;
 
@@ -37,10 +37,11 @@
 
 public class SwitchOverride extends GhidraScript {
 
-	private Address collectSelectedJumpData(Listing listing,AddressSetView select,ArrayList<Address> destlist) {
+	private Address collectSelectedJumpData(Listing listing, AddressSetView select,
+			ArrayList<Address> destlist) {
 		Address branchind = null;
 		AddressIterator iter = select.getAddresses(true);
-		while(iter.hasNext()) {
+		while (iter.hasNext()) {
 			Address addr = iter.next();
 			Instruction inst = listing.getInstructionAt(addr);
 			if (isComputedBranchInstruction(inst)) {
@@ -52,18 +53,18 @@ else if (inst != null) {
 		}
 		return branchind;
 	}
-	
+
 	private Address collectPointJumpData(Listing listing,
 			Address addr, ArrayList<Address> destlist) {
 		Address branchind = null;
-		
+
 		// current location must be a callfixup, or an indirect Jump
 		Instruction instr = currentProgram.getListing().getInstructionAt(addr);
-		
+
 		if (isComputedBranchInstruction(instr)) {
 			branchind = addr;
 		}
-		
+
 		// add any jump references already added
 		Reference[] referencesFrom = instr.getReferencesFrom();
 		for (Reference reference : referencesFrom) {
@@ -72,7 +73,7 @@ private Address collectPointJumpData(Listing listing,
 				destlist.add(reference.getToAddress());
 			}
 		}
-		
+
 		return branchind;
 	}
 
@@ -80,9 +81,9 @@ private boolean isComputedBranchInstruction(Instruction instr) {
 		if (instr == null) {
 			return false;
 		}
-		
+
 		FlowType flowType = instr.getFlowType();
-		
+
 		if (flowType.isJump() && flowType.isComputed()) {
 			return true;
 		}
@@ -91,7 +92,8 @@ private boolean isComputedBranchInstruction(Instruction instr) {
 			Reference[] referencesFrom = instr.getReferencesFrom();
 			for (Reference reference : referencesFrom) {
 				if (reference.getReferenceType().isCall()) {
-					Function func = currentProgram.getFunctionManager().getFunctionAt(reference.getToAddress());
+					Function func =
+						currentProgram.getFunctionManager().getFunctionAt(reference.getToAddress());
 					if (func != null && func.getCallFixup() != null) {
 						return true;
 					}
@@ -101,42 +103,46 @@ private boolean isComputedBranchInstruction(Instruction instr) {
 		return false;
 	}
 
-	
 	@Override
 	public void run() throws Exception {
 		ArrayList<Address> destlist = new ArrayList<Address>();
 		Address branchind = null;
-		
+
 		if (currentSelection != null && !currentSelection.isEmpty()) {
-			branchind = collectSelectedJumpData(currentProgram.getListing(),currentSelection,destlist);
-		} else {
-			branchind = collectPointJumpData(currentProgram.getListing(),currentLocation.getAddress(),destlist);
+			branchind =
+				collectSelectedJumpData(currentProgram.getListing(), currentSelection, destlist);
+		}
+		else {
+			branchind = collectPointJumpData(currentProgram.getListing(),
+				currentLocation.getAddress(), destlist);
 		}
-		
-		if (branchind==null) {
-			println("Please highlight or place the cursor on the instruction performing the computed jump");
+
+		if (branchind == null) {
+			println(
+				"Please highlight or place the cursor on the instruction performing the computed jump");
 			return;
 		}
-		if (destlist.size()==0) {
-			println("Please highlight destination instructions in addition to instruction performing switch");
+		if (destlist.size() == 0) {
+			println(
+				"Please highlight destination instructions in addition to instruction performing switch");
 			println(" Or put CONDITIONAL_JUMP destination references at the branching instruction");
 			return;
 		}
 		Function function = this.getFunctionContaining(branchind);
-		if (function==null) {
+		if (function == null) {
 			println("Computed jump instruction must be in a Function body.");
 			return;
 		}
-		
+
 		Instruction instr = currentProgram.getListing().getInstructionAt(branchind);
 		for (Address address : destlist) {
 			instr.addOperandReference(0, address, RefType.COMPUTED_JUMP, SourceType.USER_DEFINED);
 		}
 
 		// Allocate an override jumptable
-		JumpTable jumpTab = new JumpTable(branchind,destlist,true);
+		JumpTable jumpTab = new JumpTable(branchind, destlist, true);
 		jumpTab.writeOverride(function);
-		
+
 		// fixup the body now that there are jump references
 		CreateFunctionCmd.fixupFunctionBody(currentProgram, function, monitor);
 	}
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/BTreeAnnotationScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/BTreeAnnotationScript.java
index cbfe6a14525..c47d0c7e326 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/BTreeAnnotationScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/BTreeAnnotationScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Annotates an HFS+ attributes b-Tree file.
-//@category iOS
+//@category Apple.iOS
 
 import ghidra.app.script.GhidraScript;
 import ghidra.app.util.bin.*;
@@ -180,7 +180,8 @@ private Data createUserDataRecord(Program program, BTreeUserDataRecord userDataR
 		return data;
 	}
 
-	private Data createBTreeHeaderRecord(Program program, BTreeHeaderRecord headerRecord, int offset)
+	private Data createBTreeHeaderRecord(Program program, BTreeHeaderRecord headerRecord,
+			int offset)
 			throws Exception {
 		Address address = toAddr(offset);
 		DataType dataType = headerRecord.toDataType();
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/BadInstructionCleanup.java b/Ghidra/Features/FileFormats/ghidra_scripts/BadInstructionCleanup.java
index f112f34ce34..f41f00a9a0f 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/BadInstructionCleanup.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/BadInstructionCleanup.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +15,7 @@
  */
 //This script cleans up the disassembly for kext files by locating "Bad Instruction" bookmarks caused by incorrectly defined data in valid code flows.
 //@author 
-//@category iOS
+//@category Apple.iOS
 //@keybinding 
 //@menupath 
 //@toolbar 
@@ -56,7 +56,7 @@ public void run() throws Exception {
 		}
 	}
 
-public void cleanup(Address ba) throws Exception {
+	public void cleanup(Address ba) throws Exception {
 
 		Program p = currentProgram;
 		BookmarkManager bmgr = p.getBookmarkManager();
@@ -79,8 +79,9 @@ public void cleanup(Address ba) throws Exception {
 				Address paddr = listing.getInstructionBefore(ba).getAddress();
 				RegisterValue rv;
 				if (paddr != null) {
-					rv = p.getProgramContext().getRegisterValue(contextReg,
-							paddr);
+					rv = p.getProgramContext()
+							.getRegisterValue(contextReg,
+								paddr);
 					p.getProgramContext().setRegisterValue(ba, ba_end, rv);
 				}
 			}
@@ -89,13 +90,14 @@ public void cleanup(Address ba) throws Exception {
 			Function f = getFunctionBefore(ba);
 			if (f != null) {
 				CreateFunctionCmd cf = new CreateFunctionCmd(f.getName(), f
-						.getEntryPoint(), null, f.getSymbol().getSource(),
-						true, true);
+						.getEntryPoint(),
+					null, f.getSymbol().getSource(),
+					true, true);
 				cf.applyTo(p);
 			}
 			bmgr.removeBookmark(bm);
 			bmgr.setBookmark(ba, "Analysis", "Cleanup",
-					"Converted invalid pointer to code");
+				"Converted invalid pointer to code");
 		}
 	}
 }
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/GetSymbolForDynamicAddress.java b/Ghidra/Features/FileFormats/ghidra_scripts/GetSymbolForDynamicAddress.java
index adb46c850ac..548dad0b408 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/GetSymbolForDynamicAddress.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/GetSymbolForDynamicAddress.java
@@ -4,16 +4,16 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-//@category iOS
+//@category Apple.iOS
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/MachoProcessBindScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/MachoProcessBindScript.java
index 8042f288d1e..0eca9202668 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/MachoProcessBindScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/MachoProcessBindScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Processes Mach-O BIND information.
-//@category Mac OS X
+//@category Apple.Mac OS X
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -35,28 +35,29 @@ public class MachoProcessBindScript extends GhidraScript {
 
 	@Override
 	public void run() throws Exception {
-		File file = new File( currentProgram.getExecutablePath() );
-		if ( !file.exists() ) {
-			file = askFile( "Please select original file used to import this program:", "Original File" );
+		File file = new File(currentProgram.getExecutablePath());
+		if (!file.exists()) {
+			file = askFile("Please select original file used to import this program:",
+				"Original File");
 		}
 		if (file == null) {
 			popup("File cannot be null");
 			return;
 		}
-		if ( !file.exists() ) {
-			popup( "Cannot find original binary at \n" + file.getAbsolutePath() );
+		if (!file.exists()) {
+			popup("Cannot find original binary at \n" + file.getAbsolutePath());
 			return;
 		}
-		ByteProvider provider = new RandomAccessByteProvider( file ) ;
+		ByteProvider provider = new RandomAccessByteProvider(file);
 		try {
 			MachHeader header = new MachHeader(provider);
 			header.parse();
-			List<DyldInfoCommand> commands = header.getLoadCommands( DyldInfoCommand.class );
-			for ( DyldInfoCommand command : commands ) {
-				if ( monitor.isCancelled() ) {
+			List<DyldInfoCommand> commands = header.getLoadCommands(DyldInfoCommand.class);
+			for (DyldInfoCommand command : commands) {
+				if (monitor.isCancelled()) {
 					break;
 				}
-				processCommand( header, provider, command );
+				processCommand(header, provider, command);
 			}
 		}
 		finally {
@@ -64,37 +65,39 @@ public void run() throws Exception {
 		}
 	}
 
-	private void processCommand( MachHeader header, ByteProvider provider, DyldInfoCommand command ) throws Exception {
+	private void processCommand(MachHeader header, ByteProvider provider, DyldInfoCommand command)
+			throws Exception {
 
 		BindState bind = new BindState();
 		bind.header = header;
 
 		try {
 			boolean done = false;
-			
-			byte [] commandBytes = provider.readBytes( command.getBindOffset(), command.getBindSize() );
-			ByteArrayInputStream byteServer = new ByteArrayInputStream( commandBytes );
 
-			while ( !done ) {
+			byte[] commandBytes =
+				provider.readBytes(command.getBindOffset(), command.getBindSize());
+			ByteArrayInputStream byteServer = new ByteArrayInputStream(commandBytes);
 
-				if ( monitor.isCancelled() ) {
+			while (!done) {
+
+				if (monitor.isCancelled()) {
 					break;
 				}
 
 				int value = byteServer.read();
 
-				if ( value == -1 ) {
+				if (value == -1) {
 					break;
 				}
 
 				byte b = (byte) value;
 
-				int opcode    = b & DyldInfoCommandConstants.BIND_OPCODE_MASK;
+				int opcode = b & DyldInfoCommandConstants.BIND_OPCODE_MASK;
 				int immediate = b & DyldInfoCommandConstants.BIND_IMMEDIATE_MASK;
 
-				switch ( opcode ) {
+				switch (opcode) {
 					case DyldInfoCommandConstants.BIND_OPCODE_ADD_ADDR_ULEB: {
-						bind.segmentOffset += uleb128( byteServer );
+						bind.segmentOffset += uleb128(byteServer);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_DO_BIND: {
@@ -104,18 +107,20 @@ private void processCommand( MachHeader header, ByteProvider provider, DyldInfoC
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED: {
 						bind.doBind();
-						bind.segmentOffset += ( immediate * currentProgram.getDefaultPointerSize() ) + currentProgram.getDefaultPointerSize();
+						bind.segmentOffset += (immediate * currentProgram.getDefaultPointerSize()) +
+							currentProgram.getDefaultPointerSize();
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: {
 						bind.doBind();
-						bind.segmentOffset += uleb128( byteServer ) + currentProgram.getDefaultPointerSize();
+						bind.segmentOffset +=
+							uleb128(byteServer) + currentProgram.getDefaultPointerSize();
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB: {
-						long count = uleb128( byteServer );
-						long skip  = uleb128( byteServer );
-						for ( int i = 0 ; i < count ; ++i ) {
+						long count = uleb128(byteServer);
+						long skip = uleb128(byteServer);
+						for (int i = 0; i < count; ++i) {
 							bind.doBind();
 							bind.segmentOffset += skip + currentProgram.getDefaultPointerSize();
 						}
@@ -126,41 +131,43 @@ private void processCommand( MachHeader header, ByteProvider provider, DyldInfoC
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_ADDEND_SLEB: {
-						bind.addend = sleb128( byteServer );
+						bind.addend = sleb128(byteServer);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_DYLIB_ORDINAL_IMM: {
 						bind.libraryOrdinal = immediate;
-						bind.fromDylib = getOrdinalName( bind );
+						bind.fromDylib = getOrdinalName(bind);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB: {
-						bind.libraryOrdinal = (int) uleb128( byteServer );
-						bind.fromDylib = getOrdinalName( bind );
+						bind.libraryOrdinal = (int) uleb128(byteServer);
+						bind.fromDylib = getOrdinalName(bind);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: {
 						//the special ordinals are negative numbers
-						if ( immediate == 0 ) {
+						if (immediate == 0) {
 							bind.libraryOrdinal = 0;
 						}
 						else {
-							byte signExtended = (byte) ( DyldInfoCommandConstants.BIND_OPCODE_MASK | immediate );
+							byte signExtended =
+								(byte) (DyldInfoCommandConstants.BIND_OPCODE_MASK | immediate);
 							bind.libraryOrdinal = signExtended;
 						}
-						bind.fromDylib = getOrdinalName( bind );
+						bind.fromDylib = getOrdinalName(bind);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: {
 						bind.segmentIndex = immediate;
-						bind.segmentStartAddress = getSegmentStartAddress( bind );
-						bind.segmentName = getSegmentName( bind );
-						bind.segmentOffset = uleb128( byteServer );
+						bind.segmentStartAddress = getSegmentStartAddress(bind);
+						bind.segmentName = getSegmentName(bind);
+						bind.segmentOffset = uleb128(byteServer);
 						break;
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {
-						bind.symbolName = readString( byteServer );
-						if ( ( immediate & DyldInfoCommandConstants.BIND_SYMBOL_FLAGS_WEAK_IMPORT ) != 0 ) {
+						bind.symbolName = readString(byteServer);
+						if ((immediate &
+							DyldInfoCommandConstants.BIND_SYMBOL_FLAGS_WEAK_IMPORT) != 0) {
 							bind.weak = true;
 						}
 						else {
@@ -170,51 +177,51 @@ private void processCommand( MachHeader header, ByteProvider provider, DyldInfoC
 					}
 					case DyldInfoCommandConstants.BIND_OPCODE_SET_TYPE_IMM: {
 						bind.type = immediate;
-						bind.typeName = getTypeName( bind );
+						bind.typeName = getTypeName(bind);
 						break;
 					}
 					default: {
-						popup( "unknown bind opcode " + Integer.toHexString( opcode ) );
+						popup("unknown bind opcode " + Integer.toHexString(opcode));
 						return;
 					}
 				}
 			}
 		}
 		finally {
-		}		
+		}
 	}
 
-	private String readString( ByteArrayInputStream byteServer ) {
+	private String readString(ByteArrayInputStream byteServer) {
 		StringBuffer buffer = new StringBuffer();
-		while ( !monitor.isCancelled() ) {
+		while (!monitor.isCancelled()) {
 			int value = byteServer.read();
-			if ( value == -1 ) {
+			if (value == -1) {
 				break;
 			}
 			byte b = (byte) value;
-			if ( b == '\0' ) {
+			if (b == '\0') {
 				break;
 			}
-			buffer.append( (char) ( b & 0xff ) );
+			buffer.append((char) (b & 0xff));
 		}
-		System.out.println( buffer.toString() );
+		System.out.println(buffer.toString());
 		return buffer.toString();
 	}
 
-	private long getSegmentStartAddress( BindState bind )  {
-		List<SegmentCommand> segments = bind.header.getLoadCommands( SegmentCommand.class );
-		SegmentCommand segment = segments.get( bind.segmentIndex );
+	private long getSegmentStartAddress(BindState bind) {
+		List<SegmentCommand> segments = bind.header.getLoadCommands(SegmentCommand.class);
+		SegmentCommand segment = segments.get(bind.segmentIndex);
 		return segment.getVMaddress();
 	}
 
-	private String getSegmentName( BindState bind )  {
-		List<SegmentCommand> segments = bind.header.getLoadCommands( SegmentCommand.class );
-		SegmentCommand segment = segments.get( bind.segmentIndex );
+	private String getSegmentName(BindState bind) {
+		List<SegmentCommand> segments = bind.header.getLoadCommands(SegmentCommand.class);
+		SegmentCommand segment = segments.get(bind.segmentIndex);
 		return segment.getSegmentName();
 	}
 
-	private String getTypeName( BindState bind ) {
-		switch ( bind.type ) {
+	private String getTypeName(BindState bind) {
+		switch (bind.type) {
 			case DyldInfoCommandConstants.BIND_TYPE_POINTER: {
 				return "pointer";
 			}
@@ -225,11 +232,11 @@ private String getTypeName( BindState bind ) {
 				return "text_pcrel32";
 			}
 		}
-		throw new RuntimeException( "unknown type: " + Integer.toHexString( bind.type ) );
+		throw new RuntimeException("unknown type: " + Integer.toHexString(bind.type));
 	}
 
-	private String getOrdinalName( BindState bind ) {
-		switch ( bind.libraryOrdinal ) {
+	private String getOrdinalName(BindState bind) {
+		switch (bind.libraryOrdinal) {
 			case DyldInfoCommandConstants.BIND_SPECIAL_DYLIB_SELF: {
 				return "this-image";
 			}
@@ -240,14 +247,15 @@ private String getOrdinalName( BindState bind ) {
 				return "flat-namespace";
 			}
 		}
-		if ( bind.libraryOrdinal < DyldInfoCommandConstants.BIND_SPECIAL_DYLIB_FLAT_LOOKUP ) {
-			return "unknown special ordinal" + Integer.toHexString( bind.libraryOrdinal );
+		if (bind.libraryOrdinal < DyldInfoCommandConstants.BIND_SPECIAL_DYLIB_FLAT_LOOKUP) {
+			return "unknown special ordinal" + Integer.toHexString(bind.libraryOrdinal);
 		}
-		List<DynamicLibraryCommand> dylibCommands = bind.header.getLoadCommands( DynamicLibraryCommand.class );
-		if ( bind.libraryOrdinal > dylibCommands.size() ) {
-			return "library ordinal out of range" + Integer.toHexString( bind.libraryOrdinal );
+		List<DynamicLibraryCommand> dylibCommands =
+			bind.header.getLoadCommands(DynamicLibraryCommand.class);
+		if (bind.libraryOrdinal > dylibCommands.size()) {
+			return "library ordinal out of range" + Integer.toHexString(bind.libraryOrdinal);
 		}
-		DynamicLibraryCommand dylibCommand = dylibCommands.get( bind.libraryOrdinal - 1 );
+		DynamicLibraryCommand dylibCommand = dylibCommands.get(bind.libraryOrdinal - 1);
 		DynamicLibrary dynamicLibrary = dylibCommand.getDynamicLibrary();
 		LoadCommandString name = dynamicLibrary.getName();
 		return name.getString();
@@ -256,15 +264,15 @@ private String getOrdinalName( BindState bind ) {
 	/**
 	 * Unsigned Little-endian Base-128
 	 */
-	private long uleb128( ByteArrayInputStream byteServer ) throws Exception {
+	private long uleb128(ByteArrayInputStream byteServer) throws Exception {
 		long result = 0;
-		int  bit    = 0;
+		int bit = 0;
 
-		while ( !monitor.isCancelled() ) {
+		while (!monitor.isCancelled()) {
 
 			int value = byteServer.read();
 
-			if ( value == -1 ) {
+			if (value == -1) {
 				break;
 			}
 
@@ -272,16 +280,16 @@ private long uleb128( ByteArrayInputStream byteServer ) throws Exception {
 
 			long slice = b & 0x7f;
 
-			if ( ( b & 0x80 ) == 0x80 ) {//if upper bit is set
-				if ( bit >= 64 || slice << bit >> bit != slice ) {//then left shift and right shift
-					throw new RuntimeException( "uleb128 too big" );
+			if ((b & 0x80) == 0x80) {//if upper bit is set
+				if (bit >= 64 || slice << bit >> bit != slice) {//then left shift and right shift
+					throw new RuntimeException("uleb128 too big");
 				}
 			}
 
-			result |= ( slice << bit );
+			result |= (slice << bit);
 			bit += 7;
 
-			if ( ( b & 0x80 ) == 0 ) {//if upper bit NOT set, then we are done
+			if ((b & 0x80) == 0) {//if upper bit NOT set, then we are done
 				break;
 			}
 		}
@@ -291,23 +299,23 @@ private long uleb128( ByteArrayInputStream byteServer ) throws Exception {
 	/**
 	 * Signed Little-endian Base-128
 	 */
-	private long sleb128( ByteArrayInputStream byteServer ) throws Exception {
+	private long sleb128(ByteArrayInputStream byteServer) throws Exception {
 		long result = 0;
-		int  bit    = 0;
-		while ( !monitor.isCancelled() ) {
+		int bit = 0;
+		while (!monitor.isCancelled()) {
 
 			int value = byteServer.read();
 
-			if ( value == -1 ) {
+			if (value == -1) {
 				break;
 			}
 
 			byte nextByte = (byte) value;
 
-			result |= ( ( nextByte & 0x7f ) << bit );
+			result |= ((nextByte & 0x7f) << bit);
 			bit += 7;
 
-			if ( ( nextByte & 0x80 ) == 0 ) {
+			if ((nextByte & 0x80) == 0) {
 				break;
 			}
 		}
@@ -339,51 +347,51 @@ String print() {
 
 			String sectionName = "no section";
 			List<Section> sections = header.getAllSections();
-			for ( Section section : sections ) {
+			for (Section section : sections) {
 				long start = section.getAddress();
-				long end   = section.getAddress() + section.getSize();
-				if ( sectionAddress.getOffset()  >= start && sectionAddress.getOffset() < end ) {
+				long end = section.getAddress() + section.getSize();
+				if (sectionAddress.getOffset() >= start && sectionAddress.getOffset() < end) {
 					sectionName = section.getSectionName();
 				}
 			}
 
-			File file = new File( fromDylib );
+			File file = new File(fromDylib);
 
 			StringBuffer buffer = new StringBuffer();
-			buffer.append(  segmentName );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
+			buffer.append(segmentName);
+			buffer.append(' ');
+			buffer.append(' ');
 			buffer.append(StringUtilities.pad(sectionName, ' ', -20));
-			buffer.append( ' ' );
-			buffer.append( ' ' );
-			buffer.append( sectionAddress );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
-			buffer.append( typeName );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
-			buffer.append( weak );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
-			buffer.append( addend );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
+			buffer.append(' ');
+			buffer.append(' ');
+			buffer.append(sectionAddress);
+			buffer.append(' ');
+			buffer.append(' ');
+			buffer.append(typeName);
+			buffer.append(' ');
+			buffer.append(' ');
+			buffer.append(weak);
+			buffer.append(' ');
+			buffer.append(' ');
+			buffer.append(addend);
+			buffer.append(' ');
+			buffer.append(' ');
 			buffer.append(StringUtilities.pad(file.getName(), ' ', -20));
-			buffer.append( ' ' );
-			buffer.append( ' ' );
-			buffer.append( symbolName );
-			buffer.append( ' ' );
-			buffer.append( ' ' );
+			buffer.append(' ');
+			buffer.append(' ');
+			buffer.append(symbolName);
+			buffer.append(' ');
+			buffer.append(' ');
 			return buffer.toString();
 		}
 
 		void doBind() throws Exception {
-			monitor.setMessage( "Performing bind: " + symbolName );
+			monitor.setMessage("Performing bind: " + symbolName);
 
-			SymbolIterator symbolIterator = currentProgram.getSymbolTable().getSymbols( symbolName );
+			SymbolIterator symbolIterator = currentProgram.getSymbolTable().getSymbols(symbolName);
 
-			if ( !symbolIterator.hasNext() ) {
-				printerr( "Not found: " + symbolName );
+			if (!symbolIterator.hasNext()) {
+				printerr("Not found: " + symbolName);
 				return;
 			}
 
@@ -391,22 +399,25 @@ void doBind() throws Exception {
 
 			long offset = symbol.getAddress().getOffset();
 
-			DataConverter converter = DataConverter.getInstance(currentProgram.getLanguage().isBigEndian());
+			DataConverter converter =
+				DataConverter.getInstance(currentProgram.getLanguage().isBigEndian());
 
-			if ( currentProgram.getDefaultPointerSize() == 8 ) {
-				setBytes( getAddress(), converter.getBytes( offset ) );
+			if (currentProgram.getDefaultPointerSize() == 8) {
+				setBytes(getAddress(), converter.getBytes(offset));
 			}
 			else {
-				setBytes( getAddress(), converter.getBytes( (int)offset ) );
+				setBytes(getAddress(), converter.getBytes((int) offset));
 			}
 
-			Reference reference = currentProgram.getReferenceManager().addMemoryReference( getAddress(), symbol.getAddress(), RefType.READ, SourceType.IMPORTED, 0 );
-			currentProgram.getReferenceManager().setPrimary( reference, true );
+			Reference reference = currentProgram.getReferenceManager()
+					.addMemoryReference(getAddress(), symbol.getAddress(), RefType.READ,
+						SourceType.IMPORTED, 0);
+			currentProgram.getReferenceManager().setPrimary(reference, true);
 		}
 
 		Address getAddress() {
 			long result = segmentStartAddress + segmentOffset;//TODO
-			Address sectionAddress = toAddr( result & 0xffffffffL );
+			Address sectionAddress = toAddr(result & 0xffffffffL);
 			return sectionAddress;
 		}
 	}
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/PointerPullerScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/PointerPullerScript.java
index 3d280d9735b..b65e25a5a6d 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/PointerPullerScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/PointerPullerScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 //Pulls symbol name through pointer references.
-//@category Mac OS X
+//@category Apple.Mac OS X
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
@@ -97,8 +97,9 @@ private Namespace getNameSpaceForData(Data data)
 		}
 		Namespace nameSpace = getNamespace(null, nameSpaceName);
 		if (nameSpace == null) {
-			nameSpace = currentProgram.getSymbolTable().createNameSpace(null, nameSpaceName,
-				SourceType.ANALYSIS);
+			nameSpace = currentProgram.getSymbolTable()
+					.createNameSpace(null, nameSpaceName,
+						SourceType.ANALYSIS);
 		}
 		return nameSpace;
 	}
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/RemoveAllOffcutReferencesScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/RemoveAllOffcutReferencesScript.java
index f42033bf8db..8c8a0ed9f4d 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/RemoveAllOffcutReferencesScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/RemoveAllOffcutReferencesScript.java
@@ -1,20 +1,19 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-//@category References
+//@category
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
@@ -23,31 +22,31 @@
 import ghidra.program.model.listing.Listing;
 import ghidra.program.model.symbol.*;
 
-
 public class RemoveAllOffcutReferencesScript extends GhidraScript {
 
 	@Override
 	public void run() throws Exception {
 		Listing listing = currentProgram.getListing();
 		ReferenceManager referenceManager = currentProgram.getReferenceManager();
-		AddressIterator iterator = referenceManager.getReferenceDestinationIterator(currentProgram.getMinAddress(), true);
+		AddressIterator iterator =
+			referenceManager.getReferenceDestinationIterator(currentProgram.getMinAddress(), true);
 		while (iterator.hasNext()) {
 			if (monitor.isCancelled()) {
 				break;
 			}
-	 		Address address = iterator.next();
- 			CodeUnit codeUnit = listing.getCodeUnitContaining(address);
- 			if (codeUnit != null) {
- 				if (!codeUnit.getMinAddress().equals(address)) {
- 					monitor.setMessage("Removing offcut reference at "+address);
- 			 		ReferenceIterator referencesTo = referenceManager.getReferencesTo(address);
- 			 		while (referencesTo.hasNext()) {
- 			 			if (monitor.isCancelled()) {
- 							break;
- 						}
- 			 			Reference reference = referencesTo.next();
- 			 			referenceManager.delete(reference);
- 			 		}
+			Address address = iterator.next();
+			CodeUnit codeUnit = listing.getCodeUnitContaining(address);
+			if (codeUnit != null) {
+				if (!codeUnit.getMinAddress().equals(address)) {
+					monitor.setMessage("Removing offcut reference at " + address);
+					ReferenceIterator referencesTo = referenceManager.getReferencesTo(address);
+					while (referencesTo.hasNext()) {
+						if (monitor.isCancelled()) {
+							break;
+						}
+						Reference reference = referencesTo.next();
+						referenceManager.delete(reference);
+					}
 				}
 			}
 		}
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/RemoveOffcutReferenceToCurrentInstructionScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/RemoveOffcutReferenceToCurrentInstructionScript.java
index 0dea00a44af..d0bc11a04aa 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/RemoveOffcutReferenceToCurrentInstructionScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/RemoveOffcutReferenceToCurrentInstructionScript.java
@@ -1,13 +1,12 @@
 /* ###
  * IP: GHIDRA
- * REVIEWED: YES
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +14,7 @@
  * limitations under the License.
  */
 //Removes any offcut references to the current code unit.
-//@category References
+//@category
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
@@ -29,38 +28,38 @@ public void run() throws Exception {
 
 		Instruction instruction = getInstructionAt(currentAddress);
 
-		if ( instruction != null ) {
-			removeReferences( instruction );
+		if (instruction != null) {
+			removeReferences(instruction);
 		}
 
 		Data data = getDataAt(currentAddress);
 
-		if ( data != null ) {
-			removeReferences( data );
+		if (data != null) {
+			removeReferences(data);
 		}
 	}
 
 	private void removeReferences(CodeUnit codeUnit) {
-		Address address = currentAddress.add( 1 );
+		Address address = currentAddress.add(1);
 
-		while ( address.compareTo( codeUnit.getMaxAddress() ) <= 0) {
+		while (address.compareTo(codeUnit.getMaxAddress()) <= 0) {
 
-			if ( monitor.isCancelled() ) {
+			if (monitor.isCancelled()) {
 				break;
 			}
 
-			Reference [] referencesTo = getReferencesTo(address);
+			Reference[] referencesTo = getReferencesTo(address);
 
-			for ( Reference reference : referencesTo ) {
+			for (Reference reference : referencesTo) {
 
-				if ( monitor.isCancelled() ) {
+				if (monitor.isCancelled()) {
 					break;
 				}
 
 				removeReference(reference);
 			}
 
-			address = address.add( 1 );
+			address = address.add(1);
 		}
 	}
 }
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java b/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
index c6126275e00..8a61faeedfb 100644
--- a/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
+++ b/Ghidra/Features/FileFormats/ghidra_scripts/ResolveReferencesRelativeToEbxScript.java
@@ -15,7 +15,7 @@
  */
 //Resolves relative references computed off EBX. 
 //This will resolve references to strings in the "__cstring" section.
-//@category Mac OS X
+//@category Apple.Mac OS X
 
 import ghidra.app.script.GhidraScript;
 import ghidra.program.model.address.Address;
@@ -36,19 +36,19 @@ public void run() throws Exception {
 
 		FunctionIterator functions = currentProgram.getListing().getFunctions(true);
 
-		while ( functions.hasNext() ) {
+		while (functions.hasNext()) {
 
-			if ( monitor.isCancelled() ) {
+			if (monitor.isCancelled()) {
 				break;
 			}
 
 			Function function = functions.next();
 
-			monitor.setMessage( function.getName() );
+			monitor.setMessage(function.getName());
 
-			loopOverInstructionsInFunction( function );
+			loopOverInstructionsInFunction(function);
 
-			function = getFunctionAfter( function );
+			function = getFunctionAfter(function);
 		}
 	}
 
@@ -57,50 +57,53 @@ private void loopOverInstructionsInFunction(Function function) {
 
 		long ebx = -1;
 
-		InstructionIterator instructions = currentProgram.getListing().getInstructions( function.getBody(), true ) ;
+		InstructionIterator instructions =
+			currentProgram.getListing().getInstructions(function.getBody(), true);
 
-		while ( instructions.hasNext() ) {
+		while (instructions.hasNext()) {
 
 			Instruction instruction = instructions.next();
 
-			if ( monitor.isCancelled() ) {
+			if (monitor.isCancelled()) {
 				break;
 			}
 
-			if ( ebx == -1 ) {
-				ebx = getValueForEBX( instruction );
+			if (ebx == -1) {
+				ebx = getValueForEBX(instruction);
 			}
 
-			if ( ebx == -1 ) {
+			if (ebx == -1) {
 				continue;
 			}
 
-			for (int i = 0 ; i < instruction.getNumOperands() ; ++i ) {
+			for (int i = 0; i < instruction.getNumOperands(); ++i) {
 
-				Object [] opObjects = instruction.getOpObjects(i);
+				Object[] opObjects = instruction.getOpObjects(i);
 
-				if ( opObjects.length == 2 ) {
+				if (opObjects.length == 2) {
 
-					if (opObjects[ 0 ] instanceof Scalar && opObjects[ 1 ] instanceof Register ) {
+					if (opObjects[0] instanceof Scalar && opObjects[1] instanceof Register) {
 
- 						Scalar scalar = (Scalar) opObjects[ 0 ];
+						Scalar scalar = (Scalar) opObjects[0];
 
-						Register register = (Register) opObjects[ 1 ];
+						Register register = (Register) opObjects[1];
 
-						if ( register.equals( EBX ) ) {
+						if (register.equals(EBX)) {
 
 							Address address =
 								toAddr((ebx + scalar.getUnsignedValue()) & 0x00000000ffffffffL);
 
-							if ( isValid( address ) ) {
+							if (isValid(address)) {
 
 								removeReferencesFrom(instruction);
 
-								Reference reference = createMemoryReference( instruction, 1, address, RefType.DATA );
+								Reference reference =
+									createMemoryReference(instruction, 1, address, RefType.DATA);
 
-								setReferencePrimary( reference );
+								setReferencePrimary(reference);
 
-								println( "Creating reference from " + instruction.getMinAddress() + " to " + address );
+								println("Creating reference from " + instruction.getMinAddress() +
+									" to " + address);
 							}
 						}
 					}
@@ -111,43 +114,43 @@ private void loopOverInstructionsInFunction(Function function) {
 
 	private boolean isValid(Address address) {
 
-		Instruction instruction = getInstructionContaining( address );
-		if ( instruction != null ) {
+		Instruction instruction = getInstructionContaining(address);
+		if (instruction != null) {
 			Address min = instruction.getMinAddress();
-			if ( address.compareTo( min ) > 0 ) {
+			if (address.compareTo(min) > 0) {
 				return false; //off-cut
 			}
 		}
 
-		Data data = getDataContaining( address );
-		if ( data != null ) {
+		Data data = getDataContaining(address);
+		if (data != null) {
 			Address min = data.getMinAddress();
-			if ( address.compareTo( min ) > 0 ) {
+			if (address.compareTo(min) > 0) {
 				return false; //off-cut
 			}
 		}
 
-		return currentProgram.getMemory().contains( address );
+		return currentProgram.getMemory().contains(address);
 	}
 
 	private void removeReferencesFrom(Instruction instruction) {
-		Reference [] referencesFrom = instruction.getReferencesFrom();
+		Reference[] referencesFrom = instruction.getReferencesFrom();
 		for (Reference reference : referencesFrom) {
-			removeReference( reference );
+			removeReference(reference);
 		}
 	}
 
 	private long getValueForEBX(Instruction instruction) {
 
-		if ( instruction.getMnemonicString().equals( "CALL" ) ) {
+		if (instruction.getMnemonicString().equals("CALL")) {
 
-			Address nextInstructionAddress = instruction.getMaxAddress().add( 1 );
+			Address nextInstructionAddress = instruction.getMaxAddress().add(1);
 
-			Reference [] referencesFrom = instruction.getReferencesFrom();
+			Reference[] referencesFrom = instruction.getReferencesFrom();
 
-			if ( referencesFrom.length == 1) {
+			if (referencesFrom.length == 1) {
 
-				if ( referencesFrom[0].getToAddress().equals( nextInstructionAddress ) ) {
+				if (referencesFrom[0].getToAddress().equals(nextInstructionAddress)) {
 
 					return nextInstructionAddress.getOffset();
 				}
diff --git a/Ghidra/Features/FileFormats/ghidra_scripts/UpgradeDexToGhidra71Script.java b/Ghidra/Features/FileFormats/ghidra_scripts/UpgradeDexToGhidra71Script.java
deleted file mode 100644
index e1d5099ed2d..00000000000
--- a/Ghidra/Features/FileFormats/ghidra_scripts/UpgradeDexToGhidra71Script.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-//Upgrade DEX program(s) that have function prototypes layed down prior to Ghidra 7.1 
-//@category    Upgrade
-
-import java.util.Map;
-
-import ghidra.app.cmd.function.ApplyFunctionSignatureCmd;
-import ghidra.app.script.GhidraScript;
-import ghidra.framework.model.*;
-import ghidra.framework.plugintool.PluginTool;
-import ghidra.program.model.address.AddressSpace;
-import ghidra.program.model.data.FunctionDefinitionDataType;
-import ghidra.program.model.lang.*;
-import ghidra.program.model.listing.*;
-import ghidra.program.model.pcode.Varnode;
-import ghidra.program.model.symbol.SourceType;
-import ghidra.util.exception.*;
-
-/**
- * There was a major rearrangement of registers in the Dalvik.slaspec from 7.0 -> 7.1 which invalidates function prototypes
- * laid down by "Android DEX Header Format" analyzer.  This script repairs the prototypes to match the new register layout
- * If run with a Program already up, the script will make all the changes, letting the user decide if they want to
- * save (or undo) the changes.  If the script is run from an empty code browser, it will search for all Dalvik programs
- * in the current project and automatically upgrade and save the function prototypes.
- *
- */
-public class UpgradeDexToGhidra71Script extends GhidraScript {
-
-    @Override
-    public void run() throws Exception {
-        
-        if ( currentProgram != null ) {
-            processProgram(currentProgram);
-            return;
-        }
-        
-        PluginTool tool = state.getTool();
-        Project project = tool.getProject();
-        ProjectData projectData = project.getProjectData();
-        DomainFolder rootFolder = projectData.getRootFolder();
-        recurseProjectFolder( rootFolder );
-    }
-    
-    private void recurseProjectFolder( DomainFolder domainFolder ) throws Exception {
-        DomainFile[] files = domainFolder.getFiles();
-        for ( DomainFile domainFile : files ) {
-        	monitor.checkCancelled();
-        	try {
-        		processDomainFile( domainFile );
-        	} catch(Exception ex) {
-        		printerr(ex.getMessage());
-        	}
-        }
-        DomainFolder[] folders = domainFolder.getFolders();
-        for ( DomainFolder folder : folders ) {
-        	monitor.checkCancelled();
-            recurseProjectFolder( folder );
-        }
-    }
-    
-	private void processDomainFile(DomainFile domainFile ) throws Exception {
-		Map<String, String> metadata = domainFile.getMetadata();
-		if (metadata == null) {
-			return;
-		}
-		String formatString = metadata.get("Executable Format");
-		if (formatString == null) {
-			return;
-		}
-		if (!formatString.equals("Dalvik Executable (DEX)")) {
-			return;
-		}
-		DomainObject domainObject = domainFile.getDomainObject(this, true, true, monitor);
-		try {
-			Program program = (Program) domainObject;
-			processProgram(program);
-			saveProgram(program);
-		} finally {
-			domainObject.release(this);
-		}
-	}
-
-	private void processProgram(Program program) throws CancelledException {
-		println("Updating program: "+program.getName());
-		int id = program.startTransaction("Update DEX parameters");
-		boolean success = false;
-		try {
-			for (Function func : program.getFunctionManager().getFunctions(true)) {
-				monitor.checkCancelled();
-				processFunction(func);
-			}
-			success = true;
-		} finally {
-			program.endTransaction(id, success);
-		}
-	}
-
-	private void processFunction(Function func) {
-		monitor.setMessage("Updating: "+func.getName());
-		FunctionDefinitionDataType sig = new FunctionDefinitionDataType(func,false);
-		try {
-			sig.setCallingConvention(CompilerSpec.CALLING_CONVENTION_stdcall);
-		}
-		catch (InvalidInputException e) {
-			throw new AssertException(e);
-		}
-		func.setCustomVariableStorage(false);
-		ApplyFunctionSignatureCmd cmd = new ApplyFunctionSignatureCmd(func.getEntryPoint(),sig,SourceType.ANALYSIS);
-		cmd.applyTo(func.getProgram());
-		
-		Program program = func.getProgram();
-		Language language = program.getLanguage();
-		AddressSpace registerSpace = program.getAddressFactory().getRegisterSpace();
-		Variable[] localVariables = func.getLocalVariables();
-		
-		for (Variable var : localVariables) {
-			Varnode varnode = var.getFirstStorageVarnode();
-			if (!varnode.isRegister()) {
-				continue;
-			}
-			if (varnode.getOffset() >= 0x1000)
-			 {
-				continue;		// Already converted
-			}
-			long offset = varnode.getOffset() + 0x1000 - 8;
-			int size = varnode.getSize();
-			Register localRegister = language.getRegister(registerSpace, offset, size);
-			try {
-				LocalVariableImpl newlocal = new LocalVariableImpl( var.getName(), 0, var.getDataType(), localRegister, func.getProgram() );
-				func.removeVariable(var);
-				func.addLocalVariable(newlocal, SourceType.ANALYSIS);
-			} catch (InvalidInputException e) {
-			} catch (DuplicateNameException e) {
-			}
-			
-		}
-	}
-}
diff --git a/Ghidra/Features/GnuDemangler/ghidra_scripts/DemangleElfWithOptionScript.java b/Ghidra/Features/GnuDemangler/ghidra_scripts/DemangleElfWithOptionScript.java
index 7d5db9e56a4..ce8872f4b95 100644
--- a/Ghidra/Features/GnuDemangler/ghidra_scripts/DemangleElfWithOptionScript.java
+++ b/Ghidra/Features/GnuDemangler/ghidra_scripts/DemangleElfWithOptionScript.java
@@ -18,7 +18,7 @@
 // See binutils' c++filt for more information on supported options.
 
 //
-//@category Examples.Demangler
+//@category Demangler
 import ghidra.app.script.GhidraScript;
 import ghidra.app.util.demangler.DemangledObject;
 import ghidra.app.util.demangler.MangledContext;
diff --git a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_5_4.java b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_5_4.java
index 759e8e824f4..4128c0ec67a 100644
--- a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_5_4.java
+++ b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_5_4.java
@@ -44,7 +44,7 @@
 //                          script needs the address of that value to calculate
 //                          the symbol table's start address.
 //
-// @category CustomerSubmission.vxWorks
+// @category Customer Submission.vxWorks
 
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
diff --git a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_6_1.java b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_6_1.java
index 2bcc6678e54..058e41cd292 100644
--- a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_6_1.java
+++ b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_6_1.java
@@ -42,7 +42,7 @@
 //                          script needs the address of that value to calculate
 //                          the symbol table's start address.
 //
-// @category CustomerSubmission.vxWorks
+// @category Customer Submission.vxWorks
 
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
diff --git a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java
index 35bd3aa3328..e13b059914b 100644
--- a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java
+++ b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java
@@ -39,7 +39,7 @@
 //		- Modify getVxSymbolClass() to recognize your program's VxWorks
 //		  symbol table entry structure, if necessary
 //
-// @category VxWorks
+// @category Customer Submission.vxWorks
 
 import java.util.List;
 
diff --git a/Ghidra/Features/Jython/ghidra_scripts/ImportSymbolsScript.py b/Ghidra/Features/Jython/ghidra_scripts/ImportSymbolsScript.py
index ae4a5024838..e251c64c20b 100644
--- a/Ghidra/Features/Jython/ghidra_scripts/ImportSymbolsScript.py
+++ b/Ghidra/Features/Jython/ghidra_scripts/ImportSymbolsScript.py
@@ -1,17 +1,17 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 # Imports a text file containing symbol definitions, with a maximum of one symbol defined per line. Each symbol definition is in the form of "symbol_name address function_or_label", where "symbol_name" is the name of the symbol, "address" is the address of the symbol in one of the forms listed below, and "function_or_label" is either "f" or "l", with "f" indicating that a function is to be created and "l" indicating that a label is to be created.
 # Address formats are the same as those that can be used with the "Go to address" function. For example:
@@ -23,7 +23,7 @@
 # - MEMORY_REGION:0x1234abcd
 # Omitting the address space or memory region specifier from the address will result in the function or label being created in the default address space.
 # @author unkown; edited by matedealer <git@matedealer.de>
-# @category Data
+# @category Import
 # @runtime Jython
 #
 
diff --git a/Ghidra/Processors/DATA/ghidra_scripts/LoadDataScript.java b/Ghidra/Processors/DATA/ghidra_scripts/LoadDataScript.java
index 311839bbb61..945743f3852 100644
--- a/Ghidra/Processors/DATA/ghidra_scripts/LoadDataScript.java
+++ b/Ghidra/Processors/DATA/ghidra_scripts/LoadDataScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,7 +16,9 @@
 //Loads the same file as binary using each of the DATA languages.
 //Any DATA language can be used with any size file.
 //The only issues are the POINTER sizes and does the file fit in the memory space.
-//@category Processor.DATA
+//@category Languages
+
+import java.io.File;
 
 import ghidra.app.script.GhidraScript;
 import ghidra.language.data.DataLanguageHelper;
@@ -24,37 +26,41 @@
 import ghidra.program.model.lang.LanguageService;
 import ghidra.program.util.DefaultLanguageService;
 
-import java.io.File;
-
 public class LoadDataScript extends GhidraScript {
 
 	@Override
-	public void run( ) throws Exception {
+	public void run() throws Exception {
 
-		LanguageService languageService = DefaultLanguageService.getLanguageService( );
+		LanguageService languageService = DefaultLanguageService.getLanguageService();
 
-		LanguageCompilerSpecPair dataBE16 = DataLanguageHelper.getLanguage( languageService, 16, true );
-		LanguageCompilerSpecPair dataBE32 = DataLanguageHelper.getLanguage( languageService, 32, true );
-		LanguageCompilerSpecPair dataBE64 = DataLanguageHelper.getLanguage( languageService, 64, true );
+		LanguageCompilerSpecPair dataBE16 =
+			DataLanguageHelper.getLanguage(languageService, 16, true);
+		LanguageCompilerSpecPair dataBE32 =
+			DataLanguageHelper.getLanguage(languageService, 32, true);
+		LanguageCompilerSpecPair dataBE64 =
+			DataLanguageHelper.getLanguage(languageService, 64, true);
 
-		LanguageCompilerSpecPair dataLE16 = DataLanguageHelper.getLanguage( languageService, 16, false );
-		LanguageCompilerSpecPair dataLE32 = DataLanguageHelper.getLanguage( languageService, 32, false );
-		LanguageCompilerSpecPair dataLE64 = DataLanguageHelper.getLanguage( languageService, 64, false );
+		LanguageCompilerSpecPair dataLE16 =
+			DataLanguageHelper.getLanguage(languageService, 16, false);
+		LanguageCompilerSpecPair dataLE32 =
+			DataLanguageHelper.getLanguage(languageService, 32, false);
+		LanguageCompilerSpecPair dataLE64 =
+			DataLanguageHelper.getLanguage(languageService, 64, false);
 
-		File file = askFile( "Select DATA File", "OK" );
-		if ( file == null ) {
-			printerr( "No file selected, ending script." );
+		File file = askFile("Select DATA File", "OK");
+		if (file == null) {
+			printerr("No file selected, ending script.");
 			return;
 		}
 
-		openProgram( importFileAsBinary( file, dataBE16.getLanguage( ), dataBE16.getCompilerSpec( ) ) );
-		openProgram( importFileAsBinary( file, dataLE16.getLanguage( ), dataLE16.getCompilerSpec( ) ) );
+		openProgram(importFileAsBinary(file, dataBE16.getLanguage(), dataBE16.getCompilerSpec()));
+		openProgram(importFileAsBinary(file, dataLE16.getLanguage(), dataLE16.getCompilerSpec()));
 
-		openProgram( importFileAsBinary( file, dataBE32.getLanguage( ), dataBE32.getCompilerSpec( ) ) );
-		openProgram( importFileAsBinary( file, dataLE32.getLanguage( ), dataLE32.getCompilerSpec( ) ) );
+		openProgram(importFileAsBinary(file, dataBE32.getLanguage(), dataBE32.getCompilerSpec()));
+		openProgram(importFileAsBinary(file, dataLE32.getLanguage(), dataLE32.getCompilerSpec()));
 
-		openProgram( importFileAsBinary( file, dataBE64.getLanguage( ), dataBE64.getCompilerSpec( ) ) );
-		openProgram( importFileAsBinary( file, dataLE64.getLanguage( ), dataLE64.getCompilerSpec( ) ) );
+		openProgram(importFileAsBinary(file, dataBE64.getLanguage(), dataBE64.getCompilerSpec()));
+		openProgram(importFileAsBinary(file, dataLE64.getLanguage(), dataLE64.getCompilerSpec()));
 	}
 
 }
```
-----------------------------------
