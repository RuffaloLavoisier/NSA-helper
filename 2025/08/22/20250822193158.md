# Commit: 16a2e78806e36b3c183b8f08ea8a2886aff9685c
## Message: Merge remote-tracking branch 'origin/GP-5914-dragonmacher-symbol-tree-nav-fix'
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java
index d478ed55ec8..2855d4a4a11 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java
@@ -19,6 +19,7 @@
 import static ghidra.program.util.ProgramEvent.*;
 
 import java.awt.BorderLayout;
+import java.awt.Point;
 import java.awt.datatransfer.Clipboard;
 import java.awt.datatransfer.ClipboardOwner;
 import java.awt.event.MouseAdapter;
@@ -167,7 +168,8 @@ private SymbolGTree createTree(SymbolTreeRootNode rootNode) {
 				return;
 			}
 
-			maybeGoToSymbol();
+			SymbolNode symbolNode = getSelectedSymbolNode();
+			maybeGoToSymbol(symbolNode);
 			contextChanged();
 		});
 
@@ -175,14 +177,24 @@ private SymbolGTree createTree(SymbolTreeRootNode rootNode) {
 			@Override
 			public void mouseClicked(MouseEvent e) {
 
-				// This code serves to perform navigation in  the case that the selection handler
-				// above does not, as is the case when the node is already selected.  This code
-				// will get called on the mouse release, whereas the selection handler gets called
-				// on the mouse pressed.
+				// This code serves to perform navigation in the case that the selection handler
+				// above does not, as is the case when the clicked node is already selected.  This
+				// code will get called on the mouse clicked, whereas the selection handler gets 
+				// called on the mouse pressed.
 				// For now, just attempt to perform the goto.  It may get called twice, but this
 				// should have no real impact on performance.
+				Point p = e.getPoint();
+				GTreeNode clickedNode = newTree.getNodeForLocation(p.x, p.y);
+				if (clickedNode == null) {
+					return;
+				}
+
+				SymbolNode symbolNode = getSelectedSymbolNode();
+				if (!clickedNode.equals(symbolNode)) {
+					return;
+				}
 
-				maybeGoToSymbol();
+				maybeGoToSymbol(symbolNode);
 			}
 		});
 
@@ -211,19 +223,24 @@ protected void treeNodeCollapsed(TreePath path) {
 		}
 	}
 
-	private void maybeGoToSymbol() {
-
+	private SymbolNode getSelectedSymbolNode() {
 		TreePath[] paths = tree.getSelectionPaths();
 		if (paths == null || paths.length != 1) {
-			return;
+			return null;
 		}
 
 		Object object = paths[0].getLastPathComponent();
-		if (!(object instanceof SymbolNode)) {
-			return;
+		if (object instanceof SymbolNode symbolNode) {
+			return symbolNode;
 		}
 
-		SymbolNode node = (SymbolNode) object;
+		return null;
+	}
+
+	private void maybeGoToSymbol(SymbolNode node) {
+		if (node == null) {
+			return;
+		}
 		Symbol symbol = node.getSymbol();
 		SymbolType type = symbol.getSymbolType();
 		if (!type.isNamespace() || type == SymbolType.FUNCTION) {
```
-----------------------------------
