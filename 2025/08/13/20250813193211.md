# Commit: ce96f8551d69488558f55e69d54d512b48b62935
## Message: GP-5891: Include Debugger javadocs in the build.
## Diff:
```
diff --git a/Ghidra/Debug/Debugger-api/build.gradle b/Ghidra/Debug/Debugger-api/build.gradle
index 9d53c355f61..6a5af1d6acc 100644
--- a/Ghidra/Debug/Debugger-api/build.gradle
+++ b/Ghidra/Debug/Debugger-api/build.gradle
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,6 +18,7 @@ apply from: "${rootProject.projectDir}/gradle/javaProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 
 apply plugin: 'eclipse'
 eclipse.project.name = 'Debug Debugger-api'
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/DebuggerPlatformService.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/DebuggerPlatformService.java
index 0cf60bc3e63..296e3a9e44c 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/DebuggerPlatformService.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/DebuggerPlatformService.java
@@ -38,8 +38,8 @@ public interface DebuggerPlatformService {
 	 * <p>
 	 * If the trace's current mapper is applicable to the object, it will be returned. Otherwise,
 	 * the service will query the opinions for a new mapper, as in
-	 * {@link #getNewMapper(TraceObject)} and set it as the current mapper before returning. If a
-	 * new mapper is set, the trace is also initialized for that mapper.
+	 * {@link #getNewMapper(Trace, TraceObject, long)} and set it as the current mapper before
+	 * returning. If a new mapper is set, the trace is also initialized for that mapper.
 	 * 
 	 * @param trace the trace
 	 * @param object the object for which a mapper is desired
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeEmulatorFactory.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeEmulatorFactory.java
index 026acaccce9..6a825ffee6f 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeEmulatorFactory.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeEmulatorFactory.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,10 +22,6 @@
 
 /**
  * A factory for configuring and creating a Debugger-integrated emulator
- *
- * <p>
- * See {@link BytesDebuggerPcodeEmulatorFactory} for the default implementation. See the Taint
- * Analyzer for the archetype of alternative implementations.
  */
 public interface DebuggerPcodeEmulatorFactory extends ExtensionPoint {
 	// TODO: Config options, use ModelFactory as a model
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeMachine.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeMachine.java
index 5526ae01254..6fdc418491a 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeMachine.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/DebuggerPcodeMachine.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,10 +20,6 @@
 /**
  * A Debugger-integrated emulator (or p-code machine)
  *
- * <p>
- * A common implementation is an emulator with concrete plus some auxiliary state. To realize such a
- * machine, please see {@link AuxDebuggerPcodeEmulator} and {@link AuxDebuggerEmulatorPartsFactory}.
- *
  * @param <T> the type of values in the machine's memory and registers
  */
 public interface DebuggerPcodeMachine<T> extends TracePcodeMachine<T> {
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/PcodeDebuggerAccess.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/PcodeDebuggerAccess.java
index fb865c4fc84..266aabbe8f3 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/PcodeDebuggerAccess.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/emulation/PcodeDebuggerAccess.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,8 +26,7 @@
  * In addition to the trace "coordinates" encapsulated by {@link PcodeTraceAccess}, this
  * encapsulates the tool controlling a session and the session's target. This permits p-code
  * executor/emulator states to access target data and to access session data, e.g., data from mapped
- * static images. It supports the same method chain pattern as {@link PcodeTraceAccess}, but
- * starting with {@link DefaultPcodeDebuggerAccess}.
+ * static images. It supports the same method chain pattern as {@link PcodeTraceAccess}.
  */
 public interface PcodeDebuggerAccess extends PcodeTraceAccess {
 	@Override
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/target/Target.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/target/Target.java
index 2c47b9d11d0..b73df1886d3 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/target/Target.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/target/Target.java
@@ -519,8 +519,10 @@ CompletableFuture<Void> writeRegisterAsync(TracePlatform platform, TraceThread t
 	 * be recorded into the trace <em>before</em> this method returns. If the request is
 	 * unsuccessful, this method throw an exception.
 	 * 
-	 * @param address the starting address
-	 * @param data the bytes to write
+	 * @param platform the platform whose language defines the registers
+	 * @param thread the thread whose register to write
+	 * @param frame the frame level, usually 0.
+	 * @param value the register and value to write
 	 */
 	void writeRegister(TracePlatform platform, TraceThread thread, int frame, RegisterValue value);
 
@@ -548,7 +550,7 @@ void writeRegister(TracePlatform platform, TraceThread thread, int frame, Addres
 	 * @param thread if a register, the thread whose registers to examine
 	 * @param frame the frame level, usually 0.
 	 * @param address the address of the variable
-	 * @param size the size of the variable. Ignored for memory
+	 * @param length the size of the variable. Ignored for memory
 	 * @return true if the variable can be mapped to the target
 	 */
 	boolean isVariableExists(TracePlatform platform, TraceThread thread, int frame, Address address,
@@ -558,8 +560,7 @@ boolean isVariableExists(TracePlatform platform, TraceThread thread, int frame,
 	 * @see #writeVariable(TracePlatform, TraceThread, int, Address, byte[])
 	 */
 	CompletableFuture<Void> writeVariableAsync(TracePlatform platform, TraceThread thread,
-			int frame,
-			Address address, byte[] data);
+			int frame, Address address, byte[] data);
 
 	/**
 	 * Write a variable (memory or register) of the given thread or the process
@@ -571,7 +572,7 @@ CompletableFuture<Void> writeVariableAsync(TracePlatform platform, TraceThread t
 	 * {@link #writeMemory(Address, byte[])}.
 	 * 
 	 * @param thread the thread. Ignored (may be null) if address is in memory
-	 * @param frameLevel the frame, usually 0. Ignored if address is in memory
+	 * @param frame the frame, usually 0. Ignored if address is in memory
 	 * @param address the starting address
 	 * @param data the value to write
 	 */
@@ -665,7 +666,8 @@ CompletableFuture<Void> toggleBreakpointAsync(TraceBreakpointCommon breakpoint,
 	 * This will first attempt to kill the target gracefully. In addition, and whether or not the
 	 * target is successfully terminated, the target will be dissociated from its trace, and the
 	 * target will be invalidated. To attempt only a graceful termination, check
-	 * {@link #collectActions(ActionName, ActionContext)} with {@link ActionName#KILL}.
+	 * {@link #collectActions(ActionName, ActionContext, ObjectArgumentPolicy)} with
+	 * {@link ActionName#KILL}.
 	 */
 	void forceTerminate();
 
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/RemoteMethod.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/RemoteMethod.java
index e4325badd74..5f37869782a 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/RemoteMethod.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/RemoteMethod.java
@@ -117,7 +117,7 @@ public interface RemoteMethod {
 	 * Check the type of an argument.
 	 * 
 	 * <p>
-	 * This is a hack, because {@link TraceObjectSchema} expects {@link TargetObject}, or a
+	 * This is a hack, because {@link TraceObjectSchema} expects {@link TraceObject}, or a
 	 * primitive. We instead need {@link TraceObject}. I'd add the method to the schema, except that
 	 * trace stuff is not in its dependencies.
 	 * 
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiAcceptor.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiAcceptor.java
index ece13a58cf5..12f6fbc8b4d 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiAcceptor.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiAcceptor.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -34,6 +34,7 @@ public interface TraceRmiAcceptor {
 	 * 
 	 * @return the connection, if successful
 	 * @throws IOException if there was an error
+	 * @throws CancelledException if {@link #cancel()} is called, usually from the user canceling
 	 */
 	TraceRmiConnection accept() throws IOException, CancelledException;
 
@@ -64,8 +65,8 @@ public interface TraceRmiAcceptor {
 	 * 
 	 * <p>
 	 * If a different thread has called {@link #accept()}, it will fail. In this case, both
-	 * {@linkplain TraceRmiServiceListener#acceptCancelled(TraceRmiAcceptor)} and
-	 * {@linkplain TraceRmiServiceListener#acceptFailed(Exception)} may be invoked.
+	 * {@link TraceRmiServiceListener#acceptCancelled(TraceRmiAcceptor)} and
+	 * {@link TraceRmiServiceListener#acceptFailed(TraceRmiAcceptor, Exception)} may be invoked.
 	 */
 	void cancel();
 }
diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiServiceListener.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiServiceListener.java
index 24034ded05e..ed5bafc8263 100644
--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiServiceListener.java
+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/debug/api/tracermi/TraceRmiServiceListener.java
@@ -86,8 +86,9 @@ default void disconnected(TraceRmiConnection connection) {
 	 * 
 	 * <p>
 	 * The acceptor remains valid until one of three events occurs:
-	 * {@linkplain} #connected(TraceRmiConnection, ConnectMode, TraceRmiAcceptor)},
-	 * {@linkplain} #acceptCancelled(TraceRmiAcceptor)}, or {@linkplain} #acceptFailed(Exception)}.
+	 * {@link #connected(TraceRmiConnection, ConnectMode, TraceRmiAcceptor)},
+	 * {@link #acceptCancelled(TraceRmiAcceptor)}, or
+	 * {@link #acceptFailed(TraceRmiAcceptor, Exception)}.
 	 * 
 	 * @param acceptor the acceptor waiting
 	 */
diff --git a/Ghidra/Debug/Debugger-rmi-trace/build.gradle b/Ghidra/Debug/Debugger-rmi-trace/build.gradle
index 8fa654b6c51..8fda8790ebf 100644
--- a/Ghidra/Debug/Debugger-rmi-trace/build.gradle
+++ b/Ghidra/Debug/Debugger-rmi-trace/build.gradle
@@ -19,6 +19,7 @@ apply from: "${rootProject.projectDir}/gradle/helpProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 apply from: "${rootProject.projectDir}/gradle/hasProtobuf.gradle"
 apply from: "${rootProject.projectDir}/gradle/hasPythonPackage.gradle"
 
diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/debug/spi/tracermi/TraceRmiLaunchOpinion.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/debug/spi/tracermi/TraceRmiLaunchOpinion.java
index 6d9388d074b..cb9a308e5ee 100644
--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/debug/spi/tracermi/TraceRmiLaunchOpinion.java
+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/debug/spi/tracermi/TraceRmiLaunchOpinion.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,6 @@
 import ghidra.app.services.InternalTraceRmiService;
 import ghidra.debug.api.tracermi.TraceRmiLaunchOffer;
 import ghidra.framework.options.Options;
-import ghidra.framework.plugintool.PluginTool;
 import ghidra.program.model.listing.Program;
 import ghidra.util.classfinder.ExtensionPoint;
 
@@ -30,15 +29,14 @@
  * A factory of launch offers
  * 
  * <p>
- * Each factory is instantiated only once for the entire application, even when multiple tools are
- * open. Thus, {@link #init(PluginTool)} and {@link #dispose(PluginTool)} will be invoked for each
- * tool.
+ * Each opinion is instantiated only once for the entire application, even when multiple tools are
+ * open.
  */
 public interface TraceRmiLaunchOpinion extends ExtensionPoint {
 	/**
 	 * Register any options
 	 * 
-	 * @param tool the tool
+	 * @param options the tool options
 	 */
 	default void registerOptions(Options options) {
 	}
@@ -75,7 +73,7 @@ default boolean requiresRefresh(String optionName) {
 	 * @param plugin the Trace RMI launcher service plugin. <b>NOTE:</b> to get access to the Trace
 	 *            RMI (connection) service, use the {@link InternalTraceRmiService}, so that the
 	 *            offers can register the connection's resources. See
-	 *            {@link TraceRmiHandler#registerResources(Collection)}. Resource registration is
+	 *            {@link TraceRmiHandler#registerTerminals(Collection)}. Terminal registration is
 	 *            required for the Disconnect button to completely terminate the back end.
 	 * @param program the current program. While this is not <em>always</em> used by the launcher,
 	 *            it is implied that the user expects the debugger to do something with the current
diff --git a/Ghidra/Debug/Debugger/build.gradle b/Ghidra/Debug/Debugger/build.gradle
index 2cd52327a8e..0117ab919c0 100644
--- a/Ghidra/Debug/Debugger/build.gradle
+++ b/Ghidra/Debug/Debugger/build.gradle
@@ -18,6 +18,7 @@ apply from: "${rootProject.projectDir}/gradle/helpProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 
 apply plugin: 'eclipse'
 eclipse.project.name = 'Debug Debugger'
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/StackUnwinder.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/StackUnwinder.java
index 486359a7e82..fd8ffb8e33c 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/StackUnwinder.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/StackUnwinder.java
@@ -58,12 +58,12 @@
  * <p>
  * The usage pattern is typically:
  * 
- * <pre>
+ * <pre>{@code
  * StackUnwinder unwinder = new StackUnwinder(tool, coordinates.getPlatform());
  * for (AnalysisUnwoundFrame<WatchValue> frame : unwinder.frames(coordinates.frame(0), monitor)) {
  * 	// check and/or cache the frame
  * }
- * </pre>
+ * }</pre>
  * 
  * <p>
  * Typically, a frame is sought either by its level or by its function. Once found, several
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/SymPcodeExecutorState.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/SymPcodeExecutorState.java
index dc7297774ac..dc8e49edef6 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/SymPcodeExecutorState.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/SymPcodeExecutorState.java
@@ -214,8 +214,8 @@ public Long computeStackDepth() {
 	 * <p>
 	 * There are two cases:
 	 * <ul>
-	 * <li>PC:Register => location is PC.reg.address
-	 * <li>PC:Deref => location is [Stack]:PC.offset
+	 * <li>{@code PC:Register => location is PC.reg.address}</li>
+	 * <li>{@code PC:Deref => location is [Stack]:PC.offset}</li>
 	 * </ul>
 	 * 
 	 * @return the address (stack offset or register) of the return address
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwindAnalysis.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwindAnalysis.java
index 5c91d186e75..f23fd842427 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwindAnalysis.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwindAnalysis.java
@@ -419,16 +419,16 @@ public SymPcodeExecutorState executeFromPc(SymPcodeExecutorState state,
 		 * function return.</li>
 		 * <li>Examine the symbol in the program counter register. This gives the location (register
 		 * or stack offset) of the return address. This strategy should work whether or not a link
-		 * register is involved. See {@link SymPcodeExecutorState#computeAddressOfReturn()}.
+		 * register is involved. See {@link SymPcodeExecutorState#computeAddressOfReturn()}.</li>
 		 * <li>Examine the symbol in the stack pointer register, again. It should be a stack offset.
 		 * That offset is the "stack adjustment." See {@link UnwindInfo#adjust()},
 		 * {@link UnwindInfo#computeNextSp(Address)}, and
-		 * {@link SymPcodeExecutorState#computeStackDepth()}.
+		 * {@link SymPcodeExecutorState#computeStackDepth()}.</li>
 		 * <li>Search the registers for stack dereference symbols, creating an offset-register map.
 		 * This intersected with the same from entry to program counter is the saved registers map.
 		 * See {@link UnwindInfo#saved()},
 		 * {@link UnwindInfo#mapSavedRegisters(Address, SavedRegisterMap)}, and
-		 * {@link SymPcodeExecutorState#computeMapUsingRegisters()}.
+		 * {@link SymPcodeExecutorState#computeMapUsingRegisters()}.</li>
 		 * </ol>
 		 * 
 		 * <p>
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwoundFrame.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwoundFrame.java
index f638ca878ca..f8d265d6091 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwoundFrame.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/stack/UnwoundFrame.java
@@ -115,7 +115,7 @@ public interface UnwoundFrame<T> {
 	 * assuming the callee has not saved that register to the stack.</li>
 	 * <li>The return address cannot be recovered. This happens when the function appears to be non
 	 * returning, or the analysis otherwise fails to recover the return address. In this case, this
-	 * method will throw an exception.
+	 * method will throw an exception.</li>
 	 * </ol>
 	 * 
 	 * @return the return address
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/utils/MiscellaneousUtils.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/utils/MiscellaneousUtils.java
index f54933bee46..2638e7df3b4 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/utils/MiscellaneousUtils.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/utils/MiscellaneousUtils.java
@@ -93,7 +93,8 @@ public static String lengthToString(long length) {
 	}
 
 	/**
-	 * Parses a value from 1 to 1<<64. Any value outside the range is "clipped" into the range.
+	 * Parses a value from 1 to {@code 1<<64}. Any value outside the range is "clipped" into the
+	 * range.
 	 * 
 	 * <p>
 	 * Note that a returned value of 0 indicates 2 to the power 64, which is just 1 too high to fit
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/pcode/exec/DebuggerPcodeUtils.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/pcode/exec/DebuggerPcodeUtils.java
index 1fd25ce6a11..20992e9fc47 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/pcode/exec/DebuggerPcodeUtils.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/pcode/exec/DebuggerPcodeUtils.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -64,8 +64,7 @@ public enum DebuggerPcodeUtils {
 	 * A p-code parser that can resolve labels from a trace or its mapped programs.
 	 */
 	public static class LabelBoundPcodeParser extends ErrorCollectingPcodeParser {
-		record ProgSym(String sourceName, String nm, Address address) {
-		}
+		record ProgSym(String sourceName, String nm, Address address) {}
 
 		private final DebuggerStaticMappingService mappings;
 		private final DebuggerCoordinates coordinates;
@@ -447,8 +446,8 @@ public int length() {
 	 * A p-code arithmetic on watch values
 	 * 
 	 * <p>
-	 * This is just a composition of four arithmetics. Using Pair<A,Pair<B,Pair<C,D>> would be
-	 * unwieldy.
+	 * This is just a composition of four arithmetics. Using {@code Pair<A,Pair<B,Pair<C,D>>} would
+	 * be unwieldy.
 	 */
 	public enum WatchValuePcodeArithmetic implements PcodeArithmetic<WatchValue> {
 		BIG_ENDIAN(BytesPcodeArithmetic.BIG_ENDIAN, LocationPcodeArithmetic.BIG_ENDIAN),
diff --git a/Ghidra/Debug/Framework-TraceModeling/build.gradle b/Ghidra/Debug/Framework-TraceModeling/build.gradle
index 88ac65a4d6e..c96d296ec84 100644
--- a/Ghidra/Debug/Framework-TraceModeling/build.gradle
+++ b/Ghidra/Debug/Framework-TraceModeling/build.gradle
@@ -17,6 +17,7 @@ apply from: "${rootProject.projectDir}/gradle/javaProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 
 apply plugin: 'eclipse'
 eclipse.project.name = 'Debug Framework-TraceModeling'
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/AbstractCheckedTraceCachedWriteBytesPcodeExecutorStatePiece.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/AbstractCheckedTraceCachedWriteBytesPcodeExecutorStatePiece.java
index 37432fa3315..a71d8e8dfa4 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/AbstractCheckedTraceCachedWriteBytesPcodeExecutorStatePiece.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/AbstractCheckedTraceCachedWriteBytesPcodeExecutorStatePiece.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -111,7 +111,6 @@ protected AbstractSpaceMap<CachedSpace> newSpaceMap() {
 	 * @param size the size of the requested read
 	 * @param uninitialized the portion of the read that is uninitialized
 	 * @return the adjusted size of the read
-	 * @throws Exception to interrupt the emulator
 	 */
 	protected abstract int checkUninitialized(PcodeTraceDataAccess backing, Address start,
 			int size, AddressSet uninitialized);
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/data/PcodeTraceAccess.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/data/PcodeTraceAccess.java
index d0c59b5917b..db4b30a3311 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/data/PcodeTraceAccess.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/data/PcodeTraceAccess.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -54,23 +54,28 @@
  * 	new DefaultPcodeTraceAccess(trace.getPlatformManager().getHostPlatform(), 0, 0);
  * </pre>
  * 
+ * </li>
  * <li>Typically invoked by a factory method for an emulator's shared executor state
  * 
  * <pre>
  * PcodeTraceMemoryAccess sharedData = access.getDataForSharedState();
  * </pre>
  * 
+ * </li>
  * <li>Typically invoked by a factory method for an emulator thread's local executor state
  * 
  * <pre>
  * PcodeTraceRegisterAccess localData = access.getDataForLocalState(thread, 0);
  * </pre>
  * 
+ * </li>
  * <li>Typically invoked by an auxiliary emulator state piece
  * 
- * <pre>
+ * <pre>{@code
  * PcodeTracePropertyAccess<String> property = data.getPropertyAccess("MyProperty", String.class);
- * </pre>
+ * }</pre>
+ * 
+ * </li>
  * </ul>
  */
 public interface PcodeTraceAccess {
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceCodeUnitsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceCodeUnitsView.java
index 6aed1fcf75d..4cad7ec97c9 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceCodeUnitsView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceCodeUnitsView.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,6 @@
 import ghidra.program.model.address.*;
 import ghidra.trace.model.*;
 import ghidra.trace.model.listing.TraceBaseCodeUnitsView;
-import ghidra.trace.model.thread.TraceThread;
 
 /**
  * An abstract implementation of a {@link TraceBaseCodeUnitsView} for a specific address space
@@ -64,20 +63,6 @@ public Trace getTrace() {
 		return space.manager.getTrace();
 	}
 
-	/**
-	 * @see TraceBaseCodeUnitsView#getThread()
-	 */
-	public TraceThread getThread() {
-		return space.getThread();
-	}
-
-	/**
-	 * @see TraceBaseCodeUnitsView#getFrameLevel()
-	 */
-	public int getFrameLevel() {
-		return space.getFrameLevel();
-	}
-
 	/**
 	 * @see TraceBaseCodeUnitsView#size()
 	 */
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceCodeManager.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceCodeManager.java
index 263ddc9a3da..9b8ca949c28 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceCodeManager.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceCodeManager.java
@@ -115,30 +115,36 @@
  * Here is the type hierarchy presented with notes regarding structural interface implementations:
  * <ul>
  * <li>{@link AbstractBaseDBTraceCodeUnitsView} structurally implements
- * {@link TraceBaseCodeUnitsView}</li>
+ * {@link TraceBaseCodeUnitsView}
  * <ul>
- * <li>{@link AbstractComposedDBTraceCodeUnitsView}</li>
+ * <li>{@link AbstractComposedDBTraceCodeUnitsView}
  * <ul>
  * <li>{@link DBTraceCodeUnitsView} nominally implements {@link TraceCodeUnitsView}</li>
  * <li>{@link DBTraceDataView} nominally implements {@link TraceDataView}</li>
  * <li>{@link DBTraceDefinedUnitsView} nominally implements {@link TraceDefinedUnitsView}</li>
  * </ul>
- * <li>{@link AbstractSingleDBTraceCodeUnitsView}</li>
+ * </li>
+ * <li>{@link AbstractSingleDBTraceCodeUnitsView}
  * <ul>
  * <li>{@link AbstractBaseDBTraceDefinedUnitsView} structurally implements
- * {@link TraceBaseDefinedUnitsView}</li>
+ * {@link TraceBaseDefinedUnitsView}
  * <ul>
  * <li>{@link DBTraceDefinedDataView} nominally implements {@link TraceDefinedDataView}</li>
  * <li>{@link DBTraceInstructionsView} nominally implements {@link TraceInstructionsView}</li>
  * </ul>
+ * </li>
  * <li>{@link DBTraceUndefinedDataView} nominally implements {@link TraceUndefinedDataView}</li>
  * </ul>
+ * </li>
+ * </ul>
+ * </li>
  * </ul>
  * 
  * <p>
  * The view composition is not hierarchical, as each may represent a different combination, and one
  * type may appear in several compositions. The single-type views are named first, then the composed
  * views:
+ * 
  * <ul>
  * <li>Instructions - single-type view</li>
  * <li>Defined Data - single-type view</li>
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceData.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceData.java
index eca019236a9..8fbfc422427 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceData.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceData.java
@@ -119,7 +119,7 @@ protected DBTraceData getRecordValue() {
 	 * Set the fields of this record
 	 * 
 	 * @param platform the platform
-	 * @param dataType the data type
+	 * @param dataTypeID the data type id
 	 */
 	protected void set(InternalTracePlatform platform, long dataTypeID) {
 		this.platformKey = platform.getIntKey();
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataAdapter.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataAdapter.java
index c5bc5426f89..be761171ab5 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataAdapter.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataAdapter.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -240,7 +240,7 @@ default DBTraceDefinedDataAdapter doGetComponent(int[] componentPath, int level)
 	 * {@inheritDoc}
 	 * 
 	 * This implementation differs in that the path is relative to this unit, even if it is not the
-	 * root. In {@link DataDB}, it appears the behavior is undefined if you call this on a non-root
+	 * root. In {@code DataDB}, it appears the behavior is undefined if you call this on a non-root
 	 * component.
 	 */
 	@Override
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java
index ef6ce495f26..227f790e110 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java
@@ -149,8 +149,8 @@ protected Instruction doAdjustExisting(Address address, Instruction protoInstr)
 		 * Check the preceding unit and see if it can be extended to "create" the desired one
 		 * 
 		 * <p>
-		 * For overwrite, the caller should first use
-		 * {@link #doAdjustExisting(Address, InstructionPrototype, Instruction)}.
+		 * For overwrite, the caller should first use *
+		 * {@link #doAdjustExisting(Address, Instruction)}.
 		 * 
 		 * @param address the starting address of the instruction
 		 * @param protoInstr the prototype instruction
@@ -228,7 +228,7 @@ protected Instruction doCreateInstruction(Address address, Instruction protoInst
 		 * If it encounters a delay-slotted instruction, it will recurse on the group, iterating in
 		 * reverse order.
 		 * 
-		 * @param instructions the instructions to add
+		 * @param it the iterator of instructions to add
 		 * @param areDelaySlots true if the instructions are already reversed from being
 		 *            delay-slotted
 		 * @return the last instruction added
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/DefaultTraceSpan.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/DefaultTraceSpan.java
index 336eb86752e..f06148bbaf1 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/DefaultTraceSpan.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/DefaultTraceSpan.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,7 @@
 import java.util.Objects;
 
 /**
- * NOTE: This is used to mark <trace,snap>; regardless of whether that snapshot is actually in the
+ * NOTE: This is used to mark (trace,snap) regardless of whether that snapshot is actually in the
  * database.... Cannot just use TraceSnapshot here.
  */
 public class DefaultTraceSpan implements TraceSpan {
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/listing/TraceBaseCodeUnitsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/listing/TraceBaseCodeUnitsView.java
index 0dc8d0ebaf1..6982305d514 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/listing/TraceBaseCodeUnitsView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/listing/TraceBaseCodeUnitsView.java
@@ -239,8 +239,7 @@ public interface TraceBaseCodeUnitsView<T extends TraceCodeUnit> {
 	 * This checks if any (snap, address) point within the given box is contained within some code
 	 * unit in this view.
 	 * 
-	 * @param span the span of snaps
-	 * @param range the address range
+	 * @param range the address-snap range
 	 * @return true if intersecting, false otherwise
 	 */
 	boolean intersectsRange(TraceAddressSnapRange range);
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/symbol/TraceSymbolWithLocationView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/symbol/TraceSymbolWithLocationView.java
index 1311e114fd9..51e72f5bcf7 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/symbol/TraceSymbolWithLocationView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/symbol/TraceSymbolWithLocationView.java
@@ -216,7 +216,6 @@ default Collection<? extends T> getAt(long snap, TraceThread thread,
 	 * Check if this view contains any symbols at the given point.
 	 * 
 	 * @param snap the snapshot key
-	 * @param thread the thread, if in register space
 	 * @param address the address of the symbols
 	 * @param includeDynamicSymbols true to include dynamically-generated symbols
 	 * @return true if any symbols in this view satisfy the query
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/TraceObject.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/TraceObject.java
index 09004d56410..7e3ca4627fd 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/TraceObject.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/TraceObject.java
@@ -72,9 +72,9 @@
  * <ol>
  * <li><b>The object itself:</b> Test if the context target object supports the desired interface.
  * If it does, take it.</li>
- * <li><b>Aggregate objects:</b> If the object is marked with {@link TraceAggregate}, collect
- * all attributes supporting the desired interface. If there are any, take them. This step is
- * applied recursively if any child attribute is also marked with {@link TraceAggregate}.</li>
+ * <li><b>Aggregate objects:</b> If the object is marked with {@link TraceAggregate}, collect all
+ * attributes supporting the desired interface. If there are any, take them. This step is applied
+ * recursively if any child attribute is also marked with {@link TraceAggregate}.</li>
  * <li><b>Ancestry:</b> Apply these same steps to the object's (canonical) parent, recursively.</li>
  * </ol>
  * 
@@ -92,44 +92,52 @@
  * may be presented by a user-space debugger for a desktop operating system:
  * 
  * <ul>
- * <li>"Session" : {@link TraceObject}</li>
+ * <li>"Session" : {@link TraceObject}
  * <ul>
- * <li>"Process 789" : {@link TraceProcess}, {@link TraceAggregate}</li>
+ * <li>"Process 789" : {@link TraceProcess}, {@link TraceAggregate}
  * <ul>
- * <li>"Threads" : {@link TraceObject}</li>
+ * <li>"Threads" : {@link TraceObject}
  * <ul>
- * <li>"Thread 1" : {@link TraceThread}, {@link TraceExecutionStateful},
- * {@link TraceAggregate}</li>
+ * <li>"Thread 1" : {@link TraceThread}, {@link TraceExecutionStateful}, {@link TraceAggregate}
  * <ul>
- * <li>"Registers" : {@link TraceRegisterContainer}</li>
+ * <li>"Registers" : {@link TraceRegisterContainer}
  * <ul>
  * <li>"r1" : {@link TraceRegister}</li>
  * <li>...</li>
  * </ul>
+ * </li>
  * </ul>
+ * </li>
  * <li>...more threads</li>
  * </ul>
- * <li>"Memory" : {@link TraceMemory}</li>
+ * </li>
+ * <li>"Memory" : {@link TraceMemory}
  * <ul>
  * <li>"[0x00400000:0x00401234]" : {@link TraceMemoryRegion}</li>
  * <li>...more regions</li>
  * </ul>
- * <li>"Modules" : {@link TraceObject}</li>
+ * </li>
+ * <li>"Modules" : {@link TraceObject}
  * <ul>
- * <li>"/usr/bin/echo" : {@link TraceModule}</li>
+ * <li>"/usr/bin/echo" : {@link TraceModule}
  * <ul>
  * <li>".text" : {@link TraceSection}</li>
  * <li>...more sections</li>
  * </ul>
+ * </li>
  * <li>...more modules</li>
  * </ul>
+ * </li>
  * </ul>
- * <li>"Environment": {@link TraceEnvironment}</li>
+ * </li>
+ * <li>"Environment": {@link TraceEnvironment}
  * <ul>
  * <li>"Process 321" : {@link TraceObject}</li>
  * <li>...more processes</li>
  * </ul>
+ * </li>
  * </ul>
+ * </li>
  * </ul>
  * 
  * <p>
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/schema/TraceObjectSchema.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/schema/TraceObjectSchema.java
index 689fc389c89..6bbb9f4c7ce 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/schema/TraceObjectSchema.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/target/schema/TraceObjectSchema.java
@@ -390,13 +390,13 @@ default TraceObjectSchema getSuccessorSchema(KeyPath path) {
 	 * path. Thus, for a path of length n, the resulting list has n+1 entries. This is useful for
 	 * searches along the ancestry of a given path:
 	 * 
-	 * <pre>
+	 * <pre>{@code
 	 * List<TargetObjectSchema> schemas = getSuccessorSchemas(path);
 	 * for (; path != null; path = PathUtils.parent(path)) {
 	 * 	TargetObjectSchema schema = schemas.get(path.size());
 	 * 	// ...
 	 * }
-	 * </pre>
+	 * }</pre>
 	 * 
 	 * <p>
 	 * All entries are non-null, though they may be {@link PrimitiveTraceObjectSchema#VOID}.
@@ -1009,17 +1009,17 @@ default void validateRequiredAttributes(TraceObject object, boolean strict, long
 	 * 
 	 * <p>
 	 * This places some conventional restrictions / expectations on models where registers are given
-	 * on a frame-by-frame basis. The schema should present the {@link TraceRegisterContainer}
-	 * as the same object or a successor to {@link TraceStackFrame}, which must in turn be a
-	 * successor to {@link TraceStack}. The frame level (an index) must be in the path from stack to
-	 * frame. There can be no wildcards between the frame and the register container. For example,
-	 * the container for {@code Threads[1]} may be {@code Threads[1].Stack[n].Registers}, where
+	 * on a frame-by-frame basis. The schema should present the {@link TraceRegisterContainer} as
+	 * the same object or a successor to {@link TraceStackFrame}, which must in turn be a successor
+	 * to {@link TraceStack}. The frame level (an index) must be in the path from stack to frame.
+	 * There can be no wildcards between the frame and the register container. For example, the
+	 * container for {@code Threads[1]} may be {@code Threads[1].Stack[n].Registers}, where
 	 * {@code n} is the frame level. {@code Threads[1].Stack} would have the {@link TraceStack}
 	 * interface, {@code Threads[1].Stack[0]} would have the {@link TraceStackFrame} interface, and
 	 * {@code Threads[1].Stack[0].Registers} would have the {@link TraceRegisterContainer}
-	 * interface. Note it is not sufficient for {@link TraceRegisterContainer} to be a
-	 * successor of {@link TraceStack} with a single index between. There <em>must</em> be an
-	 * intervening {@link TraceStackFrame}, and the frame level (index) must precede it.
+	 * interface. Note it is not sufficient for {@link TraceRegisterContainer} to be a successor of
+	 * {@link TraceStack} with a single index between. There <em>must</em> be an intervening
+	 * {@link TraceStackFrame}, and the frame level (index) must precede it.
 	 * 
 	 * @param frameLevel the frame level. May be ignored if not applicable
 	 * @param path the path of the seed object relative to the root
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/listing/DBTraceCodeManagerTest.java b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/listing/DBTraceCodeManagerTest.java
index a3a9c1dd762..7d86bf4dbfa 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/listing/DBTraceCodeManagerTest.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/database/listing/DBTraceCodeManagerTest.java
@@ -1418,12 +1418,7 @@ public void testRegisterSpace() throws Exception {
 					.create(Lifespan.nowOn(0), b.language.getRegister("r4"), LongDataType.dataType);
 		}
 
-		assertEquals(thread, regCode.codeUnits().getThread());
-		assertEquals(thread, regCode.data().getThread());
-		assertEquals(thread, regCode.definedUnits().getThread());
-		assertEquals(thread, regCode.instructions().getThread());
-		assertEquals(thread, regCode.definedData().getThread());
-		assertEquals(thread, regCode.undefinedData().getThread());
+		assertEquals(thread, regCode.getThread());
 
 		assertEquals(List.of(dR4), list(regCode.definedUnits().get(0, true)));
 
@@ -1441,7 +1436,7 @@ public void testRegisterSpace() throws Exception {
 		}
 
 		assertEquals(1, frameCode.getFrameLevel());
-		assertEquals(thread, frameCode.codeUnits().getThread());
+		assertEquals(thread, frameCode.getThread());
 		assertEquals(List.of(dR5), list(frameCode.definedUnits().get(0, true)));
 	}
 
diff --git a/Ghidra/Debug/ProposedUtils/build.gradle b/Ghidra/Debug/ProposedUtils/build.gradle
index e63a0535f33..e0cf4cdfc85 100644
--- a/Ghidra/Debug/ProposedUtils/build.gradle
+++ b/Ghidra/Debug/ProposedUtils/build.gradle
@@ -17,6 +17,7 @@ apply from: "${rootProject.projectDir}/gradle/javaProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
 apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 
 apply plugin: 'eclipse'
 eclipse.project.name = 'Debug ProposedUtils'
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/graph/algo/TopologicalSorter.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/graph/algo/TopologicalSorter.java
index b708e5b633e..2b313ebbb47 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/graph/algo/TopologicalSorter.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/graph/algo/TopologicalSorter.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,10 @@
  * <p>
  * A-->B-->D, A-->C-->D yields either [A, B, C, D] or [A, C, B, D]
  * 
- * @see {@link https://en.wikipedia.org/wiki/Topological_sorting}
+ * @see <a href="https://en.wikipedia.org/wiki/Topological_sorting">Wikipedia: Topological
+ *      Sorting</a>
+ * @param <V> the type of vector
+ * @param <E> the type of edge
  */
 public class TopologicalSorter<V, E extends GEdge<V>> {
 	private final GDirectedGraph<V, E> graph;
@@ -53,8 +56,8 @@ public class TopologicalSorter<V, E extends GEdge<V>> {
 	 * 
 	 * @param graph the graph
 	 * @param requireTotal true to require a unique solution
-	 * @note if a unique solution is not requested, this algorithm will choose a solution
-	 *       arbitrarily. It does not yield all possible solutions.
+	 * @implNote if a unique solution is not requested, this algorithm will choose a solution
+	 *           arbitrarily. It does not yield all possible solutions.
 	 */
 	public TopologicalSorter(GDirectedGraph<V, E> graph, boolean requireTotal) {
 		this.graph = graph;
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/AbstractVarnodeEvaluator.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/AbstractVarnodeEvaluator.java
index 1202d8dbbf1..011b18a475b 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/AbstractVarnodeEvaluator.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/AbstractVarnodeEvaluator.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -271,7 +271,7 @@ protected T evaluateStack(long offset, int size) {
 	 * This is only invoked when trying to evaluate a leaf, which should never occur for a unique
 	 * variable. Thus, by default, this throws a {@link PcodeExecutionException}.
 	 * 
-	 * @param long the offset of the variable
+	 * @param offset the offset of the variable
 	 * @param size the size of the variable in bytes
 	 * @return the value
 	 */
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/VarnodeEvaluator.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/VarnodeEvaluator.java
index e752a7f32d9..64881c77a18 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/VarnodeEvaluator.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/eval/VarnodeEvaluator.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -46,7 +46,7 @@ public interface VarnodeEvaluator<T> {
 	 * Evaluate variable storage
 	 * 
 	 * <p>
-	 * Each varnode is evaluated as in {@link #evaluateStorage(VariableStorage)} and then
+	 * Each varnode is evaluated as in {@link #evaluateStorage(Program, VariableStorage)} and then
 	 * concatenated. The lower-indexed varnodes in storage are the more significant pieces, similar
 	 * to big endian.
 	 * 
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBAnnotatedObject.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBAnnotatedObject.java
index 6165804e617..9e6d629f879 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBAnnotatedObject.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBAnnotatedObject.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -34,12 +34,12 @@
  * fields from the record. These objects are managed using a {@link DBCachedObjectStore}. An example
  * object definition:
  * 
- * <pre>
+ * <pre>{@code
  * interface Person {
  * 	// ...
  * }
  * 
- * &#64;DBAnnotatedObjectInfo(version = 1)
+ * @DBAnnotatedObjectInfo(version = 1)
  * public class DBPerson extends DBAnnotatedObject implements Person {
  * 	public static final String TABLE_NAME = "Person"; // Conventionally defined here
  * 
@@ -48,15 +48,15 @@
  * 	static final String ADDRESS_COLUMN_NAME = "Address";
  * 
  * 	// Column handles
- * 	&#64;DBAnnotatedColumn(NAME_COLUMN_NAME)
+ * 	@DBAnnotatedColumn(NAME_COLUMN_NAME)
  * 	static DBObjectColumn NAME_COLUMN;
- * 	&#64;DBAnnotatedColumn(ADDRESS_COLUMN_NAME)
+ * 	@DBAnnotatedColumn(ADDRESS_COLUMN_NAME)
  * 	static DBObjectColumn ADDRESS_COLUMN;
  * 
  * 	// Column-backed fields
- * 	&#64;DBAnnotatedField(column = NAME_COLUMN_NAME, indexed = true)
+ * 	@DBAnnotatedField(column = NAME_COLUMN_NAME, indexed = true)
  * 	private String name;
- * 	&#64;DBAnnotatedField(column = ADDRESS_COLUMN_NAME)
+ * 	@DBAnnotatedField(column = ADDRESS_COLUMN_NAME)
  * 	private String address;
  * 
  * 	DBPerson(DBCachedObjectStore<DBPerson> store, DBRecord record) {
@@ -72,7 +72,7 @@
  * 
  * 	// ... other methods, getters, setters
  * }
- * </pre>
+ * }</pre>
  * 
  * <p>
  * See {@link DBCachedObjectStoreFactory} for example code that uses the example {@code DBPerson}
@@ -192,7 +192,7 @@ protected void update(DBObjectColumn col1, DBObjectColumn col2) {
 	}
 
 	/**
-	 * 2-arity version of {@link #update(DBObjectColumn...)}
+	 * 3-arity version of {@link #update(DBObjectColumn...)}
 	 * 
 	 * @param col1 a column
 	 * @param col2 another column
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedDomainObjectAdapter.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedDomainObjectAdapter.java
index dc2fb39581c..c547e0aca86 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedDomainObjectAdapter.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedDomainObjectAdapter.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -162,7 +162,7 @@ public Lock writeLock() {
 	protected ReadWriteLock rwLock;
 
 	/**
-	 * @see {@link DBDomainObjectSupport}
+	 * @see DBDomainObjectSupport
 	 */
 	protected DBCachedDomainObjectAdapter(DBHandle dbh, OpenMode openMode, TaskMonitor monitor,
 			String name, int timeInterval, int bufSize, Object consumer) {
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedObjectStoreFactory.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedObjectStoreFactory.java
index 6cfdf7a15f2..179ce06a4ec 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedObjectStoreFactory.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/DBCachedObjectStoreFactory.java
@@ -41,7 +41,7 @@
  * See {@link DBAnnotatedObject} for more documentation, including an example object definition. To
  * create a store, e.g., for {@code Person}:
  * 
- * <pre>
+ * <pre>{@code
  * interface MyDomainObject {
  * 	Person createPerson(String name, String address);
  * 
@@ -71,7 +71,7 @@
  * 		}
  * 	}
  * 
- * 	&#64;Override
+ * 	@Override
  * 	public Person createPerson(String name, String address) {
  * 		// Locking details elided
  * 		DBPerson person = people.create();
@@ -79,19 +79,19 @@
  * 		return person;
  * 	}
  * 
- * 	&#64;Override
+ * 	@Override
  * 	public Person getPerson(int id) {
  * 		// Locking details elided
  * 		return people.getAt(id);
  * 	}
  * 
- * 	&#64;Override
+ * 	@Override
  * 	public Collection<Person> getPeopleNamed(String name) {
  * 		// Locking details elided
  * 		return peopleByName.get(name);
  * 	}
  * }
- * </pre>
+ * }</pre>
  * 
  * <p>
  * The factory manages tables on behalf of the domain object, so it is typically the first thing
@@ -159,7 +159,7 @@ public AddressRange toRange(AddressFactory factory) {
 	 * {@link DBAnnotatedObject} is sufficient. If context is required, then additional interfaces
 	 * can be required via type intersection:
 	 * 
-	 * <pre>
+	 * <pre>{@code
 	 * public interface MyContext {
 	 * 	// ...
 	 * }
@@ -175,14 +175,14 @@ public AddressRange toRange(AddressFactory factory) {
 	 * 		super(MyType.class, objectType, BinaryField.class, field, column);
 	 * 	}
 	 * 
-	 * 	&#64;Override
+	 * 	@Override
 	 * 	protected void doStore(OT obj, DBRecord record) {
 	 * 		MyContext ctx = obj.getContext();
 	 * 		// ...
 	 * 	}
 	 * 	// ...
 	 * }
-	 * </pre>
+	 * }</pre>
 	 * 
 	 * <p>
 	 * Note that this implementation uses {@link AbstractDBFieldCodec}, which is highly recommended.
@@ -194,25 +194,25 @@ public AddressRange toRange(AddressFactory factory) {
 	 * {@link BinaryField}. See {@link ByteDBFieldCodec} for the simplest example with actual
 	 * encoding and decoding implementations. To use the example codec in an object:
 	 * 
-	 * <pre>
-	 * &#64;DBAnnotatedObjectInfo(version = 1)
+	 * <pre>{@code
+	 * @DBAnnotatedObjectInfo(version = 1)
 	 * public static class SomeObject extends DBAnnotatedObject implements ContextProvider {
 	 * 	static final String MY_COLUMN_NAME = "My";
 	 * 
-	 * 	&#64;DBAnnotatedColumn(MY_COLUMN_NAME)
+	 * 	@DBAnnotatedColumn(MY_COLUMN_NAME)
 	 * 	static DBObjectColumn MY_COLUMN;
 	 * 
-	 * 	&#64;DBAnnotatedField(column = MY_COLUMN_NAME, codec = MyDBFieldCodec.class)
+	 * 	@DBAnnotatedField(column = MY_COLUMN_NAME, codec = MyDBFieldCodec.class)
 	 * 	private MyType my;
 	 * 
 	 * 	// ...
 	 * 
-	 * 	&#64;Override
+	 * 	@Override
 	 * 	public MyContext getContext() {
 	 * 		// ...
 	 * 	}
 	 * }
-	 * </pre>
+	 * }</pre>
 	 * 
 	 * <p>
 	 * Notice that {@code SomeObject} must implement {@code ContextProvider}. This restriction is
@@ -406,7 +406,7 @@ protected abstract void doStore(OT obj, DBRecord record)
 				throws IllegalArgumentException, IllegalAccessException;
 
 		/**
-		 * Same as {@link #load(DBAnnotatedObject, DBRecord), but permits exceptions
+		 * Same as {@link #load(DBAnnotatedObject, DBRecord)}, but permits exceptions
 		 */
 		protected abstract void doLoad(OT obj, DBRecord record)
 				throws IllegalArgumentException, IllegalAccessException;
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/AbstractConstraintsTree.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/AbstractConstraintsTree.java
index c75715684d1..73c9d754b2b 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/AbstractConstraintsTree.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/AbstractConstraintsTree.java
@@ -119,7 +119,6 @@ protected Collection<NR> getNodeChildrenOf(NR parent) {
 	 * {@link Collection#size()}. Filtering is performed by {@link TreeRecordVisitor}.
 	 * 
 	 * @param parent the parent node
-	 * @param query a query to control the ordering of the children
 	 * @return a collection of the children
 	 */
 	protected Collection<DR> getDataChildrenOf(NR parent) {
@@ -137,7 +136,6 @@ protected Collection<DR> getDataChildrenOf(NR parent) {
 	 * {@link TreeRecordVisitor}.
 	 * 
 	 * @param parent the parent node
-	 * @param query a query to control the ordering of the children
 	 * @return a collection of the children
 	 */
 	protected Collection<? extends DBTreeRecord<?, ? extends NS>> getChildrenOf(NR parent) {
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/SpatialMap.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/SpatialMap.java
index c4236533d48..123f728479c 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/SpatialMap.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/database/spatial/SpatialMap.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -113,12 +113,13 @@ static <DS extends BoundedShape<?>, T, Q> SpatialMap<DS, T, Q> emptyMap() {
 	/**
 	 * Put an entry into the map
 	 * 
+	 * <p>
 	 * Note that the map may copy, and possibly modify, the given value. The value returned is the
 	 * value actually stored by the map. This may be useful when the map's values are identical to
 	 * its records. This allows the creation of a "blank" entry with a given shape. The entry is
 	 * then populated by the user.
 	 * 
-	 * <pre>
+	 * <pre>{@code
 	 * class MyDBDataRecord extends DBTreeDataRecord<MyShape, MyNodeShape, MyDBDataRecord> {
 	 * 	&#64;Override
 	 * 	protected void setValue(MyDBDataRecord value) {
@@ -129,18 +130,17 @@ static <DS extends BoundedShape<?>, T, Q> SpatialMap<DS, T, Q> emptyMap() {
 	 * 		return this; // The record is the value
 	 * 	}
 	 * }
-	 * </pre>
 	 * 
-	 * <pre>
 	 * MyDBDataRecord rec = map.put(MyShape.create(args), null);
 	 * rec.setSomething(6);
 	 * rec.setAnother("My user data");
-	 * </pre>
+	 * }</pre>
 	 * 
+	 * <p>
 	 * This practice is preferred when the values are not simple, and/or when the shape is a
 	 * property of the value. In other cases, e.g., when the value is an enum or a {@link Color},
-	 * then {@link DBTreeDataRecord#setValue(Object)} and {@link DBTreeDataRecord#getValue()} should
-	 * be implemented as field accessors.
+	 * then {@link DBTreeDataRecord#setRecordValue(Object)} and
+	 * {@link DBTreeDataRecord#getRecordValue()} should be implemented as field accessors.
 	 * 
 	 * @param shape the shape of the entry
 	 * @param value the value for the entry
@@ -151,6 +151,7 @@ static <DS extends BoundedShape<?>, T, Q> SpatialMap<DS, T, Q> emptyMap() {
 	/**
 	 * Remove an entry from the map
 	 * 
+	 * <p>
 	 * Removes a single matching entry, if found, from the map. If you have a reference to an entry
 	 * obtained from this map, use {@link #remove(Entry)} instead. Otherwise, this is the preferred
 	 * method.
@@ -164,6 +165,7 @@ static <DS extends BoundedShape<?>, T, Q> SpatialMap<DS, T, Q> emptyMap() {
 	/**
 	 * Remove an entry from the map
 	 * 
+	 * <p>
 	 * This method is preferred <em>only</em> when the given entry comes directly from this map.
 	 * This spares the implementation from having to search for a matching entry. If the entry does
 	 * not come from this map, it will behave like {@link #remove(BoundedShape, Object)}.
@@ -176,6 +178,7 @@ static <DS extends BoundedShape<?>, T, Q> SpatialMap<DS, T, Q> emptyMap() {
 	/**
 	 * Get or compute the size of this map
 	 * 
+	 * <p>
 	 * Note that this may not necessarily be a quick operation, esp., if this map is the result of
 	 * {@link #reduce(Object)}. In the worst case, all elements in the reduced map will be visited.
 	 * 
diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/utilities/util/SuppressableCallback.java b/Ghidra/Debug/ProposedUtils/src/main/java/utilities/util/SuppressableCallback.java
index c57d51a8f06..42d459d9578 100644
--- a/Ghidra/Debug/ProposedUtils/src/main/java/utilities/util/SuppressableCallback.java
+++ b/Ghidra/Debug/ProposedUtils/src/main/java/utilities/util/SuppressableCallback.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,7 +35,7 @@
  * A common use case is for a method to suppress any recursive calls, i.e., it is self suppressing,
  * e.g.:
  * 
- * <pre>
+ * <pre>{@code
  * private final SuppressableCallback<Void> cbDoSomething = new SuppressableCallback<>();
  * 
  * public boolean doSomething() {
@@ -51,7 +51,7 @@
  * 	// do the other thing
  * 	return doSomething();
  * }
- * </pre>
+ * }</pre>
  * 
  * <p>
  * This example is very trivial, but this sort of thing can easily happen in event driven
@@ -62,6 +62,8 @@
  * resulting in unending oscillation between the requested states. A more robust solution demands we
  * know the cause(s) of events. For now, the solution is to suppress event firing whenever a state
  * change is due to receiving an event.
+ * 
+ * @param <T> the type of return value, often {@link Void}
  */
 public class SuppressableCallback<T> {
 	/**
@@ -193,7 +195,7 @@ public <R> R invokeWithTop(Function<T, R> callback) {
 	 * The callback is always invoked, allowing it to decide what actions to take (or not take)
 	 * based on the values present in the stack.
 	 * 
-	 * @param callback
+	 * @param callback a method to receive the stack
 	 */
 	public void invokeWithStack(Consumer<List<T>> callback) {
 		callback.accept(stack.get().view);
diff --git a/Ghidra/Debug/TaintAnalysis/build.gradle b/Ghidra/Debug/TaintAnalysis/build.gradle
index 19bb73116f3..b9977c8815c 100644
--- a/Ghidra/Debug/TaintAnalysis/build.gradle
+++ b/Ghidra/Debug/TaintAnalysis/build.gradle
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-apply from: "$rootProject.projectDir/gradle/javaProject.gradle"
-apply from: "$rootProject.projectDir/gradle/jacocoProject.gradle"
-apply from: "$rootProject.projectDir/gradle/javaTestProject.gradle"
-apply from: "$rootProject.projectDir/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javaProject.gradle"
+apply from: "${rootProject.projectDir}/gradle/jacocoProject.gradle"
+apply from: "${rootProject.projectDir}/gradle/javaTestProject.gradle"
+apply from: "${rootProject.projectDir}/gradle/distributableGhidraModule.gradle"
+apply from: "${rootProject.projectDir}/gradle/javadoc.gradle"
 
 apply plugin: 'eclipse'
 eclipse.project.name = 'Debug TaintAnalysis'
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPartsFactory.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPartsFactory.java
index 09f9b56669a..52ff65142ac 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPartsFactory.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPartsFactory.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -51,12 +51,13 @@
  * <li>P-code Arithmetic: {@link TaintPcodeArithmetic}</li>
  * <li>Userop Library: {@link TaintPcodeUseropLibrary}</li>
  * <li>P-code Executor: {@link TaintPcodeThreadExecutor}</li>
- * <li>Machine State</li>
+ * <li>Machine State
  * <ul>
  * <li>Stand alone: {@link TaintPcodeExecutorState}</li>
  * <li>Trace integrated: {@link TaintTracePcodeExecutorState}</li>
  * <li>Debugger integrated: {@link TaintTracePcodeExecutorState} (same as Trace integrated)</li>
  * </ul>
+ * </li>
  * </ul>
  * 
  * <p>
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPcodeThreadExecutor.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPcodeThreadExecutor.java
index c3f9cc294cb..653460d61bb 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPcodeThreadExecutor.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/TaintPcodeThreadExecutor.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,8 +19,8 @@
 
 import ghidra.pcode.emu.DefaultPcodeThread;
 import ghidra.pcode.emu.DefaultPcodeThread.PcodeThreadExecutor;
-import ghidra.pcode.exec.PcodeExecutor;
-import ghidra.pcode.exec.PcodeFrame;
+import ghidra.pcode.exec.*;
+import ghidra.pcode.exec.PcodeArithmetic.Purpose;
 import ghidra.program.model.pcode.PcodeOp;
 import ghidra.taint.model.TaintVec;
 import ghidra.util.Msg;
@@ -52,9 +52,8 @@ public TaintPcodeThreadExecutor(DefaultPcodeThread<Pair<byte[], TaintVec>> threa
 	 * This is invoked on every {@link PcodeOp#CBRANCH}, allowing us a decent place to instrument
 	 * the emulator and add some diagnostics. Refer to
 	 * {@link PcodeExecutor#executeConditionalBranch(PcodeOp, PcodeFrame)} to see the operations
-	 * inputs. Alternatively, we could override
-	 * {@link TaintPcodeArithmetic#isTrue(TaintVec, Purpose)}; however, we'd have access to less
-	 * contextual information at that position.
+	 * inputs. Alternatively, we could override {@link PcodeArithmetic#isTrue(Object, Purpose)};
+	 * however, we'd have access to less contextual information at that position.
 	 */
 	@Override
 	public void executeConditionalBranch(PcodeOp op, PcodeFrame frame) {
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/full/TaintDebuggerPcodeEmulator.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/full/TaintDebuggerPcodeEmulator.java
index cabcae8999a..8ec3e02589d 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/full/TaintDebuggerPcodeEmulator.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/full/TaintDebuggerPcodeEmulator.java
@@ -42,8 +42,7 @@ public TaintDebuggerPcodeEmulator(PcodeDebuggerAccess data) {
 	 * Here, we just return the singleton parts factory. This appears simple because all the
 	 * complexity is encapsulated in the factory. See {@link TaintPartsFactory} to see everything
 	 * the implementation actually entails. Notice that this is the same parts factory used by
-	 * {@link TaintPcodeEmulator}. The {@link AuxDebugggerPcodeEmulator} knows to use the more
-	 * capable state parts.
+	 * {@link TaintPcodeEmulator}.
 	 */
 	@Override
 	protected AuxDebuggerEmulatorPartsFactory<TaintVec> getPartsFactory() {
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/plain/TaintPcodeExecutorStatePiece.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/plain/TaintPcodeExecutorStatePiece.java
index 89824771f09..228da37bba2 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/plain/TaintPcodeExecutorStatePiece.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/plain/TaintPcodeExecutorStatePiece.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -39,8 +39,8 @@
  * want to implement {@link TracePcodeExecutorState} directly, take the concrete piece provided, and
  * wrap it as you see fit. You may still benefit by referring to the implementation of
  * {@link PairedPcodeExecutorState}. When implementing your flavor of
- * {@link PairedPcodeExecutorState#getVar(AddressSpace, Pair, int, boolean)}, still consider that
- * you could benefit from the concrete element of the offset pair passed in.
+ * {@link PairedPcodeExecutorState#getVar(AddressSpace, Pair, int, boolean, Reason)}, still consider
+ * that you could benefit from the concrete element of the offset pair passed in.
  */
 public class TaintPcodeExecutorStatePiece extends AbstractTaintPcodeExecutorStatePiece<TaintSpace> {
 	/**
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeExecutorStatePiece.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeExecutorStatePiece.java
index 44c126d26af..8ac03935c93 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeExecutorStatePiece.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeExecutorStatePiece.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@
  * The trace-integrated state piece for holding taint marks
  *
  * <p>
- * See {@link AbstractTaintTracePcodeExecutorStatePiece} for framing. We'll store taint sets in the
+ * See {@link AbstractTaintPcodeExecutorStatePiece} for framing. We'll store taint sets in the
  * trace's address property map, which is the recommended scheme for auxiliary state.
  */
 public class TaintTracePcodeExecutorStatePiece
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTraceSpace.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTraceSpace.java
index 14ac6fea75a..3a87b2a8407 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTraceSpace.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/TaintTraceSpace.java
@@ -37,8 +37,7 @@ public class TaintTraceSpace extends TaintSpace {
 	 * Create the space
 	 * 
 	 * @param space the address space
-	 * @param backing if present, the backing object
-	 * @param snap the source snap
+	 * @param property the trace property backing this space
 	 */
 	public TaintTraceSpace(AddressSpace space, PcodeTracePropertyAccess<String> property) {
 		this.space = space;
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/package-info.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/package-info.java
index f588b3abcd7..990d0bc1a9b 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/package-info.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/pcode/emu/taint/trace/package-info.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,9 +17,9 @@
  * The trace-integrated Taint Emulator
  * 
  * <p>
- * This package builds on {@link ghidra.pcode.emu.plain} to construct a trace-integrated emulator.
- * See that package for remarks about this "working solution." Those state components were factored
- * to accommodate the state components introduced by this package.
+ * This package builds on the emulation framework to construct a trace-integrated emulator. The
+ * framework's state components were designed to accommodate the state components introduced by this
+ * package.
  * 
  * <p>
  * For this package, I recommend a bottom-up approach, since you should already be familiar with the
diff --git a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/taint/model/package-info.java b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/taint/model/package-info.java
index c64313fdff3..b6222810544 100644
--- a/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/taint/model/package-info.java
+++ b/Ghidra/Debug/TaintAnalysis/src/main/java/ghidra/taint/model/package-info.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,12 +17,13 @@
  * The Taint domain package
  * 
  * <p>
- * This package implements the domain of taint analysis. {@link TaintVec} models an array of bytes,
- * each having a {@link TaintSet}. A {@link TaintSet} is in turn made of several {@link TaintMarks}.
- * Each mark is a symbol with optional tags. We use the tags as a means of handling indirection, so
- * that we don't have to decide up front whether tainted offsets taint the values read and written
- * from memory. We allow them to be tainted, but add a tag to the mark, so they can be examined
- * and/or filtered by the user.
+ * This package implements the domain of taint analysis. {@link ghidra.taint.model.TaintVec} models
+ * an array of bytes, each having a {@link ghidra.taint.model.TaintSet}. A
+ * {@link ghidra.taint.model.TaintSet} is in turn made of several
+ * {@link ghidra.taint.model.TaintMark}s. Each mark is a symbol with optional tags. We use the tags
+ * as a means of handling indirection, so that we don't have to decide up front whether tainted
+ * offsets taint the values read and written from memory. We allow them to be tainted, but add a tag
+ * to the mark, so they can be examined and/or filtered by the user.
  * 
  * <p>
  * To facilitate storage and presentation of taint, we will need to implement some
@@ -30,7 +31,8 @@
  * parse method for sets and marks.
  * 
  * <p>
- * We recommend you read the documentation and source from the bottom up: {@link TaintMark},
- * {@link TaintSet}, {@link TaintVec}.
+ * We recommend you read the documentation and source from the bottom up:
+ * {@link ghidra.taint.model.TaintMark}, {@link ghidra.taint.model.TaintSet},
+ * {@link ghidra.taint.model.TaintVec}.
  */
 package ghidra.taint.model;
```
-----------------------------------
