# Commit: f391ddb87c88e553b84cc34a696509a01b08e7f5
## Message: GP-5945 Fixed PowerPC e500 instruction extension issues and added function start pattern variants.
## Diff:
```
diff --git a/Ghidra/Processors/PowerPC/data/languages/SPE_APU.sinc b/Ghidra/Processors/PowerPC/data/languages/SPE_APU.sinc
index cc07249e2ae..9a3c36864bb 100644
--- a/Ghidra/Processors/PowerPC/data/languages/SPE_APU.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/SPE_APU.sinc
@@ -593,45 +593,27 @@ define pcodeop VectorDivideWordUnsigned2;
 # evldd RT,D(RA)
 # ISA-cmt: Vector Load Double Word into Double Word
 # evldd rD,d(rA)
-define pcodeop VectorLoadDoubleWordIntoDoubleWord;
-# TODO: defined in evx.sinc
-# if (RA == 0) {
-#    b = 0;
-# } else {
-#    b = RA;
-# }
-# EA    = b + EXTZ(UI*8);
-# RT    = MEM(EA,8);
-
-#:evldd D,A is OP=4 & D & A & XOP_0_10=769 & BITS_11_15=0 { 
-    # TODO: defined in evx.sinc
-#    VectorLoadDoubleWordIntoDoubleWord(D,A); 
-#}
+:evldd RT,dUI16PlusRAOrZeroAddress is OP=4 & RT & dUI16PlusRAOrZeroAddress & XOP_0_10=769
+{
+   ea:$(REGISTER_SIZE) = dUI16PlusRAOrZeroAddress;
+   RT = *:8 ($(EATRUNC));
+}
 
 # evlddx RT,RA,RB
 # ISA-cmt: Vector Load Double Word into Double Word Indexed
 # evlddx
-# define pcodeop vectorLoadDoubleWordIntoDoubleWordIndexed1;
-# TODO: defined in evx.sinc
-# if (RA == 0) {
-#     b = 0;
-# } else {
-#     b = RA;
-# }
-# EA    = b + RB;
-# RT    = MEM(EA, 8);
-
-# :evlddx S,A,B is OP=4 & S & A & B & XOP_0_10=768 { 
-#    TODO: defined in evx.sinc
-#    vectorLoadDoubleWordIntoDoubleWordIndexed1(S,A,B); 
-#}
+:evlddx RT,RA_OR_ZERO,RB is OP=4 & RT & RA_OR_ZERO & RB & XOP_0_10=768
+{
+    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
+    RT = *:8 ($(EATRUNC));
+}
 
 # evldh RT,D(RA)
 # ISA-cmt: Vector Load Double into Four Halfwords
 # evldh rD,rA 011 0000 0101
 
 
-:evldh RT,EVUIMM_8_RAt is OP=4 & A & D & RT & EVUIMM_8 & EVUIMM_8_RAt & XOP_0_10=0x305 { 
+:evldh RT,EVUIMM_8_RAt is OP=4 & RT & EVUIMM_8_RAt & XOP_0_10=0x305 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -643,7 +625,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.S2     = MEM(EA+4, 2);
 # RT.S3     = MEM(EA+6, 2);
 
-    EA:8    = A + zext(EVUIMM_8_RAt);
+    EA:8    = EVUIMM_8_RAt;
     *:2 (RT) = *:2 ((EA) & $(MEMMASK));
     *:2 (RT+2) = *:2 ((EA+2) & $(MEMMASK));
     *:2 (RT+4) = *:2 ((EA+4) & $(MEMMASK));
@@ -676,7 +658,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evldw RT,D(RA)
 # ISA-cmt: Vector Load Double into Two Words
 # evldw rD,rA 011 0000 0011
-:evldw RT,EVUIMM_8_RAt is OP=4 & A & D & RT & EVUIMM_8 & EVUIMM_8_RAt & XOP_0_10=0x303 { 
+:evldw RT,EVUIMM_8_RAt is OP=4 & RT & EVUIMM_8_RAt & XOP_0_10=0x303 { 
 # if (RA == 0) {
 #    b    = 0;
 # } else {
@@ -686,7 +668,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.l      = MEM(EA, 4);
 # RT.h      = MEM(EA+4, 4);
 
-    EA:$(REGISTER_SIZE)   = A + zext(EVUIMM_8_RAt);
+    EA:$(REGISTER_SIZE)   = EVUIMM_8_RAt;
     *:4 (RT) = *:4 ((EA) & $(MEMMASK));
     *:4 (RT+4) = *:4 ((EA+4) & $(MEMMASK));
 }
@@ -712,7 +694,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlhhesplat RT,D(RA)
 # ISA-cmt: Vector Load Halfword into Halfwords Even and Splat
 # evlhhesplat rD,rA 011 0000 1001
-:evlhhesplat RT,EVUIMM_2_RAt is OP=4 & A & RT & EVUIMM_2_RAt & D & XOP_0_10=0x309 { 
+:evlhhesplat RT,EVUIMM_2_RAt is OP=4 & RT & EVUIMM_2_RAt & XOP_0_10=0x309 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -724,7 +706,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.S2    = MEM(EA,2);
 # RT.S3    = 0x0000;
 
-     EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_2_RAt);
+     EA:$(REGISTER_SIZE)  = EVUIMM_2_RAt;
      *:2 (RT) = *:2 ((EA) & $(MEMMASK));
      *:2 (RT+2) = 0x0000;
      *:2 (RT+4) = *:2 ((EA) & $(MEMMASK));
@@ -756,7 +738,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlhhossplat RT,D(RA)
 # ISA-cmt: Vector Load Halfword into Halfword Odd Signed and Splat
 # evlhhossplat rD,rA 011 0000 1111
-:evlhhossplat RT,EVUIMM_2_RAt is OP=4 & A & RT & EVUIMM_2_RAt & D & XOP_0_10=0x30F { 
+:evlhhossplat RT,EVUIMM_2_RAt is OP=4 & RT & EVUIMM_2_RAt & XOP_0_10=0x30F { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -766,7 +748,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.l  = EXTS(MEM(EA, 2));
 # RT.h  = EXTS(MEM(EA, 2));
 
-    EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_2_RAt);
+    EA:$(REGISTER_SIZE)  = EVUIMM_2_RAt;
     *:4 (RT) = sext( *:2 (((EA) & $(MEMMASK))));
     *:4 (RT+4) = sext( *:2 (((EA) & $(MEMMASK))));
 }
@@ -792,7 +774,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlhhousplat RT,D(RA)
 # ISA-cmt: Vector Load Halfword into Halfword Odd Unsigned and Splat
 # evlhhousplat rD,rA 011 0000 1101
-:evlhhousplat RT,EVUIMM_2_RAt  is OP=4 & A & RT & EVUIMM_2_RAt & D & XOP_0_10=0x30D { 
+:evlhhousplat RT,EVUIMM_2_RAt  is OP=4 & RT & EVUIMM_2_RAt & XOP_0_10=0x30D { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -802,7 +784,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.l   = EXTZ(MEM(EA, 2));
 # RT.h   = EXTZ(MEM(EA, 2));
 
-    EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_2_RAt);
+    EA:$(REGISTER_SIZE)  = EVUIMM_2_RAt;
     *:4 (RT) = zext( *:2 (((EA) & $(MEMMASK))));
     *:4 (RT+4) = zext( *:2 (((EA) & $(MEMMASK))));
 }
@@ -871,7 +853,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlwhos RT,D(RA)
 # ISA-cmt: Vector Load Word into Two Halfwords Odd Signed (with sign extension)
 # evlwhos rD,rA 011 0001 0111
-:evlwhos RT,EVUIMM_4_RAt is OP=4 & A & EVUIMM_4_RAt & RT & D & XOP_0_10=0x317 { 
+:evlwhos RT,EVUIMM_4_RAt is OP=4 & EVUIMM_4_RAt & RT & XOP_0_10=0x317 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -881,7 +863,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.l  = EXTS(MEM(EA, 2));
 # RT.h  = EXTS(MEM(EA+2, 2));
 
-    EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)  = EVUIMM_4_RAt;
     *:4 (RT) = sext( *:2 (((EA) & $(MEMMASK))));
     *:4 (RT+4) = sext( *:2 (((EA+2) & $(MEMMASK))));
 }
@@ -907,7 +889,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlwhou RT,D(RA)
 # ISA-cmt: Vector Load Word into Two Halfwords Odd Unsigned (zero-extended)
 # evlwhou rD,rA 011 0001 0101
-:evlwhou RT,EVUIMM_4_RAt is OP=4 & A & EVUIMM_4_RAt & RT & D & XOP_0_10=0x315 { 
+:evlwhou RT,EVUIMM_4_RAt is OP=4 & EVUIMM_4_RAt & RT & XOP_0_10=0x315 { 
 # if (RA == 0) { 
 #     b    = 0;
 # } else {
@@ -917,7 +899,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.l  = EXTZ(MEM(EA, 2));
 # RT.h  = EXTZ(MEM(EA+2, 2));
 
-    EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)  = EVUIMM_4_RAt;
     *:4 (RT) = zext( *:2 (((EA) & $(MEMMASK))));
     *:4 (RT+4) = zext( *:2 (((EA+2) & $(MEMMASK))));
 }
@@ -943,7 +925,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evlwhsplat RT,D(RA)
 # ISA-cmt: Vector Load Word into Two Halfwords and Splat
 # evlwhsplat rD,rA 011 0001 1101
-:evlwhsplat RS,EVUIMM_4_RAt is OP=4 & A & B & D & XOP_0_10=0x31D & EVUIMM_4_RAt & RS { 
+:evlwhsplat RS,EVUIMM_4_RAt is OP=4 & XOP_0_10=0x31D & EVUIMM_4_RAt & RS { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -955,7 +937,7 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # RT.S2  = MEM(EA+2,2);
 # RT.S3  = MEM(EA+2,2);
 
-    EA:$(REGISTER_SIZE)   = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)   = EVUIMM_4_RAt;
     *:2 (RS) = *:2 ((EA) & $(MEMMASK));
     *:2 (RS+2) = *:2 ((EA) & $(MEMMASK));
     *:2 (RS+4) = *:2 ((EA+2) & $(MEMMASK));
@@ -1023,64 +1005,38 @@ define pcodeop VectorLoadDoubleWordIntoDoubleWord;
 # evmergehi RT,RA,RB
 # ISA-cmt: Vector Merge High
 # evmergehi rD,rA,rB 010 0010 1100
-# defined evx.sinc XXX
-# define pcodeop VectorMergeHigh;
-# :evmergehi D,A,B is OP=4 & A & B & D & XOP_0_10=0x22C { 
-# RT.l    = RA.l;
-# RT.h    = RB.h;
-
-# VectorMergeHigh(D,A,B); 
-# }
+@if REGISTER_SIZE=="8"
+:evmergehi S,A,B        is OP=4 & S & A & B & XOP_0_10=556
+{
+	S[32,32] = A[32,32];
+	S[ 0,32] = B[32,32];
+}
 
 # evmergehilo RT,RA,RB
 # ISA-cmt: Vector Merge High/Low
 # evmergehilo rD,rA,rB 010 0010 1110
-#define pcodeop VectorMergeHighLow;
-#:evmergehilo D,A,B is OP=4 & A & B & D & XOP_0_10=0x22E {
-# RT.l    = RA.l;
-# RT.h    = RA.h;
-
-# lo = (A & 0x00000000FFFFFFFF);
-# hi = ((A & 0xFFFFFFFF00000000) >> 32);
-# b_lo = (B & 0x00000000FFFFFFFF);
-# b_hi = ((B & 0xFFFFFFFF00000000) >> 32);
-#
-# lo = lo;
-# hi = b_hi;
-#
-# D = ((hi << 32) | lo);
-#}
+:evmergehilo S,A,B is OP=4 & S & A & B & XOP_0_10=558 {
+	S[32,32] = A[32,32];
+	S[ 0,32] = B[ 0,32];
+}
 
 # evmergelo RT,RA,RB
 # ISA-cmt: Vector Merge Low
 # evmergelo rD,rA,rB 010 0010 1101
-# defined evx.sinc XXX
-# define pcodeop VectorMergeLow;
-# :evmergelo D,A,B is OP=4 & A & B & D & XOP_0_10=0x22D { 
-# RT.l    = RA.h;
-# RT.h    = RA.l;
-
-# VectorMergeLow(D,A,B); 
-# }
+:evmergelo S,A,B        is OP=4 & S & A & B & XOP_0_10=557
+{
+	S[32,32] = A[0,32];
+	S[ 0,32] = B[0,32];
+}
 
 # evmergelohi RT,RA,RB
 # ISA-cmt: Vector Merge Low/High
 # evmergelohi rD,rA,rB 010 0010 1111
-#:evmergelohi D,A,B is OP=4 & D & A & B & XOP_0_10=0x22F {
-# RT.l    = RA.h;
-# RT.h    = RA.l;
-
-# lo = (A & 0x00000000FFFFFFFF);
-# hi = ((A & 0xFFFFFFFF00000000) >> 32);
-# b_lo = (B & 0x00000000FFFFFFFF);
-# b_hi = ((B & 0xFFFFFFFF00000000) >> 32);
-#
-# lo = lo;
-# hi = b_lo;
-#
-# D = ((hi << 32) | lo);
-#}
-
+:evmergelohi S,A,B is OP=4 & S & A & B & XOP_0_10=559 {
+ 	S[32,32] = A[ 0,32];
+	S[ 0,32] = B[32,32];
+}
+@endif
 
 # evmhegsmfaa RT,RA,RB
 # ISA-cmt: Vector Multiply Halfwords, Even, Guarded, Signed, Modulo, Fractional and Accumulate
@@ -1962,17 +1918,11 @@ define pcodeop VectorMultiplyHalfWordsOddUnsignedSaturateIntegerAndAccumulateNeg
 # evmra RT,RA
 # ISA-cmt: Initialize Accumulator
 # evmra rD,rA 100 1100 0100
-# defined evx.sinc
-# define pcodeop InitializeAccumulator;
-# :evmra D,A is OP=4 & A & D & XOP_0_10=0x4C4 { 
-# ACC       = RA;
-# RT        = RA;
-
-#    ACC      = A;
-#    D        = A;
-
-#    InitializeAccumulator(D,A); 
-# }
+:evmra RT,RA        is OP=4 & RT & RA & BITS_11_15=0 & XOP_0_10=1220
+{
+	ACC = zext(RA);
+	RT = RA;
+}
 
 # evmwhsmf RT,RA,RB
 # ISA-cmt: Vector Multiply Word High Signed, Modulo, Fractional
@@ -2452,53 +2402,6 @@ define pcodeop VectorMultiplyWordSignedSaturateFractionalAndAccumulateNegative2;
     spr200 = spr200 | (flags & (0x1000000000000));
 }
 
-# evmwumi RT,RA,RB
-# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer
-# evmwumi rD,rA,rB 100 01A1 1000 A=0
-# evmwumi confict with machhwo
-# define pcodeop VectorMultiplyWordUnsignedModuloInteger;
-# :evmwumi D,A,B is OP=4 & A & B & D & XOP_0_10=0x458 { 
-# RT        = RA.h *ui RB.h;
-#    VectorMultiplyWordUnsignedModuloInteger(D,A,B,ACC); 
-# }
-
-# evmwumia RT,RA,RB
-# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer to Accumulator
-# evmwumia rD,rA,rB 100 01A1 1000 A=1
-:evmwumia D,A,B is OP=4 & A & B & D & XOP_0_10=0x478 {
-# RT        = RA.h *ui RB.h;
-# ACC        = RT;
-
-    D   = (( A & (0xFFFFFFFF00000000) ) >> 32) * (( B & (0xFFFFFFFF00000000) ) >> 32);
-    ACC = D;
-}
-
-# evmwumiaa RT,RA,RB
-# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer and Accumulate
-# evmwumiaa rD,rA,rB 101 0101 1000
-# evmwumiaa confict with macchwo
-# :evmwumiaa D,A,B is OP=4 & A & B & D & XOP_0_10=0x558 { 
-# u64 temp;
-# temp    = RA.h *ui RB.h;
-# RT      = ACC + temp;
-# ACC     = RT;
-
-#    VectorMultiplyWordUnsignedModuloIntegerAndAccumulate2(D,A,B,ACC); 
-# }
-
-# evmwumian RT,RA,RB
-# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer and Accumulate Negative
-# evmwumian rD,rA,rB 101 1101 1000
-# evmwumian confict with macchwso
-# :evmwumian D,A,B is OP=4 & A & B & D & XOP_0_10=0x5D8 { 
-# u64 temp;
-# temp  = RA.h *ui RB.h;
-# RT    = ACC - temp;
-# ACC   = RT;
-
-#    VectorMultiplyWordUnsignedModuloIntegerAndAccumulateNegative(D,A,B,ACC); 
-# }
-
 # =================================================================
 # Page D-15
 
@@ -2712,85 +2615,52 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
     D    = VectorShiftRightWordImmediateUnsigned(A); 
 }
 
-# evsrws RT,RA,RB
-# ISA-cmt: Vector Shift Right Word Signed
-# evsrws rD,rA,rB 010 0010 0001
-:evsrws D,A,B is OP=4 & A & B & D & XOP_0_10=0x221 { 
-# nh    = RB.bsub(26:31);
-# hl    = RB.bsub(58:63);
-# RT.l  = EXTS(RA.bsub(0:32-nh));
-# RT.h  = EXTS(RA.bsub(32:63-nl));
-
-    nh:$(REGISTER_SIZE)   = 32-((B & 0x00000000fc000000) >> 26);
-    nl:$(REGISTER_SIZE)   = 63-((B & 0xfc00000000000000) >> 58);
-    tmp:$(REGISTER_SIZE)  = (A & ((0xFFFFFFFFFFFFFFFF >> (64 - ((nh) - (0) + 1))) << (0)) >> 0);
-    lo:8 = sext(tmp:4);
-    tmp  = (A & ((0xFFFFFFFFFFFFFFFF >> (64 - ((nl) - (32) + 1))) << (32)) >> 32);
-    hi:8 = sext(tmp:4);
-    D    = (( zext(hi) << 32) | zext(lo)  );
+@if REGISTER_SIZE=="8"
+:evsrws S,A,B        is OP=4 & S & A & B & XOP_0_10=545
+{
+	local low:4 = A[0,32];
+	local high:4 = A[32,32];
+	local low_shift:1 = B[0,5];
+	local high_shift:1 = B[32,5];
+	S[0,32] = low s>> zext(low_shift);
+	S[32,32] = high s>> zext(high_shift);
 }
 
-# evsrwu RT,RA,RB
-# ISA-cmt: Vector Shift Right Word Unsigned
-# evsrwu rD,rA,rB 010 0010 0000
-:evsrwu D,A,B is OP=4 & A & B & D & XOP_0_10=0x220 { 
-# nh    = RB.bsub(26:31);
-# nl    = RB.bsub(58:63);
-# RT.l  = EXTZ(RA.bsub(0:32-nh));
-# RT.h  = EXTZ(RA.bsub(32:63-nl));
-
-    nh:$(REGISTER_SIZE)   = 32-((B & 0x00000000fc000000) >> 26);
-    nl:$(REGISTER_SIZE)   = 63-((B & 0xfc00000000000000) >> 58);
-    tmp:$(REGISTER_SIZE)  = (A & ((0xFFFFFFFFFFFFFFFF >> (64 - ((nh) - (0) + 1))) << (0)) >> 0);
-    lo:8 = zext(tmp:4);
-    tmp  = (A & ((0xFFFFFFFFFFFFFFFF >> (64 - ((nl) - (32) + 1))) << (32)) >> 32);
-    hi:8 = zext(tmp:4);
-    D    = (( zext(hi) << 32) | zext(lo)  );
+:evsrwu S,A,B        is OP=4 & S & A & B & XOP_0_10=544
+{
+	local low:4 = A[0,32];
+	local high:4 = A[32,32];
+	local low_shift:1 = B[0,5];
+	local high_shift:1 = B[32,5];
+	S[0,32] = low >> zext(low_shift);
+	S[32,32] = high >> zext(high_shift);
 }
+@endif
+
 
 # evstdd RS,D(RA)
 # ISA-cmt: Vector Store Double of Double
 # evstdd rD,rA,EVUIMM_8 011 0010 0001
-# defined evx.sinc EJ XXX
-#define pcodeop VectorStoreDoubleOfDouble;
-#:evstdd D,A,EVUIMM_8 is OP=4 & A & D & EVUIMM_8 & XOP_0_10=0x321 { 
-# if (RA == 0) {
-#     b     = 0;
-# } else {
-#     b    = RA;
-# }
-# EA            = b + EXTZ(UI*8);
-# MEM(EA,8)    = RS;
-
-#     VectorStoreDoubleOfDouble(D,A); 
-# }
+:evstdd RS,dUI16PlusRAOrZeroAddress is OP=4 & RS & dUI16PlusRAOrZeroAddress & XOP_0_10=801 
+{
+   ea:$(REGISTER_SIZE) = dUI16PlusRAOrZeroAddress;
+   *:8 ($(EATRUNC)) = RS;
+}
 
 # evstddx RS,RA,RB
 # ISA-cmt: Vector Store Double of Double Indexed
 # evstddx rS,rA,rB 011 0010 0000
-# defined evx.sinc EJ XXX
-# define pcodeop VectorStoreDoubleOfDoubleIndexed;
-# :evstddx S,A,B is OP=4 & A & S & B & XOP_0_10=0x320 { 
-# if (RA == 0) {
-#     b    = 0;
-# } else {
-#     b    = RA;
-# }
-# EA            = b + RB;
-# MEM(EA,8)     = RS;
+:evstddx RS,RA_OR_ZERO,RB        is OP=4 & RS & RA_OR_ZERO & RB & XOP_0_10=800
+{
+    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
+    *:8 ($(EATRUNC)) = RS;
+}
 
-#     VectorStoreDoubleOfDoubleIndexed(S,A,B); 
-# }
-# :evstddx RS,RA_OR_ZERO,RB        is OP=4 & RS & RA_OR_ZERO & RB & XOP_0_10=800
-# {
-#     ea = RA_OR_ZERO + RB;
-#     *:8 ($(EATRUNC)) = RS;
-# }
 
 # evstdh RS,D(RA)
 # ISA-cmt: Vector Store Double of Four Halfwords
 # evstdh rS,rA,EVUIMM_8 011 0010 0101
-:evstdh S,EVUIMM_8_RAt is OP=4 & A & S & EVUIMM_8 & EVUIMM_8_RAt & XOP_0_10=0x325 { 
+:evstdh S,EVUIMM_8_RAt is OP=4 & S & EVUIMM_8_RAt & XOP_0_10=0x325 { 
 # if (RA == 0) {
 #     b     = 0;
 # } else {
@@ -2802,7 +2672,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # MEM(EA+4,2)   = RS.S2;
 # MEM(EA+6,2)   = RS.S3;
 
-    EA:$(REGISTER_SIZE)  = A + zext(EVUIMM_8_RAt);
+    EA:$(REGISTER_SIZE)  = EVUIMM_8_RAt;
     *:2 (EA) = *:2 ((S) & $(MEMMASK));
     *:2 (EA+2) = *:2 ((S+2) & $(MEMMASK));
     *:2 (EA+4) = *:2 ((S+4) & $(MEMMASK));
@@ -2834,7 +2704,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # evstdw RS,D(RA)
 # ISA-cmt: Vector Store Double of Two Words
 # evstdw rS,rA,EVUIMM_8 011 0010 0011
-:evstdw S,EVUIMM_8_RAt is OP=4 & A & S & EVUIMM_8 & EVUIMM_8_RAt & XOP_0_10=0x323 { 
+:evstdw S,EVUIMM_8_RAt is OP=4 & S & EVUIMM_8_RAt & XOP_0_10=0x323 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -2844,7 +2714,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # MEM(EA,4)     = RS.l;
 # MEM(EA+4,4)   = RS.h;
 
-    EA:$(REGISTER_SIZE)   = A + zext(EVUIMM_8_RAt);
+    EA:$(REGISTER_SIZE)   = EVUIMM_8_RAt;
     *:4 (EA) = *:4 ((S) & $(MEMMASK));
     *:4 (EA+4) = *:4 ((S+4) & $(MEMMASK));
 }
@@ -2870,7 +2740,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # evstwhe RS,D(RA)
 # ISA-cmt: Vector Store Word of Two Halfwords from Even
 # evstwhe rS,rA,EVUIMM_4 011 0011 0001
-:evstwhe S,EVUIMM_4_RAt is OP=4 & A & S & EVUIMM_4_RAt & XOP_0_10=0x331 { 
+:evstwhe S,EVUIMM_4_RAt is OP=4 & S & EVUIMM_4_RAt & XOP_0_10=0x331 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -2880,7 +2750,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # MEM(EA,2)     = RS.S0;
 # MEM(EA+2,2)   = RS.S2;
 
-    EA:$(REGISTER_SIZE)   = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)   = EVUIMM_4_RAt;
     *:2 (EA) = *:2 ((S) & $(MEMMASK));
     *:2 (EA+2) = *:2 ((S+2) & $(MEMMASK));
 }
@@ -2906,7 +2776,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # evstwho RS,D(RA)
 # ISA-cmt: Vector Store Word of Two Halfwords from Odd
 # evstwho rS,rA,EVUIMM_4 011 0011 0101
-:evstwho S,EVUIMM_4_RAt is OP=4 & A & S & EVUIMM_4_RAt & XOP_0_10=0x335 { 
+:evstwho S,EVUIMM_4_RAt is OP=4 & S & EVUIMM_4_RAt & XOP_0_10=0x335 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -2916,7 +2786,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # MEM(EA,2)     = RS.S1;
 # MEM(EA+2,2)   = RS.S3;
 
-    EA:$(REGISTER_SIZE)   = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)   = EVUIMM_4_RAt;
     *:2 (EA) = *:2 ((S+2) & $(MEMMASK));
     *:2 (EA+2) = *:2 ((S+6) & $(MEMMASK));
 }
@@ -2924,7 +2794,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # evstwhox RS,RA,RB
 # ISA-cmt: Vector Store Word of Two Halfwords from Odd Indexed
 # evstwhox rS,rA,rB 011 0011 0100
-:evstwhox S,A,B is OP=4 & A & B & S & XOP_0_10=0x334 { 
+:evstwhox S,RA_OR_ZERO,B is OP=4 & RA_OR_ZERO & B & S & XOP_0_10=0x334 { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -2934,47 +2804,33 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # MEM(EA,2)     = RS.S1;
 # MEM(EA+2,2)   = RS.S3;
    
-    EA:$(REGISTER_SIZE)   = A + B;
+    EA:$(REGISTER_SIZE)   = RA_OR_ZERO + B;
     *:2 (EA) = *:2 ((S+2) & $(MEMMASK));
     *:2 (EA+2) = *:2 ((S+6) & $(MEMMASK));
 }
 
 # evstwwe RS,D(RA)
 # ISA-cmt: Vector Store Word of Word from Even
-# evstwwe rS,rA,EVUIMM_4 011 0011 1001
-#define pcodeop VectorStoreWordOfWordFromEven;
-#:evstwwe S,EVUIMM_4_RAt is OP=4 & A & S & EVUIMM_4_RAt & XOP_0_10=0x339 { 
-# if (RA == 0) {
-#     b    = 0;
-# } else {
-#     b    = RA;
-# }
-# EA        = b + EXTZ(UI*4);
-# MEM(EA,4) = RS;
-
-#     VectorStoreWordOfWordFromEven(S,A); 
-# }
+# evstwwe rS,rA,UIMM 011 0011 1001
+:evstwwe S,EVUIMM_4_RAt is OP=4 & S & EVUIMM_4_RAt & UI & XOP_0_10=0x339
+{
+   ea:$(REGISTER_SIZE) = EVUIMM_4_RAt;
+   *:4 ($(EATRUNC)) = S:4;
+}
 
 # evstwwex RS,RA,RB
 # ISA-cmt: Vector Store Word of Word from Even Indexed
 # evstwwex rS,rA,rB 011 0011 1000
-#define pcodeop VectorStoreWordOfWordFromEvenIndexed;
-#:evstwwex S,A,B is OP=4 & A & B & S & XOP_0_10=0x338 { 
-# if (RA == 0) {
-#     b    = 0;
-# } else {
-#     b    = RA;
-# }
-# EA        = b + RB;
-# MEM(EA,4) = RS;
-
-#    VectorStoreWordOfWordFromEvenIndexed(S,A,B); 
-# }
+:evstwwex S,RA_OR_ZERO,RB is OP=4 & S & RA_OR_ZERO & RB & XOP_0_10=0x338
+{
+    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
+    *:4 ($(EATRUNC)) = S:4;
+}
 
 # evstwwo RS,D(RA)
 # ISA-cmt: Vector Store Word of Word from Odd
 # evstwwo rS,rA,EVUIMM_4 011 0011 1101
-:evstwwo S,EVUIMM_4_RAt is OP=4 & A & S & EVUIMM_4_RAt & XOP_0_10=0x33D { 
+:evstwwo S,EVUIMM_4_RAt is OP=4 & S & EVUIMM_4_RAt & UI & XOP_0_10=0x33D { 
 # if (RA == 0) {
 #     b    = 0;
 # } else {
@@ -2983,7 +2839,7 @@ define pcodeop VectorShiftRightWordImmediateUnsigned;
 # EA        = b + EXTZ(UI*4);
 # MEM(EA,4)    = RS.h;
 
-    EA:$(REGISTER_SIZE)    = A + zext(EVUIMM_4_RAt);
+    EA:$(REGISTER_SIZE)    = EVUIMM_4_RAt;
     *:4 (EA) = *:4 ((S+4) & $(MEMMASK));
 }
 
@@ -3105,19 +2961,10 @@ define pcodeop VectorSubtractUnsignedSaturateIntegerToAccumulatorWord2;
 # evxor RT,RA,RB
 # ISA-cmt: Vector XOR
 # evxor rD,rA,rB 010 0001 0110
-# defined evx.sinc EJ XXX
-# define pcodeop VectorXOR;
-# :    D    = 64From2_32(hi,lo);
-# :evxor S,A,B is OP=4 & S & A & B & XOP_0_10=0x216 {
-# RT.l     = RA.l ^ RB.l;
-# RT.h    = RA.h ^ RB.h;
-
-# VectorXOR(S,A,B);
-# lo = A:2 ^ B:2;
-# hi = A(2) ^ B(2);
-# D:2 = lo;
-# D(2) = hi;
-# }
+:evxor vrD_64_0,vrA_64_0,vrB_64_0        is OP=4 & vrD_64_0 & vrA_64_0 & vrB_64_0 & XOP_0_10=534
+{
+    vrD_64_0 = vrA_64_0 ^ vrB_64_0;
+}
 
 # TODO evmwlssianw RT,RA,RB
 # TODO complicated
diff --git a/Ghidra/Processors/PowerPC/data/languages/SPE_EFV.sinc b/Ghidra/Processors/PowerPC/data/languages/SPE_EFV.sinc
index b71ddd36dad..5a94925d0be 100644
--- a/Ghidra/Processors/PowerPC/data/languages/SPE_EFV.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/SPE_EFV.sinc
@@ -1137,9 +1137,9 @@
 
 # evlwhe RT,D(RA)
 # evlwhe rT,rA,UI
-:evlwhe D,EVUIMM_4_RAt is OP=4 & D & EVUIMM_4_RAt & RA_OR_ZERO & UI & XOP_0_10=785
+:evlwhe D,EVUIMM_4_RAt is OP=4 & D & EVUIMM_4_RAt  & XOP_0_10=785
 {
-   ea:$(REGISTER_SIZE) = RA_OR_ZERO + (UI * 4);
+   ea:$(REGISTER_SIZE) = EVUIMM_4_RAt;
 
    # move results into upper and lower words
    tmpZ:8 = zext( *:2(ea + 2) );
@@ -1179,9 +1179,9 @@
 # ISA-info: evlwwsplat - Form "EVX" Page 521 Category "SP"
 # binutils: NO-EXAMPLE - evlwwsplat
 # collides with maclhwu
-:evlwwsplat D,EVUIMM_4_RAt is OP=4 & D & RA_OR_ZERO & EVUIMM_4_RAt & UI & XOP_0_10=793
+:evlwwsplat D,EVUIMM_4_RAt is OP=4 & D & EVUIMM_4_RAt & XOP_0_10=793
 {
-   ea:$(REGISTER_SIZE) = RA_OR_ZERO + (UI * 4);
+   ea:$(REGISTER_SIZE) = EVUIMM_4_RAt;
 
    # move results into upper and lower words
    tmpZ:8 = zext( *:4(ea) );
@@ -1413,10 +1413,34 @@
    tmpAL:8 = zext( A:4 );
    tmpBL:8 = zext( B:4 );
 
-   D = tmpAL * tmpBL;
+   temp:8 = tmpAL * tmpBL;
+   D = temp;
 }
 
+# evmwumia RT,RA,RB
+# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer to Accumulator
+# evmwumia rD,rA,rB 100 01A1 1000 A=1
+:evmwumia D,A,B is OP=4 & A & B & D & XOP_0_10=0x478 {
+   tmpAL:8 = zext( A:4 );
+   tmpBL:8 = zext( B:4 );
+
+   temp:8 = tmpAL * tmpBL;
+   D = temp;
+   ACC = D;
+}
 
+# evmwumiaa RT,RA,RB
+# ISA-cmt: Vector Multiply Word Unsigned, Modulo, Integer and Accumulate
+# evmwumiaa rD,rA,rB 101 0101 1000
+# evmwumiaa confict with macchwo
+:evmwumiaa D,A,B is OP=4 & A & B & D & XOP_0_10=0x558 { 
+   tmpAL:8 = zext( A:4 );
+   tmpBL:8 = zext( B:4 );
+
+   temp:8 = tmpAL * tmpBL;
+   D = ACC + temp;
+   ACC = D;
+}
 
 # =================================================================
 # Page 547
diff --git a/Ghidra/Processors/PowerPC/data/languages/evx.sinc b/Ghidra/Processors/PowerPC/data/languages/evx.sinc
index 190b52513ec..d2f68addb52 100644
--- a/Ghidra/Processors/PowerPC/data/languages/evx.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/evx.sinc
@@ -4,120 +4,6 @@
 @include "SPE_APU.sinc"
 @endif
 
-define pcodeop vectorExclusiveOr;
-define pcodeop vectorMergeHigh;
-define pcodeop vectorMergeLow;
-define pcodeop vectorLoadDoubleWordIntoDoubleWordIndexed;
-define pcodeop vectorStoreDoubleOfDoubleIndexed;
-define pcodeop initializeAccumulator;
-define pcodeop vectorShiftRightWordSigned;
-define pcodeop vectorShiftRightWordUnsigned;
-
-:evxor vrD_64_0,vrA_64_0,vrB_64_0        is OP=4 & vrD_64_0 & vrA_64_0 & vrB_64_0 & XOP_0_10=534
-{
-    vrD_64_0 = vrA_64_0 ^ vrB_64_0;
-}
-
-@if REGISTER_SIZE=="8"
-:evmergehi S,A,B        is OP=4 & S & A & B & XOP_0_10=556
-{
-	S[32,32] = A[32,32];
-	S[ 0,32] = B[ 0,32];
-}
-
-:evmergelo S,A,B        is OP=4 & S & A & B & XOP_0_10=557
-{
-	S[32,32] = A[0,32];
-	S[ 0,32] = B[0,32];
-}
-@endif
-
-
-:evldd RT,dUI16PlusRAOrZeroAddress is OP=4 & RT & dUI16PlusRAOrZeroAddress & XOP_0_10=769
-{
-   ea:$(REGISTER_SIZE) = dUI16PlusRAOrZeroAddress;
-   RT = *:8 ($(EATRUNC));
-}
-
-:evlddx RT,RA_OR_ZERO,RB is OP=4 & RT & RA_OR_ZERO & RB & XOP_0_10=768
-{
-    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
-    RT = *:8 ($(EATRUNC));
-}
-
-@if REGISTER_SIZE=="8"
-@ifndef IS_ISA
-:evsrws S,A,B        is OP=4 & S & A & B & XOP_0_10=545
-{
-	local low:4 = A[0,32];
-	local high:4 = A[32,32];
-	local low_shift:1 = B[0,5];
-	local high_shift:1 = B[32,5];
-	S[0,32] = low s>> zext(low_shift);
-	S[32,32] = high s>> zext(high_shift);
-}
-@endif
-
-@ifndef IS_ISA
-:evsrwu S,A,B        is OP=4 & S & A & B & XOP_0_10=544
-{
-	local low:4 = A[0,32];
-	local high:4 = A[32,32];
-	local low_shift:1 = B[0,5];
-	local high_shift:1 = B[32,5];
-	S[0,32] = low >> zext(low_shift);
-	S[32,32] = high >> zext(high_shift);
-}
-@endif
-@endif
-
-:evstdd RS,dUI16PlusRAOrZeroAddress is OP=4 & RS & dUI16PlusRAOrZeroAddress & XOP_0_10=801 
-{
-   ea:$(REGISTER_SIZE) = dUI16PlusRAOrZeroAddress;
-   *:8 ($(EATRUNC)) = RS;
-}
-
-:evstddx RS,RA_OR_ZERO,RB        is OP=4 & RS & RA_OR_ZERO & RB & XOP_0_10=800
-{
-    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
-    *:8 ($(EATRUNC)) = RS;
-}
-
-:evmra RT,RA        is OP=4 & RT & RA & BITS_11_15=0 & XOP_0_10=1220
-{
-	ACC = zext(RA);
-	RT = RA;
-}
-
-@if REGISTER_SIZE=="8"
-# evmergehilo rD,rA,rB 010 0010 1110
-:evmergehilo S,A,B is OP=4 & S & A & B & XOP_0_10=558 {
-	S[32,32] = A[32,32];
-	S[ 0,32] = B[ 0,32];
-
-}
-
-# evmergelohi rD,rA,rB 010 0010 1111
-:evmergelohi S,A,B is OP=4 & S & A & B & XOP_0_10=559 {
- 	S[32,32] = A[ 0,32];
-	S[ 0,32] = B[32,32];
-}
-@endif
-
-# evstwwe rS,rA,UIMM 011 0011 1001
-:evstwwe RS,dUI16PlusRAOrZeroAddress is OP=4 & RS & dUI16PlusRAOrZeroAddress & XOP_0_10=0x339
-{
-   ea:$(REGISTER_SIZE) = dUI16PlusRAOrZeroAddress;
-   *:4 ($(EATRUNC)) = RS:4;
-}
-
-# evstwwex rS,rA,rB 011 0011 1000
-:evstwwex RS,RA_OR_ZERO,RB is OP=4 & RS & RA_OR_ZERO & RB & XOP_0_10=0x338
-{
-    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
-    *:4 ($(EATRUNC)) = RS:4;
-}
-
 :lvx vrD, RA_OR_ZERO, RB  is OP=31 & vrD & RA_OR_ZERO & RB & XOP_1_10=103 & BIT_0=0
 {
     ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_be.slaspec b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_be.slaspec
index 5a9b490d754..79824069139 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_be.slaspec
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_be.slaspec
@@ -4,7 +4,7 @@
 # by the actual processor (e.g., floating pointer registers and associated instructions).
 # The actual processor only supports a subset of the registers and instructions implemented.
 
-@define E500
+@define E500 "1"
 
 @define ENDIAN "big"
 
@@ -19,10 +19,11 @@
 
 @define CTR_OFFSET "32"
 
-@define NoLegacyIntegerMultiplyAccumulate
+@define NoLegacyIntegerMultiplyAccumulate "1"
 
 @include "ppc_common.sinc"
 @include "quicciii.sinc"
+@include "SPE_APU.sinc"
 @include "evx.sinc"
 @include "SPEF_SCR.sinc"
 @include "SPE_EFSD.sinc"
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_le.slaspec b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_le.slaspec
index 719c0224598..a905d79e8eb 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_le.slaspec
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500_le.slaspec
@@ -4,7 +4,7 @@
 # by the actual processor (e.g., floating pointer registers and associated instructions).
 # The actual processor only supports a subset of the registers and instructions implemented.
 
-@define E500
+@define E500 "1"
 
 @define ENDIAN "little"
 
@@ -19,10 +19,11 @@
 
 @define CTR_OFFSET "32"
 
-@define NoLegacyIntegerMultiplyAccumulate
+@define NoLegacyIntegerMultiplyAccumulate "1"
 
 @include "ppc_common.sinc"
 @include "quicciii.sinc"
+@include "SPE_APU.sinc"
 @include "evx.sinc"
 @include "SPEF_SCR.sinc"
 @include "SPE_EFSD.sinc"
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_be.slaspec b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_be.slaspec
index d95cc072274..2c6e098091c 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_be.slaspec
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_be.slaspec
@@ -14,7 +14,7 @@
 #
 @define CTR_OFFSET "32"
 
-@define NoLegacyIntegerMultiplyAccumulate
+@define NoLegacyIntegerMultiplyAccumulate "1"
 
 @include "ppc_common.sinc"
 @include "quicciii.sinc"
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_le.slaspec b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_le.slaspec
index dd9a9c20b7d..ba65acec9cc 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_le.slaspec
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_32_e500mc_le.slaspec
@@ -12,7 +12,7 @@
 #
 @define CTR_OFFSET "32"
 
-@define NoLegacyIntegerMultiplyAccumulate
+@define NoLegacyIntegerMultiplyAccumulate "1"
 
 @include "ppc_common.sinc"
 @include "quicciii.sinc"
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc b/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc
index aaa76cc4acd..3a3d9a2e6a3 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc
@@ -1064,9 +1064,14 @@ define token instrvle(16)
 	LK0_VLE=(0,0)
 ;
 
-EVUIMM_2_RAt:       val^"("^A^")"	    is A & EVUIMM_2	[ val = EVUIMM_2*2; ]	{ tmp:4 = A+(EVUIMM_2*2); export tmp; }
-EVUIMM_4_RAt:       val^"("^A^")"	    is A & EVUIMM_4	[ val = EVUIMM_4*4; ]	{ tmp:4 = A+(EVUIMM_4*4); export tmp; }
-EVUIMM_8_RAt:       val^"("^A^")"	    is A & EVUIMM_8	[ val = EVUIMM_8*8; ]	{ tmp:4 = A+(EVUIMM_8*8); export tmp; }
+EVUIMM_2_RAt:       val^"("^RA^")"	    is RA & A   & EVUIMM_2	[ val = EVUIMM_2*2; ]	{ tmp:$(REGISTER_SIZE) = RA+zext(val:4); export tmp; }
+EVUIMM_2_RAt:       val^"("^RA^")"	    is RA & A=0 & EVUIMM_2	[ val = EVUIMM_2*2; ]	{ tmp:$(REGISTER_SIZE) =    zext(val:4); export tmp; }
+
+EVUIMM_4_RAt:       val^"("^RA^")"	    is RA & A & EVUIMM_4	[ val = EVUIMM_4*4; ]	{ tmp:$(REGISTER_SIZE) = RA+zext(val:4); export tmp; }
+EVUIMM_4_RAt:       val^"("^RA^")"	    is RA & A=0 & EVUIMM_4	[ val = EVUIMM_4*4; ]	{ tmp:$(REGISTER_SIZE) =    zext(val:4); export tmp; }
+
+EVUIMM_8_RAt:       val^"("^RA^")"	    is RA & A & EVUIMM_8	[ val = EVUIMM_8*8; ]	{ tmp:$(REGISTER_SIZE) = RA+zext(val:4); export tmp; }
+EVUIMM_8_RAt:       val^"("^RA^")"	    is RA & A=0 & EVUIMM_8	[ val = EVUIMM_8*8; ]	{ tmp:$(REGISTER_SIZE) =    zext(val:4); export tmp; }
 
 attach variables [ T ]
 	[ vs0    vs1   vs2   vs3   vs4   vs5   vs6   vs7   vs8   vs9  vs10  vs11  vs12  vs13  vs14  vs15  
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc b/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc
index f826beae39d..0094d68cdf8 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc
@@ -49,6 +49,13 @@
 	dataCacheBlockClearToZero(ea);
 }
 
+#dcbzl 0,r0		0x7c 20 07 ec
+:dcbzl RA_OR_ZERO,B	is OP=31 & BITS_21_25=1 & B & XOP_1_10=1014 & BIT_0=0 & RA_OR_ZERO
+{
+        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
+	dataCacheBlockClearToZero(ea);
+}
+
 define pcodeop memoryBarrier;
 #mbar 0         7c 00 06 ac
 :mbar MO        is OP=31 & MO & XOP_1_10=854
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc b/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
index c8bd8877e77..510bf963433 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
@@ -829,17 +829,17 @@ IMM16B: val						is IMM_0_10_VLE & IMM_16_20_VLE [ val = (IMM_16_20_VLE << 11) |
 	tmpS:4 = S:4;
 	tmpA:4 = (tmpS << SHL) | (tmpS >> (32 - SHL));
 
-	tmpM1 = (~0:4) << MBL;
-	tmpM1 = tmpM1 >> ((31-ME) + MBL);
-	tmpM1 = tmpM1 << (31-ME);
+	tmpM1:4 = (~0:4) << MBL;
+	tmpM1   = tmpM1 >> ((31-ME) + MBL);
+	tmpM1   = tmpM1 << (31-ME);
 
-	tmpM2 = (~0:4) << ME;
-	tmpM2 = tmpM2 >> ((31-MBL) + ME);
-	tmpM2 = tmpM2 << (31-MBL);
-	tmpM2 = ~tmpM2;
+	tmpM2:4 = (~0:4) << ME;
+	tmpM2   = tmpM2 >> ((31-MBL) + ME);
+	tmpM2   = tmpM2 << (31-MBL);
+	tmpM2   = ~tmpM2;
 
 	local invert = (ME:1 < MBL:1);
-	tmpM = (zext(invert == 0)*tmpM1) + (zext(invert == 1)*tmpM2);
+	tmpM:4 = (zext(invert == 0)*tmpM1) + (zext(invert == 1)*tmpM2);
 	A = zext(tmpA & tmpM) | (A & zext(~tmpM));	
 }
 
@@ -847,17 +847,17 @@ IMM16B: val						is IMM_0_10_VLE & IMM_16_20_VLE [ val = (IMM_16_20_VLE << 11) |
 	tmpS:4 = S:4;
 	tmpA:4 = (tmpS << SHL) | (tmpS >> (32 - SHL));
 
-	tmpM1 = (~0:4) << MBL;
-	tmpM1 = tmpM1 >> ((31-ME) + MBL);
-	tmpM1 = tmpM1 << (31-ME);
+	tmpM1:4 = (~0:4) << MBL;
+	tmpM1   = tmpM1 >> ((31-ME) + MBL);
+	tmpM1   = tmpM1 << (31-ME);
 
-	tmpM2 = (~0:4) << ME;
+	tmpM2:4 = (~0:4) << ME;
 	tmpM2 = tmpM2 >> ((31-MBL) + ME);
 	tmpM2 = tmpM2 << (31-MBL);
 	tmpM2 = ~tmpM2;
 
 	local invert = (ME:1 < MBL:1);
-	tmpM = (zext(invert == 0)*tmpM1) + (zext(invert == 1)*tmpM2);
+	tmpM:4 = (zext(invert == 0)*tmpM1) + (zext(invert == 1)*tmpM2);
 	A = zext(tmpA & tmpM);		
 }
 
diff --git a/Ghidra/Processors/PowerPC/data/patterns/PPC_BE_patterns.xml b/Ghidra/Processors/PowerPC/data/patterns/PPC_BE_patterns.xml
index 4a9b96fc781..d69520f08df 100644
--- a/Ghidra/Processors/PowerPC/data/patterns/PPC_BE_patterns.xml
+++ b/Ghidra/Processors/PowerPC/data/patterns/PPC_BE_patterns.xml
@@ -6,6 +6,7 @@
     </prepatterns>
     <postpatterns>
       <data>10010100 00100001 11...... .....000 </data>             <!-- STWU r1,xx(r1) -->
+      <data>011111.. ...01000 00000010 10100110 </data>             <!-- MFSPR rx,lr  -->
       <data>0x7c2c0b78 0x38 0x21 ........ ........ 0x91810000 </data> <!--  or r12,r1,r1; stw r12,0x0(r1) -->
       <codeboundary />              <!-- it is at least code -->
       <possiblefuncstart/>
@@ -17,8 +18,11 @@
     </prepatterns>
     <postpatterns>
      <data>10010100 00100001 11...... .....000             011111.. ...01000 00000010 10100110 </data> <!-- STWU r1,xx(r1); MFSPR rx,lr -->
+     <data>011111.. ...01000 00000010 10100110             10010100 00100001 11...... .....000 </data> <!-- MFSPR rx,lr; STWU r1,xx(r1); -->
      <data>10010100 00100001 11...... .....000  0x........ 011111.. ...01000 00000010 10100110 </data> <!-- STWU r1,xx(r1); xxx_instr; MFSPR rx,lr -->
+     <data>011111.. ...01000 00000010 10100110  0x........ 10010100 00100001 11...... .....000 </data> <!-- MFSPR rx,lr;    xxx_instr; STWU r1,xx(r1) -->
      <data>10010100 00100001 11...... .....000  0x........ 0x........ 011111.. ...01000 00000010 10100110 </data> <!-- STWU r1,xx(r1); xxx_instr; xxx_instr; MFSPR rx,lr -->
+     <data>011111.. ...01000 00000010 10100110  0x........ 0x........ 10010100 00100001 11...... .....000  </data> <!-- MFSPR rx,lr;    xxx_instr; xxx_instr;  STWU r1,xx(r1) -->
      <data>0x7c2c0b78 0x38 0x21 ........ ........ 0x91810000 </data> <!--  or r12,r1,r1; stw r12,0x0(r1) -->
      <codeboundary />              <!-- it is at least code -->
      <possiblefuncstart/>
@@ -31,6 +35,12 @@
       <possiblefuncstart after="defined" /> <!-- must be something defined right before this -->
   </pattern>
   
+  <pattern> 
+      <data>011111.. ...01000 00000010 10100110             10010100 00100001 11...... .....000 </data> <!-- MFSPR rx,lr; STWU r1,xx(r1) -->
+      <codeboundary />
+      <possiblefuncstart after="defined" /> <!-- must be something defined right before this -->
+  </pattern>
+  
   <pattern> 
       <data> 0x4e 0x80 0x00 0x21</data> <!-- blrl -->
       <possiblefuncstart validcode="function" label="__get_pc_thunk_lr" /> <!-- must be a function here -->
diff --git a/Ghidra/Processors/PowerPC/data/patterns/PPC_LE_patterns.xml b/Ghidra/Processors/PowerPC/data/patterns/PPC_LE_patterns.xml
index e334a96bace..6e4e7b739e4 100644
--- a/Ghidra/Processors/PowerPC/data/patterns/PPC_LE_patterns.xml
+++ b/Ghidra/Processors/PowerPC/data/patterns/PPC_LE_patterns.xml
@@ -6,6 +6,7 @@
     </prepatterns>
     <postpatterns>
       <data>.....000 11...... 00100001 10010100 </data>             <!-- STWU r1,xx(r1) -->
+      <data>10100110 00000010 ...01000 011111.. </data>             <!-- MFSPR rx,lr  -->
       <data>0x780b2c7c   ........ ........ 0x21 0x38   0x00008191 </data> <!--  or r12,r1,r1; stw r12,0x0(r1) -->
       <codeboundary />              <!-- it is at least code -->
       <possiblefuncstart/>
@@ -17,8 +18,11 @@
     </prepatterns>
     <postpatterns>
      <data>.....000 11...... 00100001 10010100             10100110 00000010 ...01000 011111.. </data> <!-- STWU r1,xx(r1); MFSPR rx,lr -->
+     <data>10100110 00000010 ...01000 011111..             .....000 11...... 00100001 10010100 </data> <!-- MFSPR rx,lr; STWU r1,xx(r1); -->
      <data>.....000 11...... 00100001 10010100  0x........ 10100110 00000010 ...01000 011111.. </data> <!-- STWU r1,xx(r1); xxx_instr; MFSPR rx,lr -->
+     <data>10100110 00000010 ...01000 011111..  0x........ .....000 11...... 00100001 10010100 </data> <!-- MFSPR rx,lr;    xxx_instr; STWU r1,xx(r1) -->
      <data>.....000 11...... 00100001 10010100  0x........ 0x........ 10100110 00000010 ...01000 011111.. </data> <!-- STWU r1,xx(r1); xxx_instr; xxx_instr; MFSPR rx,lr -->
+     <data>10100110 00000010 ...01000 011111..  0x........ 0x........ .....000 11...... 00100001 10010100  </data> <!-- MFSPR rx,lr;    xxx_instr; xxx_instr;  STWU r1,xx(r1) -->
      <data>0x780b2c7c  ........ ........  0x21 0x38   0x00008191 </data> <!--  or r12,r1,r1; stw r12,0x0(r1) -->
      <codeboundary />              <!-- it is at least code -->
      <possiblefuncstart/>
@@ -31,6 +35,12 @@
       <possiblefuncstart after="defined" /> <!-- must be something defined right before this -->
   </pattern>
 
+  <pattern> 
+      <data>10100110 00000010 ...01000 011111..             .....000 11...... 00100001 10010100 </data> <!-- MFSPR rx,lr; STWU r1,xx(r1) -->
+      <codeboundary />
+      <possiblefuncstart after="defined" /> <!-- must be something defined right before this -->
+  </pattern>
+  
   <pattern> 
       <data>0x21 0x00 0x80 0x4e</data> <!-- blrl -->
       <possiblefuncstart validcode="function" label="__get_pc_thunk_lr" /> <!-- must be a function here -->
```
-----------------------------------
