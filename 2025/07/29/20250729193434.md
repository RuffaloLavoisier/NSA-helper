# Commit: e355d86144b45b61bc318810b3efc2bd8362669f
## Message: API rate limit exceeded for 172.178.119.18. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)
## Diff:
```
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java
index f271bf3e6de..99ae712879f 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java
@@ -39,11 +39,11 @@
 import ghidra.framework.options.SaveState;
 import ghidra.framework.plugintool.*;
 import ghidra.framework.plugintool.annotation.AutoConfigStateField;
+import ghidra.pcode.exec.PcodeExecutionException;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressSpace;
 import ghidra.program.util.ProgramLocation;
 import ghidra.trace.model.*;
-import ghidra.trace.model.stack.TraceStack;
 import ghidra.trace.model.stack.TraceStackFrame;
 import ghidra.trace.model.target.TraceObjectValue;
 import ghidra.trace.model.thread.TraceThread;
@@ -62,7 +62,6 @@ protected class ForTrackingListener extends TraceDomainObjectListener {
 
 		public ForTrackingListener() {
 			listenFor(TraceEvents.BYTES_CHANGED, this::registersChanged);
-			//listenFor(TraceEvents.STACK_CHANGED, this::stackChanged);
 			listenFor(TraceEvents.VALUE_CREATED, this::valueCreated);
 			listenFor(TraceEvents.VALUE_LIFESPAN_CHANGED, this::valueLifespanChanged);
 		}
@@ -79,17 +78,6 @@ private void registersChanged(AddressSpace space, TraceAddressSnapRange range,
 			doTrack(TrackCause.DB_CHANGE);
 		}
 
-		private void stackChanged(TraceStack stack) {
-			if (current.getView() == null || spec == null) {
-				// Should only happen during transitional times, if at all.
-				return;
-			}
-			if (!tracker.affectedByStackChange(stack, current)) {
-				return;
-			}
-			doTrack(TrackCause.DB_CHANGE);
-		}
-
 		private void valueCreated(TraceObjectValue value) {
 			if (!value.getLifespan().contains(current.getSnap())) {
 				return;
@@ -255,7 +243,7 @@ protected ActionState<LocationTrackingSpec> makeState(LocationTrackingSpec spec)
 	public List<ActionState<LocationTrackingSpec>> getStates() {
 		Map<String, ActionState<LocationTrackingSpec>> states = new TreeMap<>();
 		// NOTE: Ensure the saved spec is available, even if no factory produces it, yet.
-		// NOTE: In particular, the DebuggerWatchesPlugin may not read its config before us.
+		// NOTE: In particular, the DebuggerWatchesPlugin might not read its config before us.
 		states.put(spec.getConfigName(), makeState(spec));
 		for (LocationTrackingSpec spec : LocationTrackingSpecFactory
 				.allSuggested(tool)
@@ -332,6 +320,14 @@ protected void doTrack(TrackCause cause) {
 		catch (TraceClosedException ex) {
 			// Silently continue
 		}
+		catch (PcodeExecutionException ex) {
+			if (ex.getCause() instanceof TraceClosedException) {
+				// Silently continue
+			}
+			else {
+				Msg.error(this, "Error while computing locatin: " + ex);
+			}
+		}
 		catch (Throwable ex) {
 			Msg.error(this, "Error while computing location: " + ex);
 		}
```
-----------------------------------
