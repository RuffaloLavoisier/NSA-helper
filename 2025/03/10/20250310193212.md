# Commit: 75288d7d321df8058f9e42fa411d69c6c10c9cbf
## Message: Merge remote-tracking branch 'origin/GP-5407_d-millar_TTD_putmem_state--SQUASHED'
## Diff:
```
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/certification.manifest b/Ghidra/Debug/Debugger-agent-dbgeng/certification.manifest
index f90bee98644..ac548173e4e 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/certification.manifest
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/certification.manifest
@@ -6,8 +6,8 @@ README.md||GHIDRA||||END|
 data/debugger-launchers/kernel-dbgeng.bat||GHIDRA||||END|
 data/debugger-launchers/local-dbgeng-attach.bat||GHIDRA||||END|
 data/debugger-launchers/local-dbgeng-ext.bat||GHIDRA||||END|
+data/debugger-launchers/local-dbgeng-trace.bat||GHIDRA||||END|
 data/debugger-launchers/local-dbgeng.bat||GHIDRA||||END|
-data/debugger-launchers/local-ttd.bat||GHIDRA||||END|
 data/debugger-launchers/remote-dbgeng.bat||GHIDRA||||END|
 data/debugger-launchers/svrcx-dbgeng.bat||GHIDRA||||END|
 src/main/py/LICENSE||GHIDRA||||END|
@@ -17,4 +17,3 @@ src/main/py/pyproject.toml||GHIDRA||||END|
 src/main/py/src/ghidradbg/dbgmodel/DbgModel.idl||GHIDRA||||END|
 src/main/py/src/ghidradbg/schema.xml||GHIDRA||||END|
 src/main/py/src/ghidradbg/schema_exdi.xml||GHIDRA||||END|
-src/main/py/src/ghidrattd/schema.xml||GHIDRA||||END|
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-dbgeng-trace.bat b/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-dbgeng-trace.bat
new file mode 100644
index 00000000000..55f5b46e656
--- /dev/null
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-dbgeng-trace.bat
@@ -0,0 +1,21 @@
+::@title dbgeng-trace
+::@desc <html><body width="300px">
+::@desc   <h3>Open trace with <tt>dbgeng</tt> (in a Python interpreter)</h3>
+::@desc   <p>
+::@desc     This will open a WinDbg TTD trace of the target on the local machine using <tt>dbgeng.dll</tt>.
+::@desc     For setup instructions, press <b>F1</b>.
+::@desc   </p>
+::@desc </body></html>
+::@menu-group local
+::@icon icon.debugger
+::@help TraceRmiLauncherServicePlugin#dbgeng_trace
+::@env OPT_PYTHON_EXE:file!="python" "Python command" "The path to the Python 3 interpreter. Omit the full path to resolve using the system PATH."
+:: Use env instead of args, because "all args except first" is terrible to implement in batch
+::@env OPT_TARGET_TRACE:file="" "Trace (.run)" "The target trace image"
+::@env OPT_USE_DBGMODEL:bool=true "Use dbgmodel" "Load and use dbgmodel.dll if it is available."
+::@env WINDBG_DIR:dir="" "Path to dbgeng.dll directory" "Path containing dbgeng and associated DLLS (if not Windows Kits)."
+
+@echo off
+
+set USE_TTD=true
+"%OPT_PYTHON_EXE%" -i ..\support\local-dbgeng-trace.py
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-ttd.bat b/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-ttd.bat
deleted file mode 100644
index 7d6e2778191..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/data/debugger-launchers/local-ttd.bat
+++ /dev/null
@@ -1,21 +0,0 @@
-::@title ttd
-::@desc <html><body width="300px">
-::@desc   <h3>Launch with <tt>ttd</tt> (in a Python interpreter)</h3>
-::@desc   <p>
-::@desc     This will launch the target on the local machine for time-travel debugging.
-::@desc     For setup instructions, press <b>F1</b>.
-::@desc   </p>
-::@desc </body></html>
-::@menu-group local
-::@icon icon.debugger
-::@help TraceRmiLauncherServicePlugin#dbgeng_ttd
-::@env OPT_PYTHON_EXE:file!="python" "Python command" "The path to the Python 3 interpreter. Omit the full path to resolve using the system PATH."
-:: Use env instead of args, because "all args except first" is terrible to implement in batch
-::@env OPT_TARGET_IMG:file!="" "Trace (.run)" "A trace associated with the target binary executable"
-::@env OPT_TARGET_ARGS:str="" "Arguments" "Command-line arguments to pass to the target"
-::@env OPT_USE_DBGMODEL:bool=true "Use dbgmodel" "Load and use dbgmodel.dll if it is available."
-::@env OPT_DBGMODEL_PATH:dir="" "Path to dbgeng.dll & \\ttd" "Path containing dbgeng and associated DLLS (if not Windows Kits)."
-
-@echo off
-
-"%OPT_PYTHON_EXE%" -i ..\support\local-ttd.py
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-dbgeng-trace.py b/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-dbgeng-trace.py
new file mode 100644
index 00000000000..82a223eaab3
--- /dev/null
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-dbgeng-trace.py
@@ -0,0 +1,73 @@
+## ###
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+##
+
+import os
+import sys
+
+
+home = os.getenv('GHIDRA_HOME')
+
+if os.path.isdir(f'{home}\\ghidra\\.git'):
+    sys.path.append(
+        f'{home}\\ghidra\\Ghidra\\Debug\\Debugger-agent-dbgeng\\build\\pypkg\\src')
+    sys.path.append(
+        f'{home}\\ghidra\\Ghidra\\Debug\\Debugger-rmi-trace\\build\\pypkg\\src')
+elif os.path.isdir(f'{home}\\.git'):
+    sys.path.append(
+        f'{home}\\Ghidra\\Debug\\Debugger-agent-dbgeng\\build\\pypkg\\src')
+    sys.path.append(
+        f'{home}\\Ghidra\\Debug\\Debugger-rmi-trace\\build\\pypkg\\src')
+else:
+    sys.path.append(
+        f'{home}\\Ghidra\\Debug\\Debugger-agent-dbgeng\\pypkg\\src')
+    sys.path.append(f'{home}\\Ghidra\\Debug\\Debugger-rmi-trace\\pypkg\\src')
+
+
+def main():
+    # Delay these imports until sys.path is patched
+    from ghidradbg import commands as cmd
+    from pybag.dbgeng import core as DbgEng
+    from ghidradbg.hooks import on_state_changed
+    from ghidradbg.util import dbg
+
+    # So that the user can re-enter by typing repl()
+    global repl
+    repl = cmd.repl
+
+    cmd.ghidra_trace_connect(os.getenv('GHIDRA_TRACE_RMI_ADDR'))
+    target = os.getenv('OPT_TARGET_TRACE')
+    if target is None or target == "":
+        print("dbgeng requires a target trace - please try again.")
+        cmd.ghidra_trace_disconnect()
+        return
+    
+    cmd.ghidra_trace_open(target, start_trace=False)
+    
+    # TODO: HACK
+    try:
+        dbg.wait()
+    except KeyboardInterrupt as ki:
+        dbg.interrupt()
+
+    cmd.ghidra_trace_start(target)
+    cmd.ghidra_trace_sync_enable()
+    
+    on_state_changed(DbgEng.DEBUG_CES_EXECUTION_STATUS, DbgEng.DEBUG_STATUS_BREAK)
+    cmd.repl()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-ttd.py b/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-ttd.py
deleted file mode 100644
index d9f861a5b5e..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/data/support/local-ttd.py
+++ /dev/null
@@ -1,58 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-
-import os
-import sys
-
-
-home = os.getenv('GHIDRA_HOME')
-
-if os.path.isdir(f'{home}\\ghidra\\.git'):
-    sys.path.append(
-        f'{home}\\ghidra\\Ghidra\\Debug\\Debugger-agent-dbgeng\\build\\pypkg\\src')
-    sys.path.append(
-        f'{home}\\ghidra\\Ghidra\\Debug\\Debugger-rmi-trace\\build\\pypkg\\src')
-elif os.path.isdir(f'{home}\\.git'):
-    sys.path.append(
-        f'{home}\\Ghidra\\Debug\\Debugger-agent-dbgeng\\build\\pypkg\\src')
-    sys.path.append(
-        f'{home}\\Ghidra\\Debug\\Debugger-rmi-trace\\build\\pypkg\\src')
-else:
-    sys.path.append(
-        f'{home}\\Ghidra\\Debug\\Debugger-agent-dbgeng\\pypkg\\src')
-    sys.path.append(f'{home}\\Ghidra\\Debug\\Debugger-rmi-trace\\pypkg\\src')
-
-
-def main():
-    # Delay these imports until sys.path is patched
-    from ghidrattd import commands as cmd
-    from ghidrattd import hooks
-    ###from ghidrattd.util import dbg
-
-    cmd.ghidra_trace_connect(os.getenv('GHIDRA_TRACE_RMI_ADDR'))
-    args = os.getenv('OPT_TARGET_ARGS')
-    if args:
-        args = ' ' + args
-    cmd.ghidra_trace_create(
-        os.getenv('OPT_TARGET_IMG') + args, start_trace=True)
-    cmd.ghidra_trace_sync_enable()
-    hooks.on_stop()
-
-    cmd.repl()
-
-
-if __name__ == '__main__':
-    main()
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/commands.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/commands.py
index 5ea94e43a30..2d9debe38d8 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/commands.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/commands.py
@@ -24,15 +24,16 @@
 
 from comtypes import c_ulong
 from ghidratrace import sch
-from ghidratrace.client import Client, Address, AddressRange, TraceObject
+from ghidratrace.client import Client, Address, AddressRange, Lifespan, TraceObject
 from pybag import pydbg, userdbg, kerneldbg
 from pybag.dbgeng import core as DbgEng
 from pybag.dbgeng import exception
 
 from . import util, arch, methods, hooks
 from .dbgmodel.imodelobject import ModelObjectKind
+
 if util.is_exdi():
-	from .exdi import exdi_commands, exdi_methods
+    from .exdi import exdi_commands, exdi_methods
 
 STILL_ACTIVE = 259
 PAGE_SIZE = 4096
@@ -65,6 +66,9 @@
 SECTION_KEY_PATTERN = '[{secname}]'
 SECTION_ADD_PATTERN = SECTIONS_ADD_PATTERN + SECTION_KEY_PATTERN
 GENERIC_KEY_PATTERN = '[{key}]'
+TTD_PATTERN = 'State.DebuggerVariables.{var}.TTD'
+
+DESCRIPTION_PATTERN = '[{major}] {type}'
 
 # TODO: Symbols
 
@@ -221,7 +225,8 @@ def start_trace(name):
     variant = " (dbgmodel)" if using_dbgmodel else " (dbgeng)"
     with STATE.trace.open_tx("Create Root Object"):
         root = STATE.trace.create_root_object(schema_xml, 'DbgRoot')
-        root.set_value('_display', util.DBG_VERSION.full + ' via pybag' + variant)
+        root.set_value('_display', util.DBG_VERSION.full + 
+                       ' via pybag' + variant)
         if util.dbg.use_generics:
             put_generic(root)
     util.set_convenience_variable('_ghidra_tracing', "true")
@@ -294,7 +299,8 @@ def ghidra_trace_create_ext(command=None, initialDirectory='.', envVariables="\0
             envVariables = None
         if envVariables is not None and envVariables.endswith("/0/0") is False:
             envVariables += "/0/0"
-        dbg._client.CreateProcess2(command, options, initialDirectory, envVariables)
+        dbg._client.CreateProcess2(
+            command, options, initialDirectory, envVariables)
         dbg._control.AddEngineOptions(int(engine_options))
     if start_trace:
         ghidra_trace_start(command)
@@ -312,9 +318,9 @@ def ghidra_trace_attach(pid=None, attach_flags='0', initial_break=True, timeout=
     if attach_flags == None:
         attach_flags = '0'
     if pid != None:
-        dbg._client.AttachProcess(int(pid,0), int(attach_flags,0))
+        dbg._client.AttachProcess(int(pid, 0), int(attach_flags, 0))
     if start_trace:
-        ghidra_trace_start("pid_"+pid)
+        ghidra_trace_start("pid_" + pid)
 
 
 @util.dbg.eng_thread
@@ -348,6 +354,19 @@ def ghidra_trace_connect_server(options=None):
         dbg._client.ConnectProcessServer(enc_options)
 
 
+@util.dbg.eng_thread
+def ghidra_trace_open(command=None, initial_break=True, timeout=DbgEng.WAIT_INFINITE, start_trace=True):
+    """
+    Create a session.
+    """
+
+    dbg = util.dbg._base
+    if command != None:
+        util.open_trace_or_dump(command)
+    if start_trace:
+        ghidra_trace_start(command)
+
+
 @util.dbg.eng_thread
 def ghidra_trace_kill():
     """
@@ -370,7 +389,7 @@ def ghidra_trace_info():
         print("Not connected to Ghidra")
         return
     host, port = STATE.client.s.getpeername()
-    print(f"Connected to {STATE.client.description} at {host}:{port}")
+    print(f"Connected to {STATE.client.description} at {host}: {port}")
     if STATE.trace is None:
         print("No trace")
         return
@@ -585,7 +604,7 @@ def putreg():
         nframe = util.selected_frame()
         # NB: We're going to update the Register View for non-zero stack frames
         if nframe == 0:
-        	return {'missing': STATE.trace.put_registers(rpath, values)}
+            return {'missing': STATE.trace.put_registers(rpath, values)}
 
     nproc = util.selected_process()
     if nproc < 0:
@@ -601,13 +620,13 @@ def putreg():
     for i in range(0, len(regs)):
         name = regs._reg.GetDescription(i)[0]
         try:
-        	value = regs._get_register_by_index(i)
+            value = regs._get_register_by_index(i)
         except Exception:
-        	value = 0
+            value = 0
         try:
             values.append(mapper.map_value(nproc, name, value))
             if util.dbg.use_generics is False:
-            	robj.set_value(name, hex(value))
+                robj.set_value(name, hex(value))
         except Exception:
             pass
     return {'missing': STATE.trace.put_registers(space, values)}
@@ -903,9 +922,10 @@ def activate(path=None):
             else:
                 frame = util.selected_frame()
                 if frame is None:
-                	path = THREAD_PATTERN.format(procnum=nproc, tnum=nthrd)
+                    path = THREAD_PATTERN.format(procnum=nproc, tnum=nthrd)
                 else:
-                	path = FRAME_PATTERN.format(procnum=nproc, tnum=nthrd, level=frame)
+                    path = FRAME_PATTERN.format(
+                        procnum=nproc, tnum=nthrd, level=frame)
     trace.proxy_object_path(path).activate()
 
 
@@ -1198,11 +1218,11 @@ def put_regions():
         regobj.set_value('AllocationBase', hex(r.AllocationBase))
         regobj.set_value('Protect', hex(r.Protect))
         regobj.set_value('Type', hex(r.Type))
-        if hasattr(r, 'Name') and  r.Name is not None:
+        if hasattr(r, 'Name') and r.Name is not None:
             regobj.set_value('_display', r.Name)
         regobj.insert()
-    STATE.trace.proxy_object_path(
-        MEMORY_PATTERN.format(procnum=nproc)).retain_values(keys)
+    #STATE.trace.proxy_object_path(
+    #    MEMORY_PATTERN.format(procnum=nproc)).retain_values(keys)
 
 
 def ghidra_trace_put_regions():
@@ -1257,6 +1277,24 @@ def put_modules():
         procnum=nproc)).retain_values(mod_keys)
 
 
+def get_module(key, mod):
+    nproc = util.selected_process()
+    modmap = util.get_attributes(mod)
+    base = util.get_value(modmap["Address"])
+    size = util.get_value(modmap["Size"])
+    name = util.get_value(modmap["Name"])
+    mpath = MODULE_PATTERN.format(procnum=nproc, modpath=hex(base))
+    modobj = STATE.trace.create_object(mpath)
+    mapper = STATE.trace.memory_mapper
+    base_base, base_addr = mapper.map(nproc, base)
+    if base_base != base_addr.space:
+        STATE.trace.create_overlay_space(base_base, base_addr.space)
+    modobj.set_value('Range', base_addr.extend(size))
+    modobj.set_value('Name', name)
+    modobj.set_value('_display','{} {:x} {}'.format(key, base, name))
+    return modobj
+
+
 def ghidra_trace_put_modules():
     """
     Gather object files, if applicable, and write to the trace's Modules
@@ -1334,6 +1372,24 @@ def put_event_thread(nthrd=None):
     STATE.trace.proxy_object_path('').set_value('_event_thread', tobj)
 
 
+def get_thread(key, thread):
+    pid = util.selected_process()
+    tmap = util.get_attributes(thread)
+    tid = int(key[1:len(key)-1])
+    radix = util.get_convenience_variable('output-radix')
+    if radix == 'auto':
+        radix = 16
+    tpath = THREAD_PATTERN.format(procnum=pid, tnum=tid)
+    tobj = STATE.trace.create_object(tpath)
+    tobj.set_value('TID', tid, span=Lifespan(0))
+    tidstr = ('0x{:x}' if radix == 16 else '0{:o}' if radix == 
+              8 else '{}').format(tid)
+    tobj.set_value('_short_display', '[{}:{}]'.format(
+        pid, tidstr), span=Lifespan(0))
+    tobj.set_value('_display', '[{}]'.format(tidstr), span=Lifespan(0))
+    return tobj
+
+
 def ghidra_trace_put_threads():
     """
     Put the current process's threads into the Ghidra trace
@@ -1358,7 +1414,7 @@ def put_frames():
         (values, keys) = create_generic(path)
         STATE.trace.proxy_object_path(path).retain_values(keys)
         # NB: some flavors of dbgmodel lack Attributes, so we grab Instruction Offset regardless
-        #return
+        # return
 
     mapper = STATE.trace.memory_mapper
     keys = []
@@ -1373,18 +1429,18 @@ def put_frames():
             STATE.trace.create_overlay_space(base, offset_inst.space)
         fobj.set_value('Instruction Offset', offset_inst)
         if not util.dbg.use_generics:
-	        base, offset_stack = mapper.map(nproc, f.StackOffset)
-	        if base != offset_stack.space:
-	            STATE.trace.create_overlay_space(base, offset_stack.space)
-	        base, offset_ret = mapper.map(nproc, f.ReturnOffset)
-	        if base != offset_ret.space:
-	            STATE.trace.create_overlay_space(base, offset_ret.space)
-	        base, offset_frame = mapper.map(nproc, f.FrameOffset)
-	        if base != offset_frame.space:
-	            STATE.trace.create_overlay_space(base, offset_frame.space)
-	        fobj.set_value('Stack Offset', offset_stack)
-	        fobj.set_value('Return Offset', offset_ret)
-	        fobj.set_value('Frame Offset', offset_frame)
+            base, offset_stack = mapper.map(nproc, f.StackOffset)
+            if base != offset_stack.space:
+                STATE.trace.create_overlay_space(base, offset_stack.space)
+            base, offset_ret = mapper.map(nproc, f.ReturnOffset)
+            if base != offset_ret.space:
+                STATE.trace.create_overlay_space(base, offset_ret.space)
+            base, offset_frame = mapper.map(nproc, f.FrameOffset)
+            if base != offset_frame.space:
+                STATE.trace.create_overlay_space(base, offset_frame.space)
+            fobj.set_value('Stack Offset', offset_stack)
+            fobj.set_value('Return Offset', offset_ret)
+            fobj.set_value('Frame Offset', offset_frame)
         fobj.set_value('_display', "#{} {}".format(
             f.FrameNumber, offset_inst.offset))
         fobj.insert()
@@ -1402,79 +1458,105 @@ def ghidra_trace_put_frames():
         put_frames()
 
 
-def update_by_container(np, keyval, obj):
-    index = keyval[0]
-    key = ''
+def update_key(np, keyval):
+    """
+    This should set the modified key
+    """
+    key = keyval[0]
+    if np.endswith("Modules"):
+        key = '[{:d}]'.format(key)
+        mo = util.get_object(np+key+".BaseAddress")
+        key = hex(util.get_value(mo))
+    return key
+
+
+def update_by_container(np, keyval, to):
+    """
+    Sets non-generic variables by container
+    """
+    key = keyval[0]
+    disp = ''
     if np.endswith("Processes") or np.endswith("Threads"):
-        istate = compute_proc_state(index)
-        obj.set_value('State', istate)
+        istate = compute_proc_state(key)
+        to.set_value('State', istate)
     if np.endswith("Sessions"):
-        key = '[{:x}]'.format(index)
+        disp = '[{:x}]'.format(key)
     if np.endswith("Processes"):
-        create_generic(obj.path)
-        obj.set_value('PID', index)
-        create_generic(obj.path + ".Memory")
+        create_generic(to.path)
+        to.set_value('PID', key)
+        create_generic(to.path + ".Memory")
         if util.is_kernel():
-            key = '[{:x}]'.format(index)
+            disp = '[{:x}]'.format(key)
         else:
-            id = util.get_proc_id(index)
-            key = '{:x} [{:x}]'.format(id, index)
+            id = util.get_proc_id(key)
+            disp = '{:x} [{:x}]'.format(id, key)
     if np.endswith("Breakpoints"):
-        create_generic(obj.path)
+        create_generic(to.path)
     if np.endswith("Threads"):
-        create_generic(obj.path)
-        obj.set_value('TID', index)
+        create_generic(to.path)
+        to.set_value('TID', key)
         if util.is_kernel():
-            key = '[{:x}]'.format(index)
+            disp = '[{:x}]'.format(key)
         else:
-            id = util.get_thread_id(index)
-            key = '{:x} [{:x}]'.format(id, index)
+            id = util.get_thread_id(key)
+            disp = '{:x} [{:x}]'.format(id, key)
     if np.endswith("Frames"):
-        mo = util.get_object(obj.path)
+        mo = util.get_object(to.path)
         map = util.get_attributes(mo)
         if 'Attributes' in map:
             attr = map["Attributes"]
             if attr is not None:
-                map = util.get_attributes(attr)        
+                map = util.get_attributes(attr)
                 pc = util.get_value(map["InstructionOffset"])
                 (pc_base, pc_addr) = map_address(pc)
-                obj.set_value('Instruction Offset', pc_addr)
-                key = '#{:x} 0x{:x}'.format(index, pc)
+                to.set_value('Instruction Offset', pc_addr)
+                disp = '#{:x} 0x{:x}'.format(key, pc)
     if np.endswith("Modules"):
-        create_generic(obj.path)
-        mo = util.get_object(obj.path)
+        modobjpath=np+'[{:d}]'.format(key)
+        create_generic(to.path, modobjpath=modobjpath)
+        mo = util.get_object(modobjpath)
         map = util.get_attributes(mo)
         base = util.get_value(map["BaseAddress"])
         size = util.get_value(map["Size"])
         name = util.get_value(map["Name"])
-        obj.set_value('Name', '{}'.format(name))
+        to.set_value('Name', '{}'.format(name))
         (base_base, base_addr) = map_address(base)
-        obj.set_value('Range', base_addr.extend(size))
-        key = '{:x} {:x} {}'.format(index, base, name)
-    disp = util.to_display_string(keyval[1])
-    if disp is not None:
-        key += " " + disp
-    if key is not None and key != "":
-        obj.set_value('_display', key)
+        to.set_value('Range', base_addr.extend(size))
+        disp = '{:x} {:x} {}'.format(key, base, name)
+    disp0 = util.to_display_string(keyval[1])
+    if disp0 is not None:
+        disp += " " + disp0
+    if disp is not None and disp != "":
+        to.set_value('_display', disp)
 
 
-def create_generic(path):
+def create_generic(path, modobjpath=None):
     obj = STATE.trace.create_object(path)
+    result = put_generic(obj, modobjpath)
+    obj.insert()
+    return result
+
+
+def put_generic_from_node(node):
+    obj = STATE.trace.create_object(node.path)
+    result = put_generic(obj, None)
     obj.insert()
-    result = put_generic(obj)
     return result
 
 
-def put_generic(node):
+def put_generic(node, modobjpath=None):
     # print(f"put_generic: {node}")
     nproc = util.selected_process()
     if nproc is None:
         return
     nthrd = util.selected_thread()
 
-    mo = util.get_object(node.path)
+    if modobjpath is None:
+        mo = util.get_object(node.path)
+    else:
+        mo = util.get_object(modobjpath)
     mapper = STATE.trace.register_mapper
-    
+
     attributes = util.get_attributes(mo)
     # print(f"ATTR={attributes}")
     values = []
@@ -1508,8 +1590,8 @@ def put_generic(node):
     keys = []
     if elements is not None:
         for el in elements:
-            index = el[0]
-            key = GENERIC_KEY_PATTERN.format(key=index)
+            key = update_key(node.path, el)
+            key = GENERIC_KEY_PATTERN.format(key=key)
             lpath = node.path + key
             lobj = STATE.trace.create_object(lpath)
             update_by_container(node.path, el, lobj)
@@ -1534,7 +1616,7 @@ def set_display(key, value, obj):
         if hloc is not None:
             key += " @ " + str(hloc)
             obj.set_value('_display', key)
-            (hloc_base, hloc_addr) = map_address(int(hloc,0))
+            (hloc_base, hloc_addr) = map_address(int(hloc, 0))
             obj.set_value('_address', hloc_addr, schema=Address)
     if vstr is not None:
         key += " : " + str(vstr)
@@ -1557,9 +1639,134 @@ def ghidra_trace_put_generic(node):
 
     STATE.require_tx()
     with STATE.client.batch() as b:
-        put_generic(node)
+        put_generic_from_node(node)
+
+
+def init_ttd():
+    # print(f"put_events: {node}")
+    with open_tracked_tx('Init TTDState'):
+        ttd = util.ttd
+        nproc = util.selected_process()
+        path = TTD_PATTERN.format(var="curprocess")+".Lifetime"
+        (values, keys) = create_generic(path)
+        lifetime = util.get_object(path)
+        map = util.get_attributes(lifetime)
+        ttd._first = map["MinPosition"]
+        ttd._last = map["MaxPosition"]
+        ttd._lastmajor = util.pos2split(ttd._last)[0]
+        ttd._lastpos = ttd._first
+        ttd.MAX_STEP = 0xFFFFFFFFFFFFFFFE
+        ghidra_trace_set_snap(util.pos2snap(ttd._first))
+
+
+def put_events():
+    ttd = util.ttd
+    nproc = util.selected_process()
+    path = TTD_PATTERN.format(var="curprocess")+".Events"
+    (values, keys) = create_generic(path)
+    for k in keys:
+        event = util.get_object(path+k)
+        map = util.get_attributes(event)
+        type = util.get_value(map["Type"])
+        pos = map["Position"]
+        (major, minor) = util.pos2split(pos)
+        ttd.events[major] = event
+        ttd.evttypes[major] = type
+        with open_tracked_tx('Populate events'):
+            index = util.pos2snap(pos)
+            STATE.trace.snapshot(DESCRIPTION_PATTERN.format(major=major, type=type), snap=index)
+            if type == "ModuleLoaded" or type == "ModuleUnloaded":
+                mod = map["Module"]
+                mobj = get_module(k, mod)
+                if type == "ModuleLoaded":
+                    mobj.insert(span=Lifespan(index))
+                else:
+                    mobj.remove(span=Lifespan(index))
+            if type == "ThreadCreated" or type == "ThreadTerminated":
+                t = map["Thread"]
+                tobj = get_thread(k, t)
+                if type == "ThreadCreated":
+                    tobj.insert(span=Lifespan(index))
+                else:
+                    tobj.remove(span=Lifespan(index))
+    hooks.on_stop()
+
+
+def ghidra_trace_put_events(node):
+    """
+    Put the event set the Ghidra trace
+    """
+
+    STATE.require_tx()
+    with STATE.client.batch() as b:
+    	put_events()
+ 
+ 
+def put_events_custom(prefix, cmd):
+    result = util.dbg.cmd("{prefix}.{cmd}".format(prefix=prefix, cmd=cmd))
+    if result.startswith("Error"):
+        print(result)
+        return
+    nproc = util.selected_process()
+    mapper = STATE.trace.memory_mapper
+    path = TTD_PATTERN.format(var="cursession")+".CustomEvents"
+    obj = STATE.trace.create_object(path)
+    index = 0
+    addr = size = start = stop = None
+    attrs = {}
+    keys = []
+    for l in result.split('\n'):
+        split = l.split(":")
+        id = split[0].strip()
+        if id == "Address":
+            addr = int(split[1].strip(),16)
+        elif id == "Size":
+            size = int(split[1].strip(),16)
+        elif id == "TimeStart":
+            start = util.mm2snap(int(split[1],16), int(split[2],16))
+        elif id == "TimeEnd":
+            stop = util.mm2snap(int(split[1],16), int(split[2],16))
+        elif " : " in l:
+            attrs[id] = l[l.index(":"):].strip()
+        if addr is not None and size is not None and start is not None and stop is not None:
+            with open_tracked_tx('Populate events'):
+                key = "[{:x}]".format(addr)
+                STATE.trace.snapshot("[{:x}] EventCreated {} ".format(start, key), snap=start)
+                if start > stop:
+                    print(f"ERROR: {start}:{stop}")
+                    continue
+                span=Lifespan(start, stop)
+                rpath = REGION_PATTERN.format(procnum=nproc, start=addr)
+                keys.append(REGION_KEY_PATTERN.format(start=addr))
+                regobj = STATE.trace.create_object(rpath)
+                (start_base, start_addr) = map_address(addr)
+                rng = start_addr.extend(size)
+                regobj.set_value('Range', rng, span=span)
+                regobj.set_value('_range', rng, span=span)
+                regobj.set_value('_display', hex(addr), span=span)
+                regobj.set_value('_cmd', cmd)
+                for (k,v) in attrs.items():
+                    regobj.set_value(k, v, span=span)
+                regobj.insert(span=span)
+                keys.append(key)
+            index += 1
+            addr = size = start = stop = None
+            attrs = {}
+    obj.insert()
+    STATE.trace.proxy_object_path(TTD_PATTERN.format(var="cursession")).retain_values(keys)
+    hooks.on_stop()
 
 
+def ghidra_trace_put_events_custom(prefix, cmd):
+    """
+    Generate events by cmd and put them into the Ghidra trace
+    """
+
+    STATE.require_tx()
+    with STATE.client.batch() as b:
+        put_events_custom(prefix, cmd)
+ 
+ 
 def ghidra_trace_put_all():
     """
     Put everything currently selected into the Ghidra trace
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodeliterator.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodeliterator.py
index c5bf8451e8e..6a90255a5d3 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodeliterator.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodeliterator.py
@@ -1,17 +1,17 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 from ctypes import *
 
@@ -26,6 +26,7 @@
 class ModelIterator(object):
     def __init__(self, iter):
         self._iter = iter
+        self._index = 0
         iter.AddRef()
 
     # ModelIterator
@@ -39,10 +40,17 @@ def GetNext(self, dimensions):
                                byref(indexer), byref(metadata))
         except COMError as ce:
             return None
+        if "ptr=0x0" in str(indexer):
+            next = (self._index, mo.ModelObject(object))
+            self._index += 1
+            return next
+               
         index = mo.ModelObject(indexer)
         ival = index.GetIntrinsicValue()
         if ival is None:
-            return (0, mo.ModelObject(object))
+            next = (self._index, mo.ModelObject(object))
+            self._index += 1
+            return next
         return (ival.value, mo.ModelObject(object))
 
     def Reset(self):
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodelmethod.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodelmethod.py
new file mode 100644
index 00000000000..27e9880dbce
--- /dev/null
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/imodelmethod.py
@@ -0,0 +1,45 @@
+## ###
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+##
+from ctypes import *
+
+from comtypes import COMError
+from comtypes.gen import DbgMod
+from comtypes.hresult import S_OK, S_FALSE
+from pybag.dbgeng import exception
+
+from . import imodelobject as mo
+
+
+class ModelMethod(object):
+    def __init__(self, method):
+        self._method = method
+        method.AddRef()
+
+    # ModelMethod
+
+    def Call(self, object, argcount=0, arguments=None):
+        if argcount == 0:
+            arguments = POINTER(DbgMod.IModelObject)()
+        result = POINTER(DbgMod.IModelObject)()
+        metadata = POINTER(DbgMod.IKeyStore)()
+        try:
+            self._method.Call(byref(object), argcount, byref(arguments),
+                               byref(result), byref(metadata))
+        except COMError as ce:
+            return None
+
+        return mo.ModelObject(result)
+ 
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/irawenumerator.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/irawenumerator.py
index 3e284aec03d..2e6afb40d05 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/irawenumerator.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/dbgmodel/irawenumerator.py
@@ -1,17 +1,17 @@
 ## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
+# IP: GHIDRA
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 ##
 from ctypes import *
 
@@ -35,7 +35,7 @@ def Release(self):
             self._keys = None
         return cnt
 
-    # KeyEnumerator
+    # RawEnumerator
 
     def GetNext(self):
         key = BSTR()
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/hooks.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/hooks.py
index dd01eab5a4b..47b418fa994 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/hooks.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/hooks.py
@@ -57,12 +57,12 @@ def __init__(self):
         self.visited = set()
         self.waiting = False
 
-    def record(self, description=None):
+    def record(self, description=None, snap=None):
         # print("RECORDING")
         first = self.first
         self.first = False
         if description is not None:
-            commands.STATE.trace.snapshot(description)
+            commands.STATE.trace.snapshot(description, snap=snap)
         if first:
             if util.is_kernel():
                 commands.create_generic("Sessions")
@@ -71,6 +71,9 @@ def record(self, description=None):
             commands.put_processes()
             commands.put_environment()
             commands.put_threads()
+            if util.is_trace():
+                commands.init_ttd()
+                #commands.put_events()
         if self.threads:
             commands.put_threads()
             self.threads = False
@@ -106,10 +109,10 @@ def record_continued(self):
         commands.put_processes(running=True)
         commands.put_threads(running=True)
 
-    def record_exited(self, exit_code, description=None):
+    def record_exited(self, exit_code, description=None, snap=None):
         # print("RECORD_EXITED")
         if description is not None:
-            commands.STATE.trace.snapshot(description)
+            commands.STATE.trace.snapshot(description, snap=snap)
         proc = util.selected_process()
         ipath = commands.PROCESS_PATTERN.format(procnum=proc)
         procobj = commands.STATE.trace.proxy_object_path(ipath)
@@ -381,13 +384,37 @@ def on_stop(*args):
         return
     state = PROC_STATE[proc]
     state.visited.clear()
+    snap = update_position()
     with commands.STATE.client.batch():
         with trace.open_tx("Stopped"):
-            state.record("Stopped")
+            state.record("Stopped", snap)
             commands.put_event_thread()
             commands.activate()
 
 
+def update_position():
+    """Update the position"""
+    cursor = util.get_cursor()
+    if cursor is None:
+        return None
+    pos = cursor.get_position()
+    lpos = util.get_last_position()
+    rng = range(pos.major, lpos.major)
+    if pos.major > lpos.major:
+        rng = range(lpos.major, pos.major)
+    for i in rng:
+        type =  util.get_event_type(i)
+        if type == "modload" or type == "modunload":
+            on_modules_changed()
+            break
+    for i in rng:
+        type =  util.get_event_type(i)
+        if type == "threadcreated" or type == "threadterm":
+            on_threads_changed()
+    util.set_last_position(pos)
+    return util.pos2snap(pos)
+
+        
 def on_exited(proc):
     # print("ON EXITED")
     if proc not in PROC_STATE:
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/methods.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/methods.py
index b98cfa1c930..efcbdd2a71b 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/methods.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/methods.py
@@ -26,7 +26,6 @@
 
 from . import util, commands
 
-
 REGISTRY = MethodRegistry(ThreadPoolExecutor(
     max_workers=1, thread_name_prefix='MethodRegistry'))
 
@@ -214,7 +213,7 @@ def evaluate(
 
 @REGISTRY.method(action='refresh', display="Refresh", condition=util.dbg.use_generics)
 def refresh_generic(node: sch.OBJECT):
-    """List processes on pydbg's host system."""
+    """List the children for a generic node."""
     with commands.open_tracked_tx('Refresh Generic'):
         commands.ghidra_trace_put_generic(node)
 
@@ -294,6 +293,15 @@ def refresh_modules(node: sch.Schema('ModuleContainer')):
         commands.ghidra_trace_put_modules()
 
 
+@REGISTRY.method(action='refresh', display='Refresh Events')
+def refresh_events(node: sch.Schema('State')):
+    """
+    Refresh the events list for a trace.
+    """
+    with commands.open_tracked_tx('Refresh Events'):
+        commands.ghidra_trace_put_events(node)
+
+
 @REGISTRY.method(action='activate')
 def activate_process(process: sch.Schema('Process')):
     """Switch to the process."""
@@ -377,7 +385,7 @@ def launch_loader(
     """
     command = file
     if args != None:
-        command += " "+args
+        command += " " + args
     commands.ghidra_trace_create(command=file, start_trace=False)
 
 
@@ -393,7 +401,7 @@ def launch(
     """
     command = file
     if args != None:
-        command += " "+args
+        command += " " + args
     commands.ghidra_trace_create(
         command, initial_break=initial_break, timeout=timeout, start_trace=False)
 
@@ -411,6 +419,14 @@ def go(process: sch.Schema('Process')):
     util.dbg.run_async(lambda: dbg().go())
 
 
+@REGISTRY.method(action='step_ext', display='Go (backwards)', icon='icon.debugger.resume.back', condition=util.dbg.IS_TRACE)
+@util.dbg.eng_thread
+def go_back(thread: sch.Schema('Process')):
+    """Continue execution of the process backwards."""
+    dbg().cmd("g-")
+    dbg().wait()
+
+
 @REGISTRY.method
 def interrupt(process: sch.Schema('Process')):
     """Interrupt the execution of the debugged program."""
@@ -433,6 +449,22 @@ def step_over(thread: sch.Schema('Thread'), n: ParamDesc(int, display='N')=1):
     util.dbg.run_async(lambda: dbg().stepo(n))
 
 
+@REGISTRY.method(action='step_ext', display='Step Into (backwards)', icon='icon.debugger.step.back.into', condition=util.dbg.IS_TRACE)
+@util.dbg.eng_thread
+def step_back_into(thread: sch.Schema('Thread'), n: ParamDesc(int, display='N')=1):
+    """Step one instruction backward exactly."""
+    dbg().cmd("t- " + str(n))
+    dbg().wait()
+
+
+@REGISTRY.method(action='step_ext', display='Step Over (backwards)', icon='icon.debugger.step.back.over', condition=util.dbg.IS_TRACE)
+@util.dbg.eng_thread
+def step_back_over(thread: sch.Schema('Thread'), n: ParamDesc(int, display='N')=1):
+    """Step one instruction backward, but proceed through subroutine calls."""
+    dbg().cmd("p- " + str(n))
+    dbg().wait()
+
+
 @REGISTRY.method(action='step_out')
 def step_out(thread: sch.Schema('Thread')):
     """Execute until the current stack frame returns."""
@@ -448,6 +480,14 @@ def step_to(thread: sch.Schema('Thread'), address: Address, max=None):
     util.dbg.run_async(lambda: dbg().stepto(address.offset, max))
 
 
+@REGISTRY.method(action='go_to_time', display='Go To (event)', condition=util.dbg.IS_TRACE)
+@util.dbg.eng_thread
+def go_to_time(node: sch.Schema('State'), evt: ParamDesc(str, display='Event')):
+    """Reset the trace to a specific time."""
+    dbg().cmd("!tt " + evt)
+    dbg().wait()
+
+
 @REGISTRY.method(action='break_sw_execute')
 @util.dbg.eng_thread
 def break_address(process: sch.Schema('Process'), address: Address):
@@ -557,7 +597,7 @@ def read_mem(process: sch.Schema('Process'), range: AddressRange):
             offset_start, offset_start + range.length() - 1, pages=True, display_result=False)
         if result['count'] == 0:
             commands.putmem_state(
-                offset_start, offset_start+range.length() - 1, 'error')
+                offset_start, offset_start + range.length() - 1, 'error')
 
 
 @REGISTRY.method
@@ -578,5 +618,14 @@ def write_reg(frame: sch.Schema('StackFrame'), name: str, value: bytes):
     dbg().reg._set_register(name, value)
 
 
+@REGISTRY.method(display='Refresh Events (custom)', condition=util.dbg.IS_TRACE)
+@util.dbg.eng_thread
+def refresh_events_custom(node: sch.Schema('State'), cmd: ParamDesc(str, display='Cmd'), 
+                          prefix: ParamDesc(str, display='Prefix')="dx -r2 @$cursession.TTD"):
+    """Parse TTD objects generated from a LINQ command."""
+    with commands.open_tracked_tx('Put Events (custom)'):
+        commands.ghidra_trace_put_events_custom(prefix, cmd)
+
+
 def dbg():
     return util.dbg._base
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/schema.xml b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/schema.xml
index 872d38b53dd..d4b7162e983 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/schema.xml
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/schema.xml
@@ -2,7 +2,7 @@
 	<schema name="DbgRoot" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
 		<attribute name="Sessions" schema="SessionContainer" required="yes" fixed="yes" />
 		<attribute name="Settings" schema="ANY" />
-		<attribute name="State" schema="ANY" />
+		<attribute name="State" schema="State" />
 		<attribute-alias from="_state" to="State" />
 		<attribute name="Utility" schema="ANY" />
 		<attribute name="_display" schema="STRING" hidden="yes" />
@@ -28,6 +28,11 @@
 		<attribute name="_order" schema="INT" hidden="yes" />
 		<attribute schema="ANY"/>
 	</schema>
+	<schema name="State" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
+		<element schema="VOID" />
+		<attribute name="_order" schema="INT" hidden="yes" />
+		<attribute schema="ANY"/>
+	</schema>
 	<schema name="Selectable" elementResync="NEVER" attributeResync="NEVER">
 		<element schema="OBJECT" />
 		<attribute name="_order" schema="INT" hidden="yes" />
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/util.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/util.py
index 86d92bdb543..94a2271c9f6 100644
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/util.py
+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidradbg/util.py
@@ -38,9 +38,9 @@
 from pybag.dbgeng.idebugclient import DebugClient
 
 from ghidradbg.dbgmodel.ihostdatamodelaccess import HostDataModelAccess
+from ghidradbg.dbgmodel.imodelmethod import ModelMethod
 from _winapi import STILL_ACTIVE
 
-
 DbgVersion = namedtuple('DbgVersion', ['full', 'name', 'dotted', 'arch'])
 
 
@@ -81,6 +81,7 @@ def IDebugInputCallbacks_EndInput(self):
 
 
 class _Worker(threading.Thread):
+
     def __init__(self, new_base, work_queue, dispatch):
         super().__init__(name='DbgWorker', daemon=True)
         self.new_base = new_base
@@ -109,6 +110,7 @@ def run(self):
 # https://github.com/python/cpython/blob/main/Lib/concurrent/futures/thread.py
 # accessed 9 Jan 2024
 class _WorkItem(object):
+
     def __init__(self, future, fn, args, kwargs):
         self.future = future
         self.fn = fn
@@ -131,6 +133,7 @@ class DebuggeeRunningException(BaseException):
 
 
 class DbgExecutor(object):
+
     def __init__(self, ghidra_dbg):
         self._ghidra_dbg = ghidra_dbg
         self._work_queue = queue.SimpleQueue()
@@ -139,12 +142,12 @@ def __init__(self, ghidra_dbg):
         self._thread.start()
         self._executing = False
 
-    def submit(self, fn, /, *args, **kwargs):
+    def submit(self, fn, / , *args, **kwargs):
         f = self._submit_no_exit(fn, *args, **kwargs)
         self._ghidra_dbg.exit_dispatch()
         return f
 
-    def _submit_no_exit(self, fn, /, *args, **kwargs):
+    def _submit_no_exit(self, fn, / , *args, **kwargs):
         f = Future()
         if self._executing and self._ghidra_dbg.IS_REMOTE == False:
             f.set_exception(DebuggeeRunningException("Debuggee is Running"))
@@ -199,6 +202,7 @@ class AllDbg(pydbg.DebuggerBase):
 
 
 class GhidraDbg(object):
+
     def __init__(self):
         self._queue = DbgExecutor(self)
         self._thread = self._queue._thread
@@ -239,10 +243,11 @@ def __init__(self):
                      'load_dump'
                      ]:
             setattr(self, name, self.eng_thread(getattr(base, name)))
-            self.IS_KERNEL = False
-            self.IS_EXDI = False
-            self.IS_REMOTE = os.getenv('OPT_CONNECT_STRING') is not None
-
+        self.IS_KERNEL = False
+        self.IS_EXDI = False
+        self.IS_REMOTE = os.getenv('OPT_CONNECT_STRING') is not None
+        self.IS_TRACE = os.getenv('USE_TTD') == "true"
+            
     def _new_base(self):
         remote = os.getenv('OPT_CONNECT_STRING')
         if remote is not None:
@@ -252,14 +257,12 @@ def _new_base(self):
         else:
             self._protected_base = AllDbg()
             
-            
     def _generate_client(self, original):
         cli = POINTER(DbgEng.IDebugClient)()
         cliptr = POINTER(POINTER(DbgEng.IDebugClient))(cli)
         hr = original.CreateClient(cliptr)
         exception.check_err(hr)
         return DebugClient(client=cli)
-           
 
     @property
     def _base(self):
@@ -289,12 +292,14 @@ def check_thread(func):
         For methods inside of GhidraDbg, ensure it runs on the dbgeng
         thread
         '''
+
         @functools.wraps(func)
         def _func(self, *args, **kwargs):
             if threading.current_thread() is self._thread:
                 return func(self, *args, **kwargs)
             else:
                 return self.run(func, self, *args, **kwargs)
+
         return _func
 
     def eng_thread(self, func):
@@ -302,12 +307,14 @@ def eng_thread(self, func):
         For methods and functions outside of GhidraDbg, ensure it
         runs on this GhidraDbg's dbgeng thread
         '''
+
         @functools.wraps(func)
         def _func(*args, **kwargs):
             if threading.current_thread() is self._thread:
                 return func(*args, **kwargs)
             else:
                 return self.run(func, *args, **kwargs)
+
         return _func
 
     def _ces_exec_status(self, argument):
@@ -325,6 +332,7 @@ def _install_stdin(self):
     def _dispatch_events(self, timeout=DbgEng.WAIT_INFINITE):
         # NB: pybag's impl doesn't heed standalone
         self._protected_base._client.DispatchCallbacks(timeout)
+
     dispatch_events = check_thread(_dispatch_events)
 
     # no check_thread. Must allow reentry
@@ -393,7 +401,23 @@ def pid(self):
             return None
 
 
+class TTDState(object):
+
+    def __init__(self):
+        self._cursor = None
+        self._first = None
+        self._last = None
+        self._lastmajor = None
+        self._lastpos = None
+        self.breakpoints = []
+        self.events = {}
+        self.evttypes = {}
+        self.starts = {}
+        self.stops = {}
+
+
 dbg = GhidraDbg()
+ttd = TTDState()
 
 
 @dbg.eng_thread
@@ -750,18 +774,12 @@ def get_proc_id(pid):
 
 
 def full_mem():
-    sizeptr = 64; #int(gdb.parse_and_eval('sizeof(void*)')) * 8
-    infoLow = DbgEng._MEMORY_BASIC_INFORMATION64()
-    infoLow.BaseAddress = 0
-    infoLow.RegionSize = (1 << (sizeptr-1))
-    infoLow.Protect = 0xFFF
-    infoLow.Name = "UMEM"
-    infoHigh = DbgEng._MEMORY_BASIC_INFORMATION64()
-    infoHigh.BaseAddress = 1 << (sizeptr-1)
-    infoHigh.RegionSize = (1 << (sizeptr-1))
-    infoHigh.Protect = 0xFFF
-    infoHigh.Name = "KMEM"
-    return [ infoLow, infoHigh ]
+    info = DbgEng._MEMORY_BASIC_INFORMATION64()
+    info.BaseAddress = 0
+    info.RegionSize = (1 << 64) - 1
+    info.Protect = 0xFFF
+    info.Name = "full memory"
+    return [ info ]
 
 
 @dbg.eng_thread
@@ -780,6 +798,16 @@ def get_thread_id(tid):
     return None
 
 
+@dbg.eng_thread
+def open_trace_or_dump(filename):
+    """Open a trace or dump file"""
+    _cli = dbg._base._client._cli
+    if isinstance(filename, str):
+        filename = filename.encode()
+    hr = _cli.OpenDumpFile(filename)
+    exception.check_err(hr)
+
+
 def split_path(pathString):
     list = []
     segs = pathString.split(".")
@@ -800,6 +828,11 @@ def IHostDataModelAccess():
         dbg._base._client._cli.QueryInterface(interface=DbgMod.IHostDataModelAccess))
 
 
+def IModelMethod(method_ptr):
+    return ModelMethod(
+        method_ptr.GetIntrinsicValue().value.QueryInterface(interface=DbgMod.IModelMethod))
+
+
 @dbg.eng_thread
 def get_object(relpath):
     """Get the list of all threads"""
@@ -810,12 +843,27 @@ def get_object(relpath):
     root = mgr.GetRootNamespace()
     pathstr = "Debugger"
     if relpath != '':
-        pathstr += "."+relpath
+        pathstr += "." + relpath
     path = split_path(pathstr)
     # print(f"PATH: {pathstr}")
     return root.GetOffspring(path)
 
 
+@dbg.eng_thread
+def get_method(context_path, method_name):
+    """Get the list of all threads"""
+    obj = get_object(context_path)
+    keys = obj.EnumerateKeys()
+    (k, v) = keys.GetNext()
+    while k is not None:
+        if k.value == method_name:
+            break
+        (k, v) = keys.GetNext()
+    if k is None:
+        return None
+    return IModelMethod(v)
+
+
 @dbg.eng_thread
 def get_attributes(obj):
     """Get the list of attributes"""
@@ -826,7 +874,7 @@ def get_attributes(obj):
 
 @dbg.eng_thread
 def get_elements(obj):
-    """Get the list of all threads"""
+    """Get the list of elements"""
     if obj is None:
         return None
     return obj.GetElements()
@@ -834,7 +882,7 @@ def get_elements(obj):
 
 @dbg.eng_thread
 def get_kind(obj):
-    """Get the list of all threads"""
+    """Get the kind"""
     if obj is None:
         return None
     kind = obj.GetKind()
@@ -845,7 +893,7 @@ def get_kind(obj):
 
 @dbg.eng_thread
 def get_type(obj):
-    """Get the list of all threads"""
+    """Get the type"""
     if obj is None:
         return None
     return obj.GetTypeKind()
@@ -853,7 +901,7 @@ def get_type(obj):
 
 @dbg.eng_thread
 def get_value(obj):
-    """Get the list of all threads"""
+    """Get the value"""
     if obj is None:
         return None
     return obj.GetValue()
@@ -861,7 +909,7 @@ def get_value(obj):
 
 @dbg.eng_thread
 def get_intrinsic_value(obj):
-    """Get the list of all threads"""
+    """Get the intrinsic value"""
     if obj is None:
         return None
     return obj.GetIntrinsicValue()
@@ -869,7 +917,7 @@ def get_intrinsic_value(obj):
 
 @dbg.eng_thread
 def get_target_info(obj):
-    """Get the list of all threads"""
+    """Get the target info"""
     if obj is None:
         return None
     return obj.GetTargetInfo()
@@ -877,7 +925,7 @@ def get_target_info(obj):
 
 @dbg.eng_thread
 def get_type_info(obj):
-    """Get the list of all threads"""
+    """Get the type info"""
     if obj is None:
         return None
     return obj.GetTypeInfo()
@@ -885,7 +933,7 @@ def get_type_info(obj):
 
 @dbg.eng_thread
 def get_name(obj):
-    """Get the list of all threads"""
+    """Get the name"""
     if obj is None:
         return None
     return obj.GetName().value
@@ -893,7 +941,7 @@ def get_name(obj):
 
 @dbg.eng_thread
 def to_display_string(obj):
-    """Get the list of all threads"""
+    """Get the display string"""
     if obj is None:
         return None
     return obj.ToDisplayString()
@@ -901,7 +949,7 @@ def to_display_string(obj):
 
 @dbg.eng_thread
 def get_location(obj):
-    """Get the list of all threads"""
+    """Get the location"""
     if obj is None:
         return None
     try:
@@ -925,6 +973,45 @@ def get_convenience_variable(id):
     return val
 
 
+def get_cursor():
+    return ttd._cursor
+
+
+def get_last_position():
+    return ttd._lastpos
+
+
+def set_last_position(pos):
+    ttd._lastpos = pos
+
+
+def get_event_type(rng):
+     if ttd.evttypes.__contains__(rng):
+         return ttd.evttypes[rng]
+
+
+def pos2snap(pos):
+    pmap = get_attributes(pos)
+    major = get_value(pmap["Sequence"])
+    minor = get_value(pmap["Steps"])
+    return mm2snap(major, minor)
+
+
+def mm2snap(major, minor):
+    index = int(major)
+    if index < 0 or index >= ttd.MAX_STEP:
+        return int(ttd._lastmajor) # << 32
+    snap = index # << 32 + int(minor)
+    return snap
+
+
+def pos2split(pos):
+    pmap = get_attributes(pos)
+    major = get_value(pmap["Sequence"])
+    minor = get_value(pmap["Steps"])
+    return (major, minor)
+
+
 def set_convenience_variable(id, value):
     conv_map[id] = value
     
@@ -952,4 +1039,11 @@ def set_remote(value):
 def is_remote():
     return dbg.IS_REMOTE
     
+    
+def set_trace(value):
+    dbg.IS_TRACE = value
+    
+    
+def is_trace():
+    return dbg.IS_TRACE
 		
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/__init__.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/__init__.py
deleted file mode 100644
index 6c5fc1de713..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/__init__.py
+++ /dev/null
@@ -1,19 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-
-# NOTE: libraries must precede EVERYTHING, esp pybag and DbgMod
-
-from . import libraries, util, commands, methods, hooks
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/arch.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/arch.py
deleted file mode 100644
index 975e19c6ae7..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/arch.py
+++ /dev/null
@@ -1,212 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-from ghidratrace.client import Address, RegVal
-
-from pybag import pydbg
-
-from . import util
-
-language_map = {
-    'ARM': ['AARCH64:BE:64:v8A', 'AARCH64:LE:64:AppleSilicon', 'AARCH64:LE:64:v8A', 'ARM:BE:64:v8', 'ARM:LE:64:v8'],
-    'Itanium': [],
-    'x86': ['x86:LE:32:default'],
-    'x86_64': ['x86:LE:64:default'],
-    'EFI': ['x86:LE:64:default'],
-}
-
-data64_compiler_map = {
-    None: 'pointer64',
-}
-
-x86_compiler_map = {
-    'windows': 'windows',
-    'Cygwin': 'windows',
-}
-
-arm_compiler_map = {
-    'windows': 'windows',
-}
-
-compiler_map = {
-    'DATA:BE:64:default': data64_compiler_map,
-    'DATA:LE:64:default': data64_compiler_map,
-    'x86:LE:32:default': x86_compiler_map,
-    'x86:LE:64:default': x86_compiler_map,
-    'AARCH64:BE:64:v8A': arm_compiler_map,
-    'AARCH64:LE:64:AppleSilicon': arm_compiler_map,
-    'AARCH64:LE:64:v8A': arm_compiler_map,
-    'ARM:BE:64:v8': arm_compiler_map,
-    'ARM:LE:64:v8': arm_compiler_map,
-}
-
-
-def get_arch():
-    return "x86_64"
-
-
-def get_endian():
-    return 'little'
-
-
-def get_osabi():
-    return "windows"
-
-
-def compute_ghidra_language():
-    # First, check if the parameter is set
-    lang = util.get_convenience_variable('ghidra-language')
-    if lang != 'auto':
-        return lang
-
-    # Get the list of possible languages for the arch. We'll need to sift
-    # through them by endian and probably prefer default/simpler variants. The
-    # heuristic for "simpler" will be 'default' then shortest variant id.
-    arch = get_arch()
-    endian = get_endian()
-    lebe = ':BE:' if endian == 'big' else ':LE:'
-    if not arch in language_map:
-        return 'DATA' + lebe + '64:default'
-    langs = language_map[arch]
-    matched_endian = sorted(
-        (l for l in langs if lebe in l),
-        key=lambda l: 0 if l.endswith(':default') else len(l)
-    )
-    if len(matched_endian) > 0:
-        return matched_endian[0]
-    # NOTE: I'm disinclined to fall back to a language match with wrong endian.
-    return 'DATA' + lebe + '64:default'
-
-
-def compute_ghidra_compiler(lang):
-    # First, check if the parameter is set
-    comp = util.get_convenience_variable('ghidra-compiler')
-    if comp != 'auto':
-        return comp
-
-    # Check if the selected lang has specific compiler recommendations
-    if not lang in compiler_map:
-        return 'default'
-    comp_map = compiler_map[lang]
-    osabi = get_osabi()
-    if osabi in comp_map:
-        return comp_map[osabi]
-    if None in comp_map:
-        return comp_map[None]
-    return 'default'
-
-
-def compute_ghidra_lcsp():
-    lang = compute_ghidra_language()
-    comp = compute_ghidra_compiler(lang)
-    return lang, comp
-
-
-class DefaultMemoryMapper(object):
-
-    def __init__(self, defaultSpace):
-        self.defaultSpace = defaultSpace
-
-    def map(self, proc: int, offset: int):
-        space = self.defaultSpace
-        return self.defaultSpace, Address(space, offset)
-
-    def map_back(self, proc: int, address: Address) -> int:
-        if address.space == self.defaultSpace:
-            return address.offset
-        raise ValueError(f"Address {address} is not in process {proc.GetProcessID()}")
-
-
-DEFAULT_MEMORY_MAPPER = DefaultMemoryMapper('ram')
-
-memory_mappers = {}
-
-
-def compute_memory_mapper(lang):
-    if not lang in memory_mappers:
-        return DEFAULT_MEMORY_MAPPER
-    return memory_mappers[lang]
-
-
-class DefaultRegisterMapper(object):
-
-    def __init__(self, byte_order):
-        if not byte_order in ['big', 'little']:
-            raise ValueError("Invalid byte_order: {}".format(byte_order))
-        self.byte_order = byte_order
-        self.union_winners = {}
-
-    def map_name(self, proc, name):
-        return name
-
-
-    def map_value(self, proc, name, value):
-        try:
-            ### TODO: this seems half-baked
-            av = value.to_bytes(8, "big")
-        except Exception:
-            raise ValueError("Cannot convert {}'s value: '{}', type: '{}'"
-                                .format(name, value, type(value)))
-        return RegVal(self.map_name(proc, name), av)
-
-    def map_name_back(self, proc, name):
-        return name
-
-    def map_value_back(self, proc, name, value):
-        return RegVal(self.map_name_back(proc, name), value)
-
-
-class Intel_x86_64_RegisterMapper(DefaultRegisterMapper):
-
-    def __init__(self):
-        super().__init__('little')
-
-    def map_name(self, proc, name):
-        if name is None:
-            return 'UNKNOWN'
-        if name == 'efl':
-            return 'rflags'
-        if name.startswith('zmm'):
-            # Ghidra only goes up to ymm, right now
-            return 'ymm' + name[3:]
-        return super().map_name(proc, name)
-
-    def map_value(self, proc, name, value):
-        rv = super().map_value(proc, name, value)
-        if rv.name.startswith('ymm') and len(rv.value) > 32:
-            return RegVal(rv.name, rv.value[-32:])
-        return rv
-
-    def map_name_back(self, proc, name):
-        if name == 'rflags':
-            return 'eflags'
-
-
-DEFAULT_BE_REGISTER_MAPPER = DefaultRegisterMapper('big')
-DEFAULT_LE_REGISTER_MAPPER = DefaultRegisterMapper('little')
-
-register_mappers = {
-    'x86:LE:64:default': Intel_x86_64_RegisterMapper()
-}
-
-
-def compute_register_mapper(lang):
-    if not lang in register_mappers:
-        if ':BE:' in lang:
-            return DEFAULT_BE_REGISTER_MAPPER
-        if ':LE:' in lang:
-            return DEFAULT_LE_REGISTER_MAPPER
-    return register_mappers[lang]
-    
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/commands.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/commands.py
deleted file mode 100644
index edee2b890b3..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/commands.py
+++ /dev/null
@@ -1,1387 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-from contextlib import contextmanager
-import inspect
-import os.path
-import socket
-import time
-import sys
-import re
-
-from ghidratrace import sch
-from ghidratrace.client import Client, Address, AddressRange, Lifespan, TraceObject
-
-#from pybag import pydbg, userdbg, kerneldbg
-#from pybag.dbgeng import core as DbgEng
-#from pybag.dbgeng import exception
-from pyttd import pyTTD
-
-from . import util, arch, methods, hooks
-import code
-
-PAGE_SIZE = 4096
-
-AVAILABLES_PATH = 'Available'
-AVAILABLE_KEY_PATTERN = '[{pid}]'
-AVAILABLE_PATTERN = AVAILABLES_PATH + AVAILABLE_KEY_PATTERN
-PROCESSES_PATH = 'Processes'
-PROCESS_KEY_PATTERN = '[{procnum}]'
-PROCESS_PATTERN = PROCESSES_PATH + PROCESS_KEY_PATTERN
-PROC_BREAKS_PATTERN = PROCESS_PATTERN + '.Breakpoints'
-PROC_BREAK_KEY_PATTERN = '[{breaknum}]'
-PROC_BREAK_PATTERN = PROC_BREAKS_PATTERN + PROC_BREAK_KEY_PATTERN
-ENV_PATTERN = PROCESS_PATTERN + '.Environment'
-THREADS_PATTERN = PROCESS_PATTERN + '.Threads'
-THREAD_KEY_PATTERN = '[{tnum}]'
-THREAD_PATTERN = THREADS_PATTERN + THREAD_KEY_PATTERN
-STACK_PATTERN = THREAD_PATTERN + '.Stack'
-FRAME_KEY_PATTERN = '[{level}]'
-FRAME_PATTERN = STACK_PATTERN + FRAME_KEY_PATTERN
-REGS_PATTERN = THREAD_PATTERN + '.Registers'
-MEMORY_PATTERN = PROCESS_PATTERN + '.Memory'
-REGION_KEY_PATTERN = '[{start:08x}]'
-REGION_PATTERN = MEMORY_PATTERN + REGION_KEY_PATTERN
-MODULES_PATTERN = PROCESS_PATTERN + '.Modules'
-MODULE_KEY_PATTERN = '[{modpath}]'
-MODULE_PATTERN = MODULES_PATTERN + MODULE_KEY_PATTERN
-SECTIONS_ADD_PATTERN = '.Sections'
-SECTION_KEY_PATTERN = '[{secname}]'
-SECTION_ADD_PATTERN = SECTIONS_ADD_PATTERN + SECTION_KEY_PATTERN
-DESCRIPTION_PATTERN = '{major}:{minor} {type}'
-
-# TODO: Symbols
-
-
-class ErrorWithCode(Exception):
-    def __init__(self, code):
-        self.code = code
-
-    def __str__(self)->str:
-        return repr(self.code)
-
-
-class State(object):
-
-    def __init__(self):
-        self.reset_client()
-
-    def require_client(self):
-        if self.client is None:
-            raise RuntimeError("Not connected")
-        return self.client
-
-    def require_no_client(self):
-        if self.client != None:
-            raise RuntimeError("Already connected")
-
-    def reset_client(self):
-        self.client = None
-        self.reset_trace()
-
-    def require_trace(self):
-        if self.trace is None:
-            raise RuntimeError("No trace active")
-        return self.trace
-
-    def require_no_trace(self):
-        if self.trace != None:
-            raise RuntimeError("Trace already started")
-
-    def reset_trace(self):
-        self.trace = None
-        util.set_convenience_variable('_ghidra_tracing', "false")
-        self.reset_tx()
-
-    def require_tx(self):
-        if self.tx is None:
-            raise RuntimeError("No transaction")
-        return self.tx
-
-    def require_no_tx(self):
-        if self.tx != None:
-            raise RuntimeError("Transaction already started")
-
-    def reset_tx(self):
-        self.tx = None
-
-
-STATE = State()
-
-
-def ghidra_trace_connect(address=None):
-    """
-    Connect Python to Ghidra for tracing
-
-    Address must be of the form 'host:port'
-    """
-
-    STATE.require_no_client()
-    if address is None:
-        raise RuntimeError(
-            "'ghidra_trace_connect': missing required argument 'address'")
-
-    parts = address.split(':')
-    if len(parts) != 2:
-        raise RuntimeError("address must be in the form 'host:port'")
-    host, port = parts
-    try:
-        c = socket.socket()
-        c.connect((host, int(port)))
-        # TODO: Can we get version info from the DLL?
-        STATE.client = Client(c, "dbgeng.dll", methods.REGISTRY)
-        print(f"Connected to {STATE.client.description} at {address}")
-    except ValueError:
-        raise RuntimeError("port must be numeric")
-
-
-def ghidra_trace_listen(address='0.0.0.0:0'):
-    """
-    Listen for Ghidra to connect for tracing
-
-    Takes an optional address for the host and port on which to listen. Either
-    the form 'host:port' or just 'port'. If omitted, it will bind to an
-    ephemeral port on all interfaces. If only the port is given, it will bind to
-    that port on all interfaces. This command will block until the connection is
-    established.
-    """
-
-    STATE.require_no_client()
-    parts = address.split(':')
-    if len(parts) == 1:
-        host, port = '0.0.0.0', parts[0]
-    elif len(parts) == 2:
-        host, port = parts
-    else:
-        raise RuntimeError("address must be 'port' or 'host:port'")
-
-    try:
-        s = socket.socket()
-        s.bind((host, int(port)))
-        host, port = s.getsockname()
-        s.listen(1)
-        print("Listening at {}:{}...\n".format(host, port))
-        c, (chost, cport) = s.accept()
-        s.close()
-        print("Connection from {}:{}\n".format(chost, cport))
-        STATE.client = Client(c, "dbgeng.dll", methods.REGISTRY)
-    except ValueError:
-        raise RuntimeError("port must be numeric")
-
-
-def ghidra_trace_disconnect():
-    """Disconnect Python from Ghidra for tracing"""
-
-    STATE.require_client().close()
-    STATE.reset_client()
-
-
-def compute_name(progname=None):
-    if progname is None:
-        try:
-            buffer = util.GetCurrentProcessExecutableName()
-            progname = buffer.decode('utf-8')
-        except Exception:
-            return 'pydbg/noname'
-    return 'pydbg/' + re.split(r'/|\\', progname)[-1]
-
-
-def start_trace(name):
-    language, compiler = arch.compute_ghidra_lcsp()
-    STATE.trace = STATE.client.create_trace(name, language, compiler)
-    # TODO: Is adding an attribute like this recommended in Python?
-    STATE.trace.memory_mapper = arch.compute_memory_mapper(language)
-    STATE.trace.register_mapper = arch.compute_register_mapper(language)
-
-    parent = os.path.dirname(inspect.getfile(inspect.currentframe()))
-    schema_fn = os.path.join(parent, 'schema.xml')
-    with open(schema_fn, 'r') as schema_file:
-        schema_xml = schema_file.read()
-    with STATE.trace.open_tx("Create Root Object"):
-        root = STATE.trace.create_root_object(schema_xml, 'TTDSession')
-        root.set_value('_display', 'pyTTD ' + util.DBG_VERSION.full)
-    util.set_convenience_variable('_ghidra_tracing', "true")
-
-
-def ghidra_trace_start(name=None):
-    """Start a Trace in Ghidra"""
-
-    STATE.require_client()
-    name = compute_name(name)
-    STATE.require_no_trace()
-    start_trace(name)
-
-
-def ghidra_trace_stop():
-    """Stop the Trace in Ghidra"""
-
-    STATE.require_trace().close()
-    STATE.reset_trace()
-
-
-def ghidra_trace_restart(name=None):
-    """Restart or start the Trace in Ghidra"""
-
-    STATE.require_client()
-    if STATE.trace != None:
-        STATE.trace.close()
-        STATE.reset_trace()
-    name = compute_name(name)
-    start_trace(name)
-
-
-def ghidra_trace_create(command=None, initial_break=True, timeout=None, start_trace=True):
-    """
-    Create a session.
-    """
-
-    eng = pyTTD.ReplayEngine()
-    util.eng = eng
-    if command != None:
-        eng.initialize(command)
-        util.first = eng.get_first_position()
-        util.last = eng.get_last_position()
-        print(f"Trace from {util.first} to {util.last}")
-        cursor = eng.new_cursor()
-        cursor.set_position(util.first)
-        util.lastpos = util.first
-        util.base = cursor
-    if start_trace:
-        print(f"calling start with {command}")
-        ghidra_trace_start(command)
-        print(f"started")
-    events = sorted(
-        list((x, "modload") for x in eng.get_module_loaded_event_list())
-        + list((x, "modunload") for x in eng.get_module_unloaded_event_list())
-        + list((x, "threadcreated")
-               for x in eng.get_thread_created_event_list())
-        + list((x, "threadterm")
-               for x in eng.get_thread_terminated_event_list()),
-        key=lambda event: event[0].position
-    )
-
-    keys = []
-    radix = util.get_convenience_variable('output-radix')
-    if radix == 'auto':
-        radix = 16
-    nproc = 0
-
-    for event, evtype in events:
-        pos = event.position
-        util.events[pos.major] = event
-        util.evttypes[pos.major] = evtype
-        with open_tracked_tx('Populate events'):
-            index = util.pos2snap(pos)
-            STATE.trace.snapshot(DESCRIPTION_PATTERN.format(
-                major=pos.major, minor=pos.minor, type=evtype), snap=index)
-        if evtype == "modload":
-            with open_tracked_tx(evtype):
-                id = event.info.base_addr
-                path = event.info.path
-                size = event.info.image_size
-                mobj = get_module(keys, nproc, path, id, size)
-                util.starts[id] = index
-                mobj.insert(span=Lifespan(index))
-            print(f"[{event.position.major:x}:{event.position.minor:x}]", end=" ")
-            print(f"Module {event.info.path} loaded")
-        elif evtype == "modunload":
-            with open_tracked_tx(evtype):
-                id = event.info.base_addr
-                path = event.info.path
-                size = event.info.image_size
-                mobj = get_module(keys, nproc, path, id, size)
-                util.stops[id] = index
-                mobj.remove(span=Lifespan(index))
-            #print(f"[{event.position.major:x}:{event.position.minor:x}]", end=" ")
-            #print(f"Module {event.info.path} unloaded")
-        elif evtype == "threadcreated":
-            with open_tracked_tx(evtype):
-                id = event.info.threadid
-                tobj = get_thread(keys, radix, nproc, id)
-                util.starts[id] = index
-                tobj.insert(span=Lifespan(index))
-            print(f"[{event.position.major:x}:{event.position.minor:x}]", end=" ")
-            print(f"Thread {event.info.threadid:x} created")
-        elif evtype == "threadterm":
-            with open_tracked_tx(evtype):
-                id = event.info.threadid
-                tobj = get_thread(keys, radix, 0, id)
-                util.stops[id] = index
-                tobj.remove(span=Lifespan(index))
-            #print(f"[{event.position.major:x}:{event.position.minor:x}]", end=" ")
-            #print(f"Thread {event.info.threadid:x} terminated")
-    ghidra_trace_set_snap(util.first.major)
-
-
-def ghidra_trace_kill():
-    """
-    Kill a session.
-    """
-
-    print("ghidra_trace_kill")
-
-
-def ghidra_trace_info():
-    """Get info about the Ghidra connection"""
-
-    result = {}
-    if STATE.client is None:
-        print("Not connected to Ghidra\n")
-        return
-    host, port = STATE.client.s.getpeername()
-    print(f"Connected to {STATE.client.description} at {host}:{port}\n")
-    if STATE.trace is None:
-        print("No trace\n")
-        return
-    print("Trace active\n")
-    return result
-
-
-def ghidra_trace_info_lcsp():
-    """
-    Get the selected Ghidra language-compiler-spec pair. 
-    """
-
-    language, compiler = arch.compute_ghidra_lcsp()
-    print("Selected Ghidra language: {}\n".format(language))
-    print("Selected Ghidra compiler: {}\n".format(compiler))
-
-
-def ghidra_trace_txstart(description="tx"):
-    """
-    Start a transaction on the trace
-    """
-
-    STATE.require_no_tx()
-    STATE.tx = STATE.require_trace().start_tx(description, undoable=False)
-
-
-def ghidra_trace_txcommit():
-    """
-    Commit the current transaction
-    """
-
-    STATE.require_tx().commit()
-    STATE.reset_tx()
-
-
-def ghidra_trace_txabort():
-    """
-    Abort the current transaction
-
-    Use only in emergencies.
-    """
-
-    tx = STATE.require_tx()
-    print("Aborting trace transaction!\n")
-    tx.abort()
-    STATE.reset_tx()
-
-
-@contextmanager
-def open_tracked_tx(description):
-    with STATE.require_trace().open_tx(description) as tx:
-        STATE.tx = tx
-        yield tx
-    STATE.reset_tx()
-
-
-def ghidra_trace_save():
-    """
-    Save the current trace
-    """
-
-    STATE.require_trace().save()
-
-
-def ghidra_trace_new_snap(description=None, snap=None):
-    """
-    Create a new snapshot
-
-    Subsequent modifications to machine state will affect the new snapshot.
-    """
-
-    description = str(description)
-    STATE.require_tx()
-    return {'snap': STATE.require_trace().snapshot(description, snap=snap)}
-
-
-def ghidra_trace_set_snap(snap=None):
-    """
-    Go to a snapshot
-
-    Subsequent modifications to machine state will affect the given snapshot.
-    """
-
-    STATE.require_trace().set_snap(int(snap))
-
-
-def put_bytes(start, end, pages, display_result):
-    trace = STATE.require_trace()
-    if pages:
-        start = start // PAGE_SIZE * PAGE_SIZE
-        end = (end + PAGE_SIZE - 1) // PAGE_SIZE * PAGE_SIZE
-    nproc = util.selected_process()
-    if end - start <= 0:
-        return {'count': 0}
-    buf = dbg().read_mem(start, end - start)
-
-    count = 0
-    if buf != None:
-        base, addr = trace.memory_mapper.map(nproc, start)
-        if base != addr.space:
-            trace.create_overlay_space(base, addr.space)
-        count = trace.put_bytes(addr, buf)
-        if display_result:
-            print("Wrote {} bytes\n".format(count))
-    return {'count': count}
-
-
-def eval_address(address):
-    try:
-        return util.parse_and_eval(address)
-    except Exception:
-        raise RuntimeError("Cannot convert '{}' to address".format(address))
-
-
-def eval_range(address, length):
-    start = eval_address(address)
-    try:
-        end = start + util.parse_and_eval(length)
-    except Exception as e:
-        raise RuntimeError("Cannot convert '{}' to length".format(length))
-    return start, end
-
-
-def putmem(address, length, pages=True, display_result=True):
-    start, end = eval_range(address, length)
-    return put_bytes(start, end, pages, display_result)
-
-
-def ghidra_trace_putmem(items):
-    """
-    Record the given block of memory into the Ghidra trace.
-    """
-
-    items = items.split(" ")
-    address = items[0]
-    length = items[1]
-    pages = items[2] if len(items) > 2 else True
-
-    STATE.require_tx()
-    return putmem(address, length, pages, True)
-
-
-def ghidra_trace_putval(items):
-    """
-    Record the given value into the Ghidra trace, if it's in memory.
-    """
-
-    items = items.split(" ")
-    value = items[0]
-    pages = items[1] if len(items) > 1 else True
-
-    STATE.require_tx()
-    try:
-        start = util.parse_and_eval(value)
-    except e:
-        raise RuntimeError("Value '{}' has no address".format(value))
-    end = start + int(start.GetType().GetByteSize())
-    return put_bytes(start, end, pages, True)
-
-
-def ghidra_trace_putmem_state(items):
-    """
-    Set the state of the given range of memory in the Ghidra trace.
-    """
-
-    items = items.split(" ")
-    address = items[0]
-    length = items[1]
-    state = items[2]
-
-    STATE.require_tx()
-    STATE.trace.validate_state(state)
-    start, end = eval_range(address, length)
-    nproc = util.selected_process()
-    base, addr = STATE.trace.memory_mapper.map(nproc, start)
-    if base != addr.space:
-        trace.create_overlay_space(base, addr.space)
-    STATE.trace.set_memory_state(addr.extend(end - start), state)
-
-
-def ghidra_trace_delmem(items):
-    """
-    Delete the given range of memory from the Ghidra trace.
-
-    Why would you do this? Keep in mind putmem quantizes to full pages by
-    default, usually to take advantage of spatial locality. This command does
-    not quantize. You must do that yourself, if necessary.
-    """
-
-    items = items.split(" ")
-    address = items[0]
-    length = items[1]
-
-    STATE.require_tx()
-    start, end = eval_range(address, length)
-    nproc = util.selected_process()
-    base, addr = STATE.trace.memory_mapper.map(nproc, start)
-    # Do not create the space. We're deleting stuff.
-    STATE.trace.delete_bytes(addr.extend(end - start))
-
-
-def putreg():
-    nproc = util.selected_process()
-    if nproc < 0:
-        return
-    nthrd = util.selected_thread()
-    space = REGS_PATTERN.format(procnum=nproc, tnum=nthrd)
-    STATE.trace.create_overlay_space('register', space)
-    robj = STATE.trace.create_object(space)
-    robj.insert()
-    mapper = STATE.trace.register_mapper
-    values = []
-    regs = dbg().get_context_x86_64()
-    keys = ["seg_cs", "seg_ds", "seg_es", "seg_fs", "seg_gs", "seg_ss", "rflags",
-            "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rsp", "rbp", "rip",
-            "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
-    vals = [regs.seg_cs, regs.seg_ds, regs.seg_es, regs.seg_fs, regs.seg_gs,
-            regs.seg_ss, regs.eflags, regs.rax, regs.rbx, regs.rcx, regs.rdx,
-            regs.rsi, regs.rdi, regs.rsp, regs.rbp, regs.rip,
-            regs.r8, regs.r9, regs.r10, regs.r11, regs.r12, regs.r13, regs.r14,
-            regs.r15]
-    for i in range(0, len(keys)):
-        name = keys[i]
-        value = vals[i]
-        try:
-            values.append(mapper.map_value(nproc, name, value))
-            robj.set_value(name, hex(value))
-        except Exception:
-            pass
-    return {'missing': STATE.trace.put_registers(space, values)}
-
-
-def ghidra_trace_putreg():
-    """
-    Record the given register group for the current frame into the Ghidra trace.
-
-    If no group is specified, 'all' is assumed.
-    """
-
-    STATE.require_tx()
-    putreg()
-
-
-def ghidra_trace_delreg(group='all'):
-    """
-    Delete the given register group for the curent frame from the Ghidra trace.
-
-    Why would you do this? If no group is specified, 'all' is assumed.
-    """
-
-    STATE.require_tx()
-    nproc = util.selected_process()
-    nthrd = util.selected_thread()
-    space = REGS_PATTERN.format(procnum=nproc, tnum=nthrd)
-    mapper = STATE.trace.register_mapper
-    names = []
-    names.append(mapper.map_name(nproc, group))
-    return STATE.trace.delete_registers(space, names)
-
-
-def ghidra_trace_create_obj(path=None):
-    """
-    Create an object in the Ghidra trace.
-
-    The new object is in a detached state, so it may not be immediately
-    recognized by the Debugger GUI. Use 'ghidra_trace_insert-obj' to finish the
-    object, after all its required attributes are set.
-    """
-
-    STATE.require_tx()
-    obj = STATE.trace.create_object(path)
-    obj.insert()
-    print("Created object: id={}, path='{}'\n".format(obj.id, obj.path))
-    return {'id': obj.id, 'path': obj.path}
-
-
-def ghidra_trace_insert_obj(path):
-    """
-    Insert an object into the Ghidra trace.
-    """
-
-    # NOTE: id parameter is probably not necessary, since this command is for
-    # humans.
-    STATE.require_tx()
-    span = STATE.trace.proxy_object_path(path).insert()
-    print("Inserted object: lifespan={}\n".format(span))
-    return {'lifespan': span}
-
-
-def ghidra_trace_remove_obj(path):
-    """
-    Remove an object from the Ghidra trace.
-
-    This does not delete the object. It just removes it from the tree for the
-    current snap and onwards.
-    """
-
-    STATE.require_tx()
-    STATE.trace.proxy_object_path(path).remove()
-
-
-def to_bytes(value):
-    return bytes(ord(value[i]) if type(value[i]) == str else int(value[i]) for i in range(0, len(value)))
-
-
-def to_string(value, encoding):
-    b = bytes(ord(value[i]) if type(value[i]) == str else int(
-        value[i]) for i in range(0, len(value)))
-    return str(b, encoding)
-
-
-def to_bool_list(value):
-    return [bool(value[i]) for i in range(0, len(value))]
-
-
-def to_int_list(value):
-    return [ord(value[i]) if type(value[i]) == str else int(value[i]) for i in range(0, len(value))]
-
-
-def to_short_list(value):
-    return [ord(value[i]) if type(value[i]) == str else int(value[i]) for i in range(0, len(value))]
-
-
-def to_string_list(value, encoding):
-    return [to_string(value[i], encoding) for i in range(0, len(value))]
-
-
-def eval_value(value, schema=None):
-    if schema == sch.CHAR or schema == sch.BYTE or schema == sch.SHORT or schema == sch.INT or schema == sch.LONG or schema == None:
-        value = util.get_eval(value)
-        return value, schema
-    if schema == sch.ADDRESS:
-        value = util.get_eval(value)
-        nproc = util.selected_process()
-        base, addr = STATE.trace.memory_mapper.map(nproc, value)
-        return (base, addr), sch.ADDRESS
-    if type(value) != str:
-        value = eval("{}".format(value))
-    if schema == sch.BOOL_ARR:
-        return to_bool_list(value), schema
-    if schema == sch.BYTE_ARR:
-        return to_bytes(value), schema
-    if schema == sch.SHORT_ARR:
-        return to_short_list(value), schema
-    if schema == sch.INT_ARR:
-        return to_int_list(value), schema
-    if schema == sch.LONG_ARR:
-        return to_int_list(value), schema
-    if schema == sch.STRING_ARR:
-        return to_string_list(value, 'utf-8'), schema
-    if schema == sch.CHAR_ARR:
-        return to_string(value, 'utf-8'), sch.CHAR_ARR
-    if schema == sch.STRING:
-        return to_string(value, 'utf-8'), sch.STRING
-
-    return value, schema
-
-
-def ghidra_trace_set_value(path: str, key: str, value, schema=None):
-    """
-    Set a value (attribute or element) in the Ghidra trace's object tree.
-
-    A void value implies removal. 
-    NOTE: The type of an expression may be subject to the dbgeng's current 
-    language. which current defaults to DEBUG_EXPR_CPLUSPLUS (vs DEBUG_EXPR_MASM). 
-    For most non-primitive cases, we are punting to the Python API.
-    """
-    schema = None if schema is None else sch.Schema(schema)
-    STATE.require_tx()
-    if schema == sch.OBJECT:
-        val = STATE.trace.proxy_object_path(value)
-    else:
-        val, schema = eval_value(value, schema)
-        if schema == sch.ADDRESS:
-            base, addr = val
-            val = addr
-            if base != addr.space:
-                trace.create_overlay_space(base, addr.space)
-    STATE.trace.proxy_object_path(path).set_value(key, val, schema)
-
-
-def ghidra_trace_retain_values(path: str, keys: str):
-    """
-    Retain only those keys listed, settings all others to null.
-
-    Takes a list of keys to retain. The first argument may optionally be one of
-    the following:
-
-        --elements To set all other elements to null (default)
-        --attributes To set all other attributes to null
-        --both To set all other values (elements and attributes) to null
-
-    If, for some reason, one of the keys to retain would be mistaken for this
-    switch, then the switch is required. Only the first argument is taken as the
-    switch. All others are taken as keys.
-    """
-
-    keys = keys.split(" ")
-
-    STATE.require_tx()
-    kinds = 'elements'
-    if keys[0] == '--elements':
-        kinds = 'elements'
-        keys = keys[1:]
-    elif keys[0] == '--attributes':
-        kinds = 'attributes'
-        keys = keys[1:]
-    elif keys[0] == '--both':
-        kinds = 'both'
-        keys = keys[1:]
-    elif keys[0].startswith('--'):
-        raise RuntimeError("Invalid argument: " + keys[0])
-    STATE.trace.proxy_object_path(path).retain_values(keys, kinds=kinds)
-
-
-def ghidra_trace_get_obj(path):
-    """
-    Get an object descriptor by its canonical path.
-
-    This isn't the most informative, but it will at least confirm whether an
-    object exists and provide its id.
-    """
-
-    trace = STATE.require_trace()
-    object = trace.get_object(path)
-    print("{}\t{}\n".format(object.id, object.path))
-    return object
-
-
-class TableColumn(object):
-    def __init__(self, head):
-        self.head = head
-        self.contents = [head]
-        self.is_last = False
-
-    def add_data(self, data):
-        self.contents.append(str(data))
-
-    def finish(self):
-        self.width = max(len(d) for d in self.contents) + 1
-
-    def print_cell(self, i):
-        print(
-            self.contents[i] if self.is_last else self.contents[i].ljust(self.width), end='')
-
-
-class Tabular(object):
-    def __init__(self, heads):
-        self.columns = [TableColumn(h) for h in heads]
-        self.columns[-1].is_last = True
-        self.num_rows = 1
-
-    def add_row(self, datas):
-        for c, d in zip(self.columns, datas):
-            c.add_data(d)
-        self.num_rows += 1
-
-    def print_table(self):
-        for c in self.columns:
-            c.finish()
-        for rn in range(self.num_rows):
-            for c in self.columns:
-                c.print_cell(rn)
-            print('\n')
-
-
-def val_repr(value):
-    if isinstance(value, TraceObject):
-        return value.path
-    elif isinstance(value, Address):
-        return '{}:{:08x}'.format(value.space, value.offset)
-    return repr(value)
-
-
-def print_values(values):
-    table = Tabular(['Parent', 'Key', 'Span', 'Value', 'Type'])
-    for v in values:
-        table.add_row(
-            [v.parent.path, v.key, v.span, val_repr(v.value), v.schema])
-    table.print_table()
-
-
-def ghidra_trace_get_values(pattern):
-    """
-    List all values matching a given path pattern.
-    """
-
-    trace = STATE.require_trace()
-    values = trace.get_values(pattern)
-    print_values(values)
-    return values
-
-
-def ghidra_trace_get_values_rng(items):
-    """
-    List all values intersecting a given address range.
-    """
-
-    items = items.split(" ")
-    address = items[0]
-    length = items[1]
-
-    trace = STATE.require_trace()
-    start, end = eval_range(address, length)
-    nproc = util.selected_process()
-    base, addr = trace.memory_mapper.map(nproc, start)
-    # Do not create the space. We're querying. No tx.
-    values = trace.get_values_intersecting(addr.extend(end - start))
-    print_values(values)
-    return values
-
-
-def activate(path=None):
-    trace = STATE.require_trace()
-    if path is None:
-        nproc = util.selected_process()
-        if nproc is None:
-            path = PROCESSES_PATH
-        else:
-            nthrd = util.selected_thread()
-            if nthrd is None:
-                path = PROCESS_PATTERN.format(procnum=nproc)
-            else:
-                path = THREAD_PATTERN.format(procnum=nproc, tnum=nthrd)
-    trace.proxy_object_path(path).activate()
-
-
-def ghidra_trace_activate(path=None):
-    """
-    Activate an object in Ghidra's GUI.
-
-    This has no effect if the current trace is not current in Ghidra. If path is
-    omitted, this will activate the current frame.
-    """
-
-    activate(path)
-
-
-def ghidra_trace_disassemble(address):
-    """
-    Disassemble starting at the given seed.
-
-    Disassembly proceeds linearly and terminates at the first branch or unknown
-    memory encountered.
-    """
-
-    STATE.require_tx()
-    start = eval_address(address)
-    nproc = util.selected_process()
-    base, addr = STATE.trace.memory_mapper.map(nproc, start)
-    if base != addr.space:
-        trace.create_overlay_space(base, addr.space)
-
-    length = STATE.trace.disassemble(addr)
-    print("Disassembled {} bytes\n".format(length))
-    return {'length': length}
-
-
-def compute_proc_state(nproc=None):
-    return 'STOPPED'
-
-
-def put_processes(running=False):
-    radix = util.get_convenience_variable('output-radix')
-    if radix == 'auto':
-        radix = 16
-    keys = []
-    for i, p in enumerate(util.process_list(running)):
-        ipath = PROCESS_PATTERN.format(procnum=i)
-        keys.append(PROCESS_KEY_PATTERN.format(procnum=i))
-        procobj = STATE.trace.create_object(ipath)
-
-        istate = compute_proc_state(p)
-        procobj.set_value('State', istate)
-        if running == False:
-            procobj.set_value('PID', p)
-            pidstr = ('0x{:x}' if radix ==
-                      16 else '0{:o}' if radix == 8 else '{}').format(p)
-            procobj.set_value('_display', pidstr)
-            #procobj.set_value('Name', str(p[1]))
-            procobj.set_value('PEB', hex(util.eng.get_peb_address()))
-        procobj.insert()
-    STATE.trace.proxy_object_path(PROCESSES_PATH).retain_values(keys)
-
-
-def put_state(event_process):
-    STATE.require_no_tx()
-    STATE.tx = STATE.require_trace().start_tx("state", undoable=False)
-    ipath = PROCESS_PATTERN.format(procnum=event_process)
-    procobj = STATE.trace.create_object(ipath)
-    state = compute_proc_state(event_process)
-    procobj.set_value('State', state)
-    procobj.insert()
-    tnum = util.selected_thread()
-    if tnum is not None:
-        ipath = THREAD_PATTERN.format(procnum=event_process, tnum=tnum)
-        threadobj = STATE.trace.create_object(ipath)
-        threadobj.set_value('State', state)
-        threadobj.insert()
-    STATE.require_tx().commit()
-    STATE.reset_tx()
-
-
-def ghidra_trace_put_processes():
-    """
-    Put the list of processes into the trace's Processes list.
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_processes()
-
-
-def put_available():
-    radix = util.get_convenience_variable('output-radix')
-    keys = []
-    result = dbg().cmd(".tlist")
-    lines = result.split("\n")
-    for i in lines:
-        i = i.strip()
-        if i == "":
-            continue
-        if i.startswith("0n") is False:
-            continue
-        items = i.strip().split(" ")
-        id = items[0][2:]
-        name = items[1]
-        ppath = AVAILABLE_PATTERN.format(pid=id)
-        procobj = STATE.trace.create_object(ppath)
-        keys.append(AVAILABLE_KEY_PATTERN.format(pid=id))
-        pidstr = ('0x{:x}' if radix ==
-                  16 else '0{:o}' if radix == 8 else '{}').format(id)
-        procobj.set_value('PID', id)
-        procobj.set_value('Name', name)
-        procobj.set_value('_display', '{} {}'.format(pidstr, name))
-        procobj.insert()
-    STATE.trace.proxy_object_path(AVAILABLES_PATH).retain_values(keys)
-
-
-def ghidra_trace_put_available():
-    """
-    Put the list of available processes into the trace's Available list.
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_available()
-
-
-def put_single_breakpoint(bp, ibobj, nproc, ikeys):
-    mapper = STATE.trace.memory_mapper
-    bpath = PROC_BREAK_PATTERN.format(procnum=nproc, breaknum=bp.id)
-    brkobj = STATE.trace.create_object(bpath)
-    status = True
-    address = bp.addr
-    expr = bp.expr
-    offset = "%016x" % address
-
-    prot = bp.flags
-    width = bp.size
-    prot = {4: 'HW_EXECUTE', 3: 'READ', 2: 'WRITE'}[prot]
-
-    if address is not None:  # Implies execution break
-        base, addr = mapper.map(nproc, address)
-        if base != addr.space:
-            STATE.trace.create_overlay_space(base, addr.space)
-        brkobj.set_value('Range', addr.extend(1))
-    elif expr is not None:  # Implies watchpoint
-        try:
-            address = int(util.parse_and_eval('&({})'.format(expr)))
-            base, addr = mapper.map(inf, address)
-            if base != addr.space:
-                STATE.trace.create_overlay_space(base, addr.space)
-            brkobj.set_value('Range', addr.extend(width))
-        except Exception as e:
-            print("Error: Could not get range for breakpoint: {}\n".format(e))
-        else:  # I guess it's a catchpoint
-            pass
-
-    brkobj.set_value('Expression', expr)
-    brkobj.set_value('Range', addr.extend(1))
-    brkobj.set_value('Kinds', prot)
-    brkobj.set_value('Enabled', status)
-    brkobj.set_value('Flags', prot)
-    brkobj.insert()
-
-    k = PROC_BREAK_KEY_PATTERN.format(breaknum=bp.id)
-    ikeys.append(k)
-
-
-def put_breakpoints():
-    target = util.get_target()
-    nproc = util.selected_process()
-    ibpath = PROC_BREAKS_PATTERN.format(procnum=nproc)
-    ibobj = STATE.trace.create_object(ibpath)
-    keys = []
-    ikeys = []
-    #ids = [bpid for bpid in util.breakpoints]
-    for bp in util.breakpoints:
-        keys.append(PROC_BREAK_KEY_PATTERN.format(breaknum=bp.id))
-        put_single_breakpoint(bp, ibobj, nproc, ikeys)
-    ibobj.insert()
-    STATE.trace.proxy_object_path(PROC_BREAKS_PATTERN).retain_values(keys)
-    ibobj.retain_values(ikeys)
-
-
-def ghidra_trace_put_breakpoints():
-    """
-    Put the current process's breakpoints into the trace.
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_breakpoints()
-
-
-def put_environment():
-    epath = ENV_PATTERN.format(procnum=util.selected_process())
-    envobj = STATE.trace.create_object(epath)
-    envobj.set_value('Debugger', 'pyttd')
-    envobj.set_value('Arch', arch.get_arch())
-    envobj.set_value('OS', arch.get_osabi())
-    envobj.set_value('Endian', arch.get_endian())
-    envobj.insert()
-
-
-def ghidra_trace_put_environment():
-    """
-    Put some environment indicators into the Ghidra trace
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_environment()
-
-
-def put_regions():
-    nproc = util.selected_process()
-    try:
-        modules = util.module_list()
-    except Exception:
-        modules = []
-    if len(modules) == 0 and util.selected_thread() != None:
-        modules = [util.REGION_INFO_READER.full_mem()]
-    mapper = STATE.trace.memory_mapper
-    keys = []
-    for m in modules:
-        rpath = REGION_PATTERN.format(procnum=nproc, start=m.base_addr)
-        keys.append(REGION_KEY_PATTERN.format(start=m.base_addr))
-        regobj = STATE.trace.create_object(rpath)
-        start_base, start_addr = mapper.map(nproc, m.base_addr)
-        if start_base != start_addr.space:
-            STATE.trace.create_overlay_space(start_base, start_addr.space)
-        regobj.set_value('Range', start_addr.extend(m.image_size))
-        regobj.set_value('_readable', True)
-        regobj.set_value('_writable', False)
-        regobj.set_value('_executable', False)
-        regobj.insert()
-    STATE.trace.proxy_object_path(
-        MEMORY_PATTERN.format(procnum=nproc)).retain_values(keys)
-
-
-def ghidra_trace_put_regions():
-    """
-    Read the memory map, if applicable, and write to the trace's Regions
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_regions()
-
-
-def put_modules():
-    target = util.get_target()
-    nproc = util.selected_process()
-    modules = util.module_list()
-    keys = []
-    for m in modules:
-        mobj = get_module(keys, nproc, m.path, m.base_addr, m.image_size)
-        lspan = Lifespan(util.starts[m.base_addr], util.stops[m.base_addr])
-        mobj.insert(span=lspan)
-    # STATE.trace.proxy_object_path(MODULES_PATTERN.format(
-    #    procnum=nproc)).retain_values(keys)
-
-
-def get_module(keys, nproc: int, path, base, size):
-    split = path.split("\\")
-    name = split[len(split)-1]
-    hbase = hex(base)
-    #flags = m[1].Flags
-    mpath = MODULE_PATTERN.format(procnum=nproc, modpath=hbase)
-    modobj = STATE.trace.create_object(mpath)
-    keys.append(MODULE_KEY_PATTERN.format(modpath=hbase))
-    mapper = STATE.trace.memory_mapper
-    base_base, base_addr = mapper.map(nproc, base)
-    if base_base != base_addr.space:
-        STATE.trace.create_overlay_space(base_base, base_addr.space)
-    modobj.set_value('Range', base_addr.extend(size))
-    modobj.set_value('Name', name)
-    modobj.set_value('Path', path)
-    return modobj
-
-
-def ghidra_trace_put_modules():
-    """
-    Gather object files, if applicable, and write to the trace's Modules
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_modules()
-
-
-def convert_state(t):
-    if t.IsSuspended():
-        return 'SUSPENDED'
-    if t.IsStopped():
-        return 'STOPPED'
-    return 'RUNNING'
-
-
-def compute_thread_display(tidstr):
-    return '[{}]'.format(tidstr)
-
-
-def put_threads(running=False):
-    radix = util.get_convenience_variable('output-radix')
-    if radix == 'auto':
-        radix = 16
-    nproc = util.selected_process()
-    if nproc == None:
-        return
-    keys = []
-    for t in util.thread_list():
-        tobj = get_thread(keys, radix, nproc, t.threadid)
-        lspan = Lifespan(util.starts[t.threadid], util.stops[t.threadid])
-        tobj.insert(span=lspan)
-    # STATE.trace.proxy_object_path(
-    #    THREADS_PATTERN.format(procnum=nproc)).retain_values(keys)
-
-
-def get_thread(keys, radix, pid: int, tid: int):
-    tpath = THREAD_PATTERN.format(procnum=pid, tnum=tid)
-    tobj = STATE.trace.create_object(tpath)
-    keys.append(THREAD_KEY_PATTERN.format(tnum=tid))
-    tobj.set_value('TID', tid, span=Lifespan(0))
-    tidstr = ('0x{:x}' if radix == 16 else '0{:o}' if radix ==
-              8 else '{}').format(tid)
-    tobj.set_value('_short_display', '[{}:{}]'.format(
-        pid, tidstr), span=Lifespan(0))
-    tobj.set_value('_display', compute_thread_display(
-        tidstr), span=Lifespan(0))
-    return tobj
-
-
-def put_event_thread(nthrd=None):
-    nproc = util.selected_process()
-    # Assumption: Event thread is selected by pydbg upon stopping
-    if nthrd is None:
-        nthrd = util.selected_thread()
-    if nthrd != None:
-        tpath = THREAD_PATTERN.format(procnum=nproc, tnum=nthrd)
-        tobj = STATE.trace.proxy_object_path(tpath)
-    else:
-        tobj = None
-    STATE.trace.proxy_object_path('').set_value('_event_thread', tobj)
-
-
-def ghidra_trace_put_threads():
-    """
-    Put the current process's threads into the Ghidra trace
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_threads()
-
-
-def put_frames():
-    nproc = util.selected_process()
-    mapper = STATE.trace.memory_mapper
-    nthrd = util.selected_thread()
-    if nthrd is None:
-        return
-    keys = []
-    # f : _DEBUG_STACK_FRAME
-    for f in dbg().backtrace_list():
-        fpath = FRAME_PATTERN.format(
-            procnum=nproc, tnum=nthrd, level=f.FrameNumber)
-        fobj = STATE.trace.create_object(fpath)
-        keys.append(FRAME_KEY_PATTERN.format(level=f.FrameNumber))
-        base, offset_inst = mapper.map(nproc, f.InstructionOffset)
-        if base != offset_inst.space:
-            STATE.trace.create_overlay_space(base, offset_inst.space)
-        base, offset_stack = mapper.map(nproc, f.StackOffset)
-        if base != offset_stack.space:
-            STATE.trace.create_overlay_space(base, offset_stack.space)
-        base, offset_ret = mapper.map(nproc, f.ReturnOffset)
-        if base != offset_ret.space:
-            STATE.trace.create_overlay_space(base, offset_ret.space)
-        base, offset_frame = mapper.map(nproc, f.FrameOffset)
-        if base != offset_frame.space:
-            STATE.trace.create_overlay_space(base, offset_frame.space)
-        fobj.set_value('Instruction Offset', offset_inst)
-        fobj.set_value('Stack Offset', offset_stack)
-        fobj.set_value('Return Offset', offset_ret)
-        fobj.set_value('Frame Offset', offset_frame)
-        fobj.set_value('_display', "#{} {}".format(
-            f.FrameNumber, offset_inst.offset))
-        fobj.insert()
-    STATE.trace.proxy_object_path(STACK_PATTERN.format(
-        procnum=nproc, tnum=nthrd)).retain_values(keys)
-
-
-def ghidra_trace_put_frames():
-    """
-    Put the current thread's frames into the Ghidra trace
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        put_frames()
-
-
-def ghidra_trace_put_all():
-    """
-    Put everything currently selected into the Ghidra trace
-    """
-
-    STATE.require_tx()
-    with STATE.client.batch() as b:
-        # put_available()
-        put_processes()
-        put_environment()
-        put_regions()
-        put_modules()
-        put_threads()
-        # put_frames()
-        put_breakpoints()
-        # put_available()
-        ghidra_trace_putreg()
-        ghidra_trace_putmem("$pc 1")
-        ghidra_trace_putmem("$sp 1")
-
-
-def ghidra_trace_install_hooks():
-    """
-    Install hooks to trace in Ghidra
-    """
-
-    hooks.install_hooks()
-
-
-def ghidra_trace_remove_hooks():
-    """
-    Remove hooks to trace in Ghidra
-
-    Using this directly is not recommended, unless it seems the hooks are
-    preventing pydbg or other extensions from operating. Removing hooks will break
-    trace synchronization until they are replaced.
-    """
-
-    hooks.remove_hooks()
-
-
-def ghidra_trace_sync_enable():
-    """
-    Synchronize the current process with the Ghidra trace
-
-    This will automatically install hooks if necessary. The goal is to record
-    the current frame, thread, and process into the trace immediately, and then
-    to append the trace upon stopping and/or selecting new frames. This action
-    is effective only for the current process. This command must be executed
-    for each individual process you'd like to synchronize. In older versions of
-    pydbg, certain events cannot be hooked. In that case, you may need to execute
-    certain "trace put" commands manually, or go without.
-
-    This will have no effect unless or until you start a trace.
-    """
-
-    hooks.install_hooks()
-    hooks.enable_current_process()
-    put_state(0)
-
-
-def ghidra_trace_sync_disable():
-    """
-    Cease synchronizing the current process with the Ghidra trace
-
-    This is the opposite of 'ghidra_trace_sync-disable', except it will not
-    automatically remove hooks.
-    """
-
-    hooks.disable_current_process()
-
-
-def ghidra_util_wait_stopped(timeout=1):
-    """
-    Spin wait until the selected thread is stopped.
-    """
-
-    start = time.time()
-    t = util.selected_thread()
-    if t is None:
-        return
-    while not t.IsStopped() and not t.IsSuspended():
-        t = util.selected_thread()  # I suppose it could change
-        time.sleep(0.1)
-        if time.time() - start > timeout:
-            raise RuntimeError('Timed out waiting for thread to stop')
-
-
-def dbg():
-    return util.get_debugger()
-
-
-SHOULD_WAIT = ['GO', 'STEP_BRANCH', 'STEP_INTO', 'STEP_OVER']
-
-
-def repl():
-    print("This is the dbgeng.dll (WinDbg) REPL. To drop to Python3, press Ctrl-C.")
-    while True:
-        # TODO: Implement prompt retrieval in PR to pybag?
-        print('dbg> ', end='')
-        try:
-            cmd = input().strip()
-            if not cmd:
-                continue
-            dbg().cmd(cmd, quiet=True)
-            stat = dbg().exec_status()
-            if stat != 'BREAK':
-                dbg().wait()
-            else:
-                pass
-                # dbg().dispatch_events()
-        except KeyboardInterrupt as e:
-            print("")
-            print("You have left the dbgeng REPL and are now at the Python3 interpreter.")
-            print("use repl() to re-enter.")
-            return
-        except:
-            # Assume cmd() has already output the error
-            pass
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/hooks.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/hooks.py
deleted file mode 100644
index a1028a8ddfa..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/hooks.py
+++ /dev/null
@@ -1,441 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-import sys
-import time
-import threading
-
-from pybag import pydbg
-from pybag.dbgeng.callbacks import EventHandler
-from pybag.dbgeng import core as DbgEng
-from pybag.dbgeng import exception
-from pybag.dbgeng.idebugbreakpoint import DebugBreakpoint
-
-from . import commands, util
-
-ALL_EVENTS = 0xFFFF
-
-class HookState(object):
-    __slots__ = ('installed', 'mem_catchpoint')
-
-    def __init__(self):
-        self.installed = False
-        self.mem_catchpoint = None
-
-
-class ProcessState(object):
-    __slots__ = ('first', 'regions', 'modules', 'threads', 'breaks', 'watches', 'visited', 'waiting')
-
-    def __init__(self):
-        self.first = True
-        # For things we can detect changes to between stops
-        self.regions = False
-        self.modules = False
-        self.threads = False
-        self.breaks = False
-        self.watches = False
-        # For frames and threads that have already been synced since last stop
-        self.visited = set()
-        self.waiting = True
-
-    def record(self, description=None, snap=None):
-        first = self.first
-        self.first = False
-        if description is not None:
-            commands.STATE.trace.snapshot(description, snap=snap)
-        if first:
-            commands.put_processes()
-            commands.put_environment()
-        if self.threads:
-            commands.put_threads()
-            self.threads = False
-        thread = util.selected_thread()
-        if thread is not None:
-            if first or thread not in self.visited:
-                commands.putreg()
-                commands.putmem("$pc", "1", display_result=False)
-                commands.putmem("$sp", "1", display_result=False)
-                #commands.put_frames()
-                self.visited.add(thread)
-            #frame = util.selected_frame()
-            #hashable_frame = (thread, frame)
-            #if first or hashable_frame not in self.visited:
-            #    self.visited.add(hashable_frame)
-        if first or self.regions:
-            commands.put_regions()
-            self.regions = False
-        if first or self.modules:
-            commands.put_modules()
-            self.modules = False
-        if first or self.breaks:
-            commands.put_breakpoints()
-            self.breaks = False
-
-    def record_continued(self):
-        commands.put_processes(running=True)
-        commands.put_threads(running=True)
-
-    def record_exited(self, exit_code, description=None, snap=None):
-        if description is not None:
-            commands.STATE.trace.snapshot(description, snap)
-        proc = util.selected_process()
-        ipath = commands.PROCESS_PATTERN.format(procnum=proc)
-        commands.STATE.trace.proxy_object_path(
-            ipath).set_value('Exit Code', exit_code)
-
-
-class BrkState(object):
-    __slots__ = ('break_loc_counts',)
-
-    def __init__(self):
-        self.break_loc_counts = {}
-
-    def update_brkloc_count(self, b, count):
-        self.break_loc_counts[b.GetID()] = count
-
-    def get_brkloc_count(self, b):
-        return self.break_loc_counts.get(b.GetID(), 0)
-
-    def del_brkloc_count(self, b):
-        if b not in self.break_loc_counts:
-            return 0  # TODO: Print a warning?
-        count = self.break_loc_counts[b.GetID()]
-        del self.break_loc_counts[b.GetID()]
-        return count
-
-
-HOOK_STATE = HookState()
-BRK_STATE = BrkState()
-PROC_STATE = {}
-
-
-def on_state_changed(*args):
-    #print("ON_STATE_CHANGED")
-    if args[0] == DbgEng.DEBUG_CES_CURRENT_THREAD:
-        return on_thread_selected(args)
-    elif args[0] == DbgEng.DEBUG_CES_BREAKPOINTS:
-        return on_breakpoint_modified(args)
-    elif args[0] == DbgEng.DEBUG_CES_RADIX:
-        util.set_convenience_variable('output-radix', args[1])
-        return DbgEng.DEBUG_STATUS_GO
-    elif args[0] == DbgEng.DEBUG_CES_EXECUTION_STATUS:
-        proc = util.selected_process()
-        if args[1] & DbgEng.DEBUG_STATUS_INSIDE_WAIT:
-            PROC_STATE[proc].waiting = True
-            return DbgEng.DEBUG_STATUS_GO
-        PROC_STATE[proc].waiting = False
-        commands.put_state(proc)
-        if args[1] == DbgEng.DEBUG_STATUS_BREAK:
-            return on_stop(args)
-        else:
-            return on_cont(args)
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_debuggee_changed(*args):
-    #print("ON_DEBUGGEE_CHANGED")
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    if args[1] == DbgEng.DEBUG_CDS_REGISTERS:
-        on_register_changed(args[0][1])
-    #if args[1] == DbgEng.DEBUG_CDS_DATA:
-    #    on_memory_changed(args[0][1])
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_session_status_changed(*args):
-    #print("ON_STATUS_CHANGED")
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    if args[0] == DbgEng.DEBUG_SESSION_ACTIVE or args[0] == DbgEng.DEBUG_SSESION_REBOOT:
-        with commands.STATE.client.batch():
-            with trace.open_tx("New Process {}".format(util.selected_process())):
-                commands.put_processes() 
-                return DbgEng.DEBUG_STATUS_GO   
-
-
-def on_symbol_state_changed(*args):
-    #print("ON_SYMBOL_STATE_CHANGED")
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    if args[0] == 1 or args[0] == 2:
-        PROC_STATE[proc].modules = True
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_system_error(*args):
-    print("ON_SYSTEM_ERROR")
-    print(hex(args[0]))
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("New Process {}".format(util.selected_process())):
-            commands.put_processes() 
-    return DbgEng.DEBUG_STATUS_BREAK
-
-
-def on_new_process(*args):
-    #print("ON_NEW_PROCESS")
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("New Process {}".format(util.selected_process())):
-            commands.put_processes() 
-    return DbgEng.DEBUG_STATUS_BREAK
-
-
-def on_process_selected():
-    #print("PROCESS_SELECTED")
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("Process {} selected".format(proc)):
-            PROC_STATE[proc].record()
-            commands.activate()
-
-
-def on_process_deleted(*args):
-    #print("ON_PROCESS_DELETED")
-    proc = args[0]
-    on_exited(proc)
-    if proc in PROC_STATE:
-        del PROC_STATE[proc]
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("Process {} deleted".format(proc)):
-            commands.put_processes()  # TODO: Could just delete the one....
-    return DbgEng.DEBUG_STATUS_BREAK
-
-
-def on_threads_changed(*args):
-    #print("ON_THREADS_CHANGED")
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return DbgEng.DEBUG_STATUS_GO
-    PROC_STATE[proc].threads = True
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_thread_selected(*args):
-    #print("THREAD_SELECTED")
-    nthrd = args[0][1]
-    nproc = util.selected_process()
-    if nproc not in PROC_STATE:
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("Thread {}.{} selected".format(nproc, nthrd)):
-            commands.put_state(nproc)
-            state = PROC_STATE[nproc]
-            if state.waiting:
-                state.record_continued()
-            else:
-                state.record()
-                commands.activate()
-
-
-def on_register_changed(regnum):
-    #print("REGISTER_CHANGED")
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("Register {} changed".format(regnum)):
-            commands.putreg()
-            commands.activate()
-
-
-def on_cont(*args):
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    state = PROC_STATE[proc]
-    with commands.STATE.client.batch():
-        with trace.open_tx("Continued"):
-            state.record_continued()
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_stop(*args):
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        print("not in state")
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        print("no trace")
-        return
-    state = PROC_STATE[proc]
-    state.visited.clear()
-    pos = dbg().get_position()
-    rng = range(pos.major, util.lastpos.major)
-    if pos.major > util.lastpos.major:
-        rng = range(util.lastpos.major, pos.major)
-    for i in rng:
-        if util.evttypes.__contains__(i):
-            type = util.evttypes[i]
-            if type == "modload" or type == "modunload":
-                on_modules_changed()
-            if type == "threadcreated" or type == "threadterm":
-                on_threads_changed()
-    util.lastpos = pos
-    with commands.STATE.client.batch():
-        with trace.open_tx("Stopped"):
-            state.record("Stopped", util.pos2snap(pos))
-            commands.put_state(proc)
-            commands.put_event_thread()
-            commands.activate()
-
-
-def on_exited(proc):
-    if proc not in PROC_STATE:
-        print("not in state")
-        return
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    state = PROC_STATE[proc]
-    state.visited.clear()
-    exit_code = util.GetExitCode()
-    description = "Exited with code {}".format(exit_code)
-    with commands.STATE.client.batch():
-        with trace.open_tx(description):
-            state.record_exited(exit_code, description)
-            commands.activate()
-
-
-def on_modules_changed(*args):
-    #print("ON_MODULES_CHANGED")
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return DbgEng.DEBUG_STATUS_GO
-    PROC_STATE[proc].modules = True
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_breakpoint_created(bp):
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    PROC_STATE[proc].breaks = True
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    ibpath = commands.PROC_BREAKS_PATTERN.format(procnum=proc)
-    with commands.STATE.client.batch():
-        with trace.open_tx("Breakpoint {} created".format(bp.id)):
-            ibobj = trace.create_object(ibpath)
-            # Do not use retain_values or it'll remove other locs
-            commands.put_single_breakpoint(bp, ibobj, proc, [])
-            ibobj.insert()
-
-
-def on_breakpoint_modified(*args):
-    #print("BREAKPOINT_MODIFIED")
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    PROC_STATE[proc].breaks = True
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    ibpath = commands.PROC_BREAKS_PATTERN.format(procnum=proc)
-    ibobj = trace.create_object(ibpath)
-    bpid = args[0][1]
-    try:
-        bp = dbg()._control.GetBreakpointById(bpid)
-    except exception.E_NOINTERFACE_Error:
-        dbg().breakpoints._remove_stale(bpid)
-        return on_breakpoint_deleted(bpid)
-    return on_breakpoint_created(bp)
-
-
-def on_breakpoint_deleted(bpt):
-    proc = util.selected_process()
-    if proc not in PROC_STATE:
-        return
-    PROC_STATE[proc].breaks = True
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    bpath = commands.PROC_BREAK_PATTERN.format(procnum=proc, breaknum=bpt.id)
-    with commands.STATE.client.batch():
-        with trace.open_tx("Breakpoint {} deleted".format(bpt.id)):
-            trace.proxy_object_path(bpath).remove(tree=True)
-
-
-def on_breakpoint_hit(*args):
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("New Process {}".format(util.selected_process())):
-            commands.put_processes() 
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def on_exception(*args):
-    trace = commands.STATE.trace
-    if trace is None:
-        return
-    with commands.STATE.client.batch():
-        with trace.open_tx("New Process {}".format(util.selected_process())):
-            commands.put_processes() 
-    return DbgEng.DEBUG_STATUS_GO
-
-
-def install_hooks():
-    if HOOK_STATE.installed:
-        return
-    HOOK_STATE.installed = True
-
-def remove_hooks():
-    if not HOOK_STATE.installed:
-        return
-    HOOK_STATE.installed = False
-
-
-def enable_current_process():
-    proc = util.selected_process()
-    PROC_STATE[proc] = ProcessState()
-
-
-def disable_current_process():
-    proc = util.selected_process()
-    if proc in PROC_STATE:
-        # Silently ignore already disabled
-        del PROC_STATE[proc]
-
-def dbg():
-    return util.get_debugger()
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/libraries.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/libraries.py
deleted file mode 100644
index 5d6b4bd9fc7..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/libraries.py
+++ /dev/null
@@ -1,78 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-import ctypes
-import os
-import platform
-
-import comtypes
-import comtypes.client
-
-
-ctypes.windll.kernel32.SetErrorMode(0x0001 | 0x0002 | 0x8000)
-
-if platform.architecture()[0] == '64bit':
-    dbgdirs = [os.getenv('OPT_DBGMODEL_PATH'),
-               r'C:\Program Files\Windows Kits\10\Debuggers\x64',
-               r'C:\Program Files (x86)\Windows Kits\10\Debuggers\x64']
-else:
-    dbgdirs = [os.getenv('OPT_DBGMODEL_PATH'),
-               r'C:\Program Files\Windows Kits\10\Debuggers\x86',
-               r'C:\Program Files (x86)\Windows Kits\10\Debuggers\x86']
-dbgdir = None
-for _dir in dbgdirs:
-    if _dir is not None and os.path.exists(_dir):
-        dbgdir = _dir
-        break
-
-if not dbgdir:
-    raise RuntimeError("Windbg install directory not found!")
-
-print(f"Loading dbgeng and friends from {dbgdir}")
-
-# preload these to get correct DLLs loaded
-try:
-    ctypes.windll.LoadLibrary(os.path.join(dbgdir, 'dbghelp.dll'))
-except Exception as exc:
-    print(fr"LoadLibrary failed: {dbgdir}\dbghelp.dll {exc}")
-    pass
-try:
-    ctypes.windll.LoadLibrary(os.path.join(dbgdir, 'dbgeng.dll'))
-except Exception as exc:
-    print(fr"LoadLibrary failed: {dbgdir}\dbgeng.dll {exc}")
-    pass
-try:
-    ctypes.windll.LoadLibrary(os.path.join(dbgdir, 'DbgModel.dll'))
-except Exception as exc:
-    print(fr"LoadLibrary failed: {dbgdir}\dbgmodel.dll {exc}")
-    pass
-try:
-    ctypes.windll.LoadLibrary(os.path.join(dbgdir, 'ttd/TTDReplay.dll'))
-except Exception as exc:
-    print(fr"LoadLibrary failed: {dbgdir}\ttd\TTDReplay.dll {exc}")
-    pass
-try:
-    ctypes.windll.LoadLibrary(os.path.join(dbgdir, 'ttd/TTDReplayCPU.dll'))
-except Exception as exc:
-    print(fr"LoadLibrary failed: {dbgdir}\ttd\TTDReplayCPU.dll {exc}")
-    pass
-
-try:
-    from comtypes.gen import DbgMod
-except:
-    tlb = os.path.join(dbgmodel.module_locator(), 'tlb', 'dbgmodel.tlb')
-    print(f"Loading TLB: {tlb}")
-    comtypes.client.GetModule(tlb)
-    from comtypes.gen import DbgMod
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/methods.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/methods.py
deleted file mode 100644
index 7ed486285bd..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/methods.py
+++ /dev/null
@@ -1,538 +0,0 @@
-## ###
-# IP: GHIDRA
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-##
-from concurrent.futures import Future, ThreadPoolExecutor
-import re
-import sys
-
-from ghidratrace import sch
-from ghidratrace.client import MethodRegistry, ParamDesc, Address, AddressRange
-
-from pyttd import pyTTD
-#from pybag import pydbg
-#from pybag.dbgeng import core as DbgEng
-
-from . import util, commands, hooks
-from contextlib import redirect_stdout
-from io import StringIO
-
-
-REGISTRY = MethodRegistry(ThreadPoolExecutor(max_workers=1))
-
-
-def extre(base, ext):
-    return re.compile(base.pattern + ext)
-
-
-AVAILABLE_PATTERN = re.compile('Available\[(?P<pid>\\d*)\]')
-WATCHPOINT_PATTERN = re.compile('Watchpoints\[(?P<watchnum>\\d*)\]')
-BREAKPOINT_PATTERN = re.compile('Breakpoints\[(?P<breaknum>\\d*)\]')
-BREAK_LOC_PATTERN = extre(BREAKPOINT_PATTERN, '\[(?P<locnum>\\d*)\]')
-PROCESS_PATTERN = re.compile('Processes\[(?P<procnum>\\d*)\]')
-PROC_BREAKS_PATTERN = extre(PROCESS_PATTERN, '\.Breakpoints')
-PROC_BREAKBPT_PATTERN = extre(PROC_BREAKS_PATTERN, '\[(?P<breaknum>\\d*)\]')
-ENV_PATTERN = extre(PROCESS_PATTERN, '\.Environment')
-THREADS_PATTERN = extre(PROCESS_PATTERN, '\.Threads')
-THREAD_PATTERN = extre(THREADS_PATTERN, '\[(?P<tnum>\\d*)\]')
-STACK_PATTERN = extre(THREAD_PATTERN, '\.Stack')
-FRAME_PATTERN = extre(STACK_PATTERN, '\[(?P<level>\\d*)\]')
-REGS_PATTERN0 = extre(THREAD_PATTERN, '.Registers')
-REGS_PATTERN = extre(FRAME_PATTERN, '.Registers')
-MEMORY_PATTERN = extre(PROCESS_PATTERN, '\.Memory')
-MODULES_PATTERN = extre(PROCESS_PATTERN, '\.Modules')
-
-
-def find_availpid_by_pattern(pattern, object, err_msg):
-    mat = pattern.fullmatch(object.path)
-    if mat is None:
-        raise TypeError(f"{object} is not {err_msg}")
-    pid = int(mat['pid'])
-    return pid
-
-
-def find_availpid_by_obj(object):
-    return find_availpid_by_pattern(AVAILABLE_PATTERN, object, "an Available")
-
-
-def find_proc_by_num(id):
-    if id != util.selected_process():
-        util.select_process(id)
-    return util.selected_process()
-
-
-def find_proc_by_pattern(object, pattern, err_msg):
-    mat = pattern.fullmatch(object.path)
-    if mat is None:
-        raise TypeError(f"{object} is not {err_msg}")
-    procnum = int(mat['procnum'])
-    return find_proc_by_num(procnum)
-
-
-def find_proc_by_obj(object):
-    return find_proc_by_pattern(object, PROCESS_PATTERN, "an Process")
-
-
-def find_proc_by_procbreak_obj(object):
-    return find_proc_by_pattern(object, PROC_BREAKS_PATTERN,
-                                "a BreakpointLocationContainer")
-
-
-def find_proc_by_procwatch_obj(object):
-    return find_proc_by_pattern(object, PROC_WATCHES_PATTERN,
-                                "a WatchpointContainer")
-
-
-def find_proc_by_env_obj(object):
-    return find_proc_by_pattern(object, ENV_PATTERN, "an Environment")
-
-
-def find_proc_by_threads_obj(object):
-    return find_proc_by_pattern(object, THREADS_PATTERN, "a ThreadContainer")
-
-
-def find_proc_by_mem_obj(object):
-    return find_proc_by_pattern(object, MEMORY_PATTERN, "a Memory")
-
-
-def find_proc_by_modules_obj(object):
-    return find_proc_by_pattern(object, MODULES_PATTERN, "a ModuleContainer")
-
-
-def find_thread_by_num(id):
-    if id != util.selected_thread():
-        util.select_thread(id)
-    return util.selected_thread()
-
-
-def find_thread_by_pattern(pattern, object, err_msg):
-    mat = pattern.fullmatch(object.path)
-    if mat is None:
-        raise TypeError(f"{object} is not {err_msg}")
-    pnum = int(mat['procnum'])
-    tnum = int(mat['tnum'])
-    find_proc_by_num(pnum)
-    return find_thread_by_num(tnum)
-
-
-def find_thread_by_obj(object):
-    return find_thread_by_pattern(THREAD_PATTERN, object, "a Thread")
-
-
-def find_thread_by_stack_obj(object):
-    return find_thread_by_pattern(STACK_PATTERN, object, "a Stack")
-
-
-def find_thread_by_regs_obj(object):
-    return find_thread_by_pattern(REGS_PATTERN0, object, "a RegisterValueContainer")
-
-
-def find_frame_by_level(level):
-    return dbg().backtrace_list()[level]
-
-
-def find_frame_by_pattern(pattern, object, err_msg):
-    mat = pattern.fullmatch(object.path)
-    if mat is None:
-        raise TypeError(f"{object} is not {err_msg}")
-    pnum = int(mat['procnum'])
-    tnum = int(mat['tnum'])
-    level = int(mat['level'])
-    find_proc_by_num(pnum)
-    find_thread_by_num(tnum)
-    return find_frame_by_level(level)
-
-
-def find_frame_by_obj(object):
-    return find_frame_by_pattern(FRAME_PATTERN, object, "a StackFrame")
-
-
-def find_bpt_by_number(breaknum):
-    try:
-        bp = util.breakpoints[breaknum]
-        return bp
-    except exception.E_NOINTERFACE_Error:
-        raise KeyError(f"Breakpoints[{breaknum}] does not exist")
-
-
-def find_bpt_by_pattern(pattern, object, err_msg):
-    mat = pattern.fullmatch(object.path)
-    if mat is None:
-        raise TypeError(f"{object} is not {err_msg}")
-    breaknum = int(mat['breaknum'])
-    return find_bpt_by_number(breaknum)
-
-
-def find_bpt_by_obj(object):
-    return find_bpt_by_pattern(PROC_BREAKBPT_PATTERN, object, "a BreakpointSpec")
-
-
-shared_globals = dict()
-
-
-@REGISTRY.method
-def execute(cmd: str, to_string: bool=False):
-    """Execute a CLI command."""
-    # print("***{}***".format(cmd))
-    # sys.stderr.flush()
-    # sys.stdout.flush()
-    if to_string:
-        data = StringIO()
-        with redirect_stdout(data):
-            exec("{}".format(cmd), shared_globals)
-        return data.getvalue()
-    else:
-        exec("{}".format(cmd), shared_globals)
-
-
-@REGISTRY.method(action='evaluate', display='Evaluate')
-def evaluate(
-	session: sch.Schema('Session'),
- 	expr: ParamDesc(str, display='Expr')):
-    """Execute a CLI command."""
-    return str(eval("{}".format(expr), shared_globals))
-
-
-@REGISTRY.method(action='refresh')
-def refresh_available(node: sch.Schema('AvailableContainer')):
-    """List processes on pydbg's host system."""
-    with commands.open_tracked_tx('Refresh Available'):
-        commands.ghidra_trace_put_available()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_breakpoints(node: sch.Schema('BreakpointContainer')):
-    """
-    Refresh the list of breakpoints (including locations for the current
-    process).
-    """
-    with commands.open_tracked_tx('Refresh Breakpoints'):
-        commands.ghidra_trace_put_breakpoints()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_processes(node: sch.Schema('ProcessContainer')):
-    """Refresh the list of processes."""
-    with commands.open_tracked_tx('Refresh Processes'):
-        commands.ghidra_trace_put_threads()
-
-
-def refresh_environment(node: sch.Schema('Environment')):
-    """Refresh the environment descriptors (arch, os, endian)."""
-    with commands.open_tracked_tx('Refresh Environment'):
-        commands.ghidra_trace_put_environment()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_threads(node: sch.Schema('ThreadContainer')):
-    """Refresh the list of threads in the process."""
-    with commands.open_tracked_tx('Refresh Threads'):
-        commands.ghidra_trace_put_threads()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_stack(node: sch.Schema('Stack')):
-    """Refresh the backtrace for the thread."""
-    tnum = find_thread_by_stack_obj(node)
-    with commands.open_tracked_tx('Refresh Stack'):
-        commands.ghidra_trace_put_frames()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_registers(node: sch.Schema('RegisterValueContainer')):
-    """Refresh the register values for the frame."""
-    tnum = find_thread_by_regs_obj(node)
-    with commands.open_tracked_tx('Refresh Registers'):
-        commands.ghidra_trace_putreg()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_mappings(node: sch.Schema('Memory')):
-    """Refresh the list of memory regions for the process."""
-    with commands.open_tracked_tx('Refresh Memory Regions'):
-        commands.ghidra_trace_put_regions()
-
-
-@REGISTRY.method(action='refresh')
-def refresh_modules(node: sch.Schema('ModuleContainer')):
-    """
-    Refresh the modules and sections list for the process.
-
-    This will refresh the sections for all modules, not just the selected one.
-    """
-    with commands.open_tracked_tx('Refresh Modules'):
-        commands.ghidra_trace_put_modules()
-
-
-@REGISTRY.method(action='activate')
-def activate_process(process: sch.Schema('Process')):
-    """Switch to the process."""
-    find_proc_by_obj(process)
-
-
-@REGISTRY.method(action='activate')
-def activate_thread(thread: sch.Schema('Thread')):
-    """Switch to the thread."""
-    find_thread_by_obj(thread)
-
-
-@REGISTRY.method(action='activate')
-def activate_frame(frame: sch.Schema('StackFrame')):
-    """Select the frame."""
-    find_frame_by_obj(frame)
-
-
-@REGISTRY.method(action='delete')
-def remove_process(process: sch.Schema('Process')):
-    """Remove the process."""
-    find_proc_by_obj(process)
-    dbg().detach()
-
-
-@REGISTRY.method(action='connect', display='Connect')
-@util.dbg.eng_thread
-def target(
-	session: sch.Schema('Session'), 
-	cmd: ParamDesc(str, display='Command')):
-    """Connect to a target machine or process."""
-    dbg().attach_kernel(cmd)
-
-
-@REGISTRY.method(action='attach', display='Attach')
-@util.dbg.eng_thread
-def attach_obj(target: sch.Schema('Attachable')):
-    """Attach the process to the given target."""
-    pid = find_availpid_by_obj(target)
-    dbg().attach(pid)
-
-
-@REGISTRY.method(action='attach', display='Attach by pid')
-@util.dbg.eng_thread
-def attach_pid(
-	session: sch.Schema('Session'), 
-	pid: ParamDesc(str, display='PID')):
-    """Attach the process to the given target."""
-    dbg().attach_proc(int(pid))
-
-
-@REGISTRY.method(action='attach', display='Attach by name')
-@util.dbg.eng_thread
-def attach_name(
-	session: sch.Schema('Session'), 
-	name: ParamDesc(str, display='Name')):
-    """Attach the process to the given target."""
-    dbg().attach_proc(name)
-
-
-@REGISTRY.method(action='detach', display='Detach')
-@util.dbg.eng_thread
-def detach(process: sch.Schema('Process')):
-    """Detach the process's target."""
-    dbg().detach()
-
-
-@REGISTRY.method(action='launch', display='Launch')
-def launch_loader(
-		session: sch.Schema('Session'),
-        file: ParamDesc(str, display='File'),
-        args: ParamDesc(str, display='Arguments')=''):
-    """
-    Start a native process with the given command line, stopping at the ntdll initial breakpoint.
-    """
-    command = file
-    if args != None:
-        command += " "+args
-    commands.ghidra_trace_create(command=file, start_trace=False)
-
-
-@REGISTRY.method(action='launch', display='LaunchEx')
-def launch(
-		session: sch.Schema('Session'),
-        file: ParamDesc(str, display='File'),
-        args: ParamDesc(str, display='Arguments')='',
-        initial_break: ParamDesc(bool, display='Initial Break')=True,
-        timeout: ParamDesc(int, display='Timeout')=-1):
-    """
-    Run a native process with the given command line.
-    """
-    command = file
-    if args != None:
-        command += " "+args
-    commands.ghidra_trace_create(
-        command, initial_break=initial_break, timeout=timeout, start_trace=False)
-
-
-@REGISTRY.method
-def kill(process: sch.Schema('Process')):
-    """Kill execution of the process."""
-    dbg().terminate()
-
-
-@REGISTRY.method(name='continue', action='resume')
-def _continue(process: sch.Schema('Process')):
-    """Continue execution of the process."""
-    dbg().replay_forward(pyTTD.MAX_STEP, util.last)
-    hooks.on_stop()
-
-
-@REGISTRY.method
-def interrupt(process: sch.Schema('Process')):
-    """Interrupt the execution of the debugged program."""
-    print("'interrupt' is unsupported for TTD")
-
-
-@REGISTRY.method(action='step_into')
-def step_into(thread: sch.Schema('Thread'), n: ParamDesc(int, display='N')=1):
-    """Step one instruction exactly."""
-    # find_thread_by_obj(thread)
-    dbg().replay_forward(n, util.last)
-    hooks.on_stop()
-
-
-@REGISTRY.method(action='step_over')
-def step_over(thread: sch.Schema('Thread'), n: ParamDesc(int, display='N')=1):
-    """Step one instruction, but proceed through subroutine calls."""
-    # find_thread_by_obj(thread)
-    dbg().replay_backward(n, util.first)
-    hooks.on_stop()
-
-
-@REGISTRY.method(action='step_out')
-def step_out(thread: sch.Schema('Thread')):
-    """Execute until the current stack frame returns."""
-    dbg().replay_backward(pyTTD.MAX_STEP, util.first)
-    hooks.on_stop()
-
-
-@REGISTRY.method(action='step_to', display='Step To')
-def step_to(thread: sch.Schema('Thread'), address: Address, max=None):
-    """Continue execution up to the given address."""
-    find_thread_by_obj(thread)
-    return dbg().stepto(address.offset, max)
-
-
-def gen_bpt(offset: int, size: int, flags: int):
-    bp = pyTTD.MemoryWatchpointData(addr=offset, size=size, flags=flags)
-    dbg().add_memory_watchpoint(bp)
-    bpt = util.Watchpoint(offset, size, flags, len(util.breakpoints), bp)
-    util.breakpoints.append(bpt)
-    hooks.on_breakpoint_created(bpt)
-
-
-@REGISTRY.method(action='break_sw_execute')
-def break_address(process: sch.Schema('Process'), address: Address):
-    """Set a breakpoint."""
-    gen_bpt(offset=address.offset, size=4, flags=pyTTD.BP_FLAGS.EXEC)
-
-
-@REGISTRY.method(action='break_sw_execute')
-def break_expression(expression: str):
-    """Set a breakpoint."""
-    # TODO: Escape?
-    dbg().bp(expr=expression)
-
-
-@REGISTRY.method(action='break_hw_execute')
-def break_hw_address(process: sch.Schema('Process'), address: Address):
-    """Set a hardware-assisted breakpoint."""
-    gen_bpt(offset=address.offset, size=4, flags=pyTTD.BP_FLAGS.EXEC)
-
-
-@REGISTRY.method(action='break_hw_execute')
-def break_hw_expression(expression: str):
-    """Set a hardware-assisted breakpoint."""
-    dbg().ba(expr=expression)
-
-
-@REGISTRY.method(action='break_read')
-def break_read_range(process: sch.Schema('Process'), range: AddressRange):
-    """Set a read watchpoint."""
-    gen_bpt(offset=range.min, size=range.length(), flags=pyTTD.BP_FLAGS.READ)
-
-
-@REGISTRY.method(action='break_read')
-def break_read_expression(expression: str):
-    """Set a read watchpoint."""
-    dbg().ba(expr=expression, access=DbgEng.DEBUG_BREAK_READ)
-
-
-@REGISTRY.method(action='break_write')
-def break_write_range(process: sch.Schema('Process'), range: AddressRange):
-    """Set a watchpoint."""
-    gen_bpt(offset=range.min, size=range.length(), flags=pyTTD.BP_FLAGS.WRITE)
-
-
-@REGISTRY.method(action='break_write')
-def break_write_expression(expression: str):
-    """Set a watchpoint."""
-    dbg().ba(expr=expression, access=DbgEng.DEBUG_BREAK_WRITE)
-
-
-@REGISTRY.method(action='break_access')
-def break_access_range(process: sch.Schema('Process'), range: AddressRange):
-    """Set an access watchpoint."""
-    find_proc_by_obj(process)
-    break_read_range(process, range)
-    break_write_range(process, range)
-
-
-@REGISTRY.method(action='break_access')
-def break_access_expression(expression: str):
-    """Set an access watchpoint."""
-    dbg().ba(expr=expression, access=DbgEng.DEBUG_BREAK_READ | DbgEng.DEBUG_BREAK_WRITE)
-
-
-@REGISTRY.method(action='toggle')
-def toggle_breakpoint(breakpoint: sch.Schema('BreakpointSpec'), enabled: bool):
-    """Toggle a breakpoint."""
-    bpt = find_bpt_by_obj(breakpoint)
-    if enabled:
-        dbg().be(bpt.GetId())
-    else:
-        dbg().bd(bpt.GetId())
-
-
-@REGISTRY.method(action='delete')
-def delete_breakpoint(breakpoint: sch.Schema('BreakpointSpec')):
-    """Delete a breakpoint."""
-    bpt = find_bpt_by_obj(breakpoint)
-    dbg().remove_memory_watchpoint(bpt.bp)
-    util.breakpoints.remove(bpt)
-    hooks.on_breakpoint_deleted(bpt)
-
-
-@REGISTRY.method
-def read_mem(process: sch.Schema('Process'), range: AddressRange):
-    """Read memory."""
-    nproc = find_proc_by_obj(process)
-    offset_start = process.trace.memory_mapper.map_back(
-        nproc, Address(range.space, range.min))
-    with commands.open_tracked_tx('Read Memory'):
-        dbg().read_mem(range.min, range.length())
-
-
-@REGISTRY.method
-def write_mem(process: sch.Schema('Process'), address: Address, data: bytes):
-    """Write memory."""
-    print("'write_mem' is unsupported for TTD")
-
-
-@REGISTRY.method
-def write_reg(frame: sch.Schema('StackFrame'), name: str, value: bytes):
-    """Write a register."""
-    print("'write_reg' is unsupported for TTD")
-
-
-def dbg():
-    return util.get_debugger()
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/schema.xml b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/schema.xml
deleted file mode 100644
index b9682f17e8b..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/schema.xml
+++ /dev/null
@@ -1,233 +0,0 @@
-<context>
-	<schema name="TTDSession" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="EventScope" />
-		<interface name="FocusScope" />
-		<interface name="Aggregate" />
-		<element schema="VOID" />
-		<attribute name="Processes" schema="ProcessContainer" required="yes" fixed="yes" />
-		<attribute name="Available" schema="AvailableContainer" required="yes" fixed="yes" />
-		<attribute name="_event_thread" schema="OBJECT" hidden="yes" />
-		<attribute name="_focus" schema="Selectable" required="yes" hidden="yes" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Selectable" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="OBJECT" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="BreakpointContainer" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="BreakpointSpec" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="AvailableContainer" canonical="yes" elementResync="ALWAYS" attributeResync="NEVER">
-		<element schema="Attachable" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="ProcessContainer" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="Process" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="BreakpointSpec" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="BreakpointSpec" />
-		<interface name="BreakpointLocation" />
-		<interface name="Togglable" />
-		<element schema="VOID" />
-		<attribute name="Expression" schema="STRING" required="yes" hidden="yes" />
-		<attribute-alias from="_expression" to="Expression" />
-		<attribute name="Kinds" schema="STRING" required="yes" hidden="yes" />
-		<attribute-alias from="_kinds" to="Kinds" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute name="Range" schema="RANGE" />
-		<attribute-alias from="_range" to="Range" />
-		<attribute name="_enabled" schema="BOOL" required="yes" hidden="yes" />
-		<attribute name="Commands" schema="STRING" />
-		<attribute name="Condition" schema="STRING" />
-		<attribute name="Hit Count" schema="INT" />
-		<attribute name="Ignore Count" schema="INT" />
-		<attribute name="Pending" schema="BOOL" />
-		<attribute name="Silent" schema="BOOL" />
-		<attribute name="Temporary" schema="BOOL" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Attachable" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="VOID" />
-		<attribute name="PID" schema="LONG" />
-		<attribute-alias from="_pid" to="PID" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Process" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Activatable" />
-		<interface name="Process" />
-		<interface name="Aggregate" />
-		<interface name="ExecutionStateful" />
-		<element schema="VOID" />
-		<attribute name="Threads" schema="ThreadContainer" required="yes" fixed="yes" />
-		<attribute name="Breakpoints" schema="BreakpointContainer" required="yes" fixed="yes" />
-		<attribute name="Exit Code" schema="LONG" />
-		<attribute-alias from="_exit_code" to="Exit Code" />
-		<attribute name="Environment" schema="Environment" required="yes" fixed="yes" />
-		<attribute name="Memory" schema="Memory" required="yes" fixed="yes" />
-		<attribute name="Modules" schema="ModuleContainer" required="yes" fixed="yes" />
-		<attribute name="PID" schema="LONG" hidden="yes" />
-		<attribute-alias from="_pid" to="PID" />
-		<attribute name="State" schema="EXECUTION_STATE" required="yes" hidden="yes" />
-		<attribute-alias from="_state" to="State" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_short_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Environment" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Environment" />
-		<element schema="VOID" />
-		<attribute name="OS" schema="STRING" />
-		<attribute name="Arch" schema="STRING" />
-		<attribute name="Endian" schema="STRING" />
-		<attribute name="Debugger" schema="STRING" />
-		<attribute-alias from="_os" to="OS" />
-		<attribute-alias from="_arch" to="Arch" />
-		<attribute-alias from="_endian" to="Endian" />
-		<attribute-alias from="_debugger" to="Debugger" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="ModuleContainer" canonical="yes" elementResync="ONCE" attributeResync="NEVER">
-		<element schema="Module" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Memory" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Memory" />
-		<element schema="MemoryRegion" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="ThreadContainer" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="Thread" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Method" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Method" />
-		<element schema="VOID" />
-		<attribute name="_display" schema="STRING" required="yes" fixed="yes" hidden="yes" />
-		<attribute name="_return_type" schema="TYPE" required="yes" fixed="yes" hidden="yes" />
-		<attribute name="_parameters" schema="MAP_PARAMETERS" required="yes" fixed="yes" hidden="yes" />
-		<attribute schema="VOID" fixed="yes" hidden="yes" />
-	</schema>
-	<schema name="Thread" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Activatable" />
-		<interface name="Thread" />
-		<interface name="ExecutionStateful" />
-		<interface name="Aggregate" />
-		<element schema="VOID" />
-		<attribute name="Stack" schema="Stack" required="yes" fixed="yes" />
-		<attribute name="Registers" schema="RegisterValueContainer" required="yes" fixed="yes" />
-		<attribute name="TID" schema="LONG" />
-		<attribute-alias from="_tid" to="TID" />
-		<attribute name="State" schema="EXECUTION_STATE" required="yes" hidden="yes" />
-		<attribute-alias from="_state" to="State" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_short_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute name="Advance" schema="Method" required="yes" fixed="yes" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Module" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Module" />
-		<element schema="VOID" />
-		<attribute name="Sections" schema="SectionContainer" required="yes" fixed="yes" />
-		<attribute name="Symbols" schema="SymbolContainer" required="yes" fixed="yes" />
-		<attribute name="Range" schema="RANGE" />
-		<attribute name="Name" schema="STRING" />
-		<attribute-alias from="_module_name" to="Name" />
-		<attribute-alias from="_range" to="Range" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="MemoryRegion" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="MemoryRegion" />
-		<element schema="VOID" />
-		<attribute name="Base" schema="LONG" required="yes" fixed="yes" />
-		<attribute name="Object File" schema="STRING" fixed="yes" />
-		<attribute name="_readable" schema="BOOL" required="yes" hidden="yes" />
-		<attribute name="_writable" schema="BOOL" required="yes" hidden="yes" />
-		<attribute name="_executable" schema="BOOL" required="yes" hidden="yes" />
-		<attribute name="Range" schema="RANGE" required="yes" hidden="yes" />
-		<attribute-alias from="_range" to="Range" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="SectionContainer" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="Section" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Stack" canonical="yes" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Stack" />
-		<element schema="StackFrame" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="SymbolContainer" canonical="yes" elementResync="ONCE" attributeResync="NEVER">
-		<element schema="Symbol" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="Symbol" elementResync="NEVER" attributeResync="NEVER">
-		<element schema="VOID" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="StackFrame" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Activatable" />
-		<interface name="StackFrame" />
-		<interface name="Aggregate" />
-		<element schema="VOID" />
-		<attribute name="Function" schema="STRING" hidden="yes" />
-		<attribute-alias from="_function" to="Function" />
-		<attribute name="Registers" schema="RegisterValueContainer" required="yes" fixed="yes" />
-		<attribute name="Instruction Offset" schema="ADDRESS" required="yes" />
-		<attribute-alias from="_pc" to="Instruction Offset" />
-		<attribute name="Stack Offset" schema="ADDRESS" />
-		<attribute name="Return Offset" schema="ADDRESS" />
-		<attribute name="Frame Offset" schema="ADDRESS" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="ANY" />
-	</schema>
-	<schema name="Section" elementResync="NEVER" attributeResync="NEVER">
-		<interface name="Section" />
-		<element schema="VOID" />
-		<attribute name="Range" schema="RANGE" />
-		<attribute-alias from="_range" to="Range" />
-		<attribute name="Offset" schema="STRING" fixed="yes" />
-		<attribute name="_display" schema="STRING" hidden="yes" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="RegisterValueContainer" attributeResync="ONCE">
-		<interface name="RegisterContainer" />
-		<attribute name="General Purpose Registers" schema="RegisterBank" />
-		<attribute name="Floating Point Registers" schema="RegisterBank" />
-		<attribute name="Advanced Vector Extensions" schema="RegisterBank" />
-		<attribute name="Memory Protection Extensions" schema="RegisterBank" />
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-	<schema name="RegisterBank" canonical="yes" elementResync="ONCE" attributeResync="NEVER">
-		<attribute name="_order" schema="INT" hidden="yes" />
-		<attribute schema="VOID" />
-	</schema>
-</context>
\ No newline at end of file
diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/util.py b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/util.py
deleted file mode 100644
index 2b6cec60d53..00000000000
--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/py/src/ghidrattd/util.py
+++ /dev/null
@@ -1,204 +0,0 @@
-## ###
-#  IP: GHIDRA
-# 
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#  
-#       http://www.apache.org/licenses/LICENSE-2.0
-#  
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-##
-from collections import namedtuple
-import os
-import re
-import sys
-
-from ctypes import *
-
-from pyttd import pyTTD
-
-#from pybag import pydbg
-#from pybag.dbgeng import core as DbgEng
-#from pybag.dbgeng import exception
-#from pybag.dbgeng import util as DbgUtil
-
-base = False
-eng = False
-first = False
-last = False
-breakpoints = []
-events = {}
-evttypes = {}
-starts = {}
-stops = {}
-lastpos = False
-DbgVersion = namedtuple('DbgVersion', ['full', 'major', 'minor'])
-
-
-class Watchpoint(object):
-    def __init__(self, addr, size, flags, id, bp):
-        self.addr = addr
-        self.size = size
-        self.flags = flags
-        self.id = id
-        self.bp = bp
-        self.expr = None
-
-
-def _compute_pydbg_ver():
-    blurb = "" #get_debugger()._control.GetActualProcessorType()
-    full = ""
-    major = 0
-    minor = 0
-    return DbgVersion(full, int(major), int(minor))
-
-
-DBG_VERSION = _compute_pydbg_ver()
-
-
-def get_debugger():
-    return base
-
-
-def get_target():
-    return 0  # get_debugger()._systems.GetCurrentSystemId()
-
-
-def get_inst(addr):
-    dbg = get_debugger()
-    ins = DbgUtil.disassemble_instruction(
-        dbg.bitness(), addr, dbg.read_mem(addr, 15))
-    return str(ins)
-
-
-def get_inst_sz(addr):
-    dbg = get_debugger()
-    ins = DbgUtil.disassemble_instruction(
-        dbg.bitness(), addr, dbg.read_mem(addr, 15))
-    return str(ins.size)
-
-
-def get_breakpoints():
-    return None
-
-
-def selected_process():
-    try:
-        return 0
-        # return current_process
-    except Exception:
-        return None
-
-
-def selected_thread():
-    try:
-        dbg = get_debugger()
-        current = dbg.get_thread_info()
-        return current.threadid
-    except Exception:
-        return None
-
-
-def selected_frame():
-    return 0  # selected_thread().GetSelectedFrame()
-
-
-def select_process(id: int):
-    return None
-
-
-def select_thread(id: int):
-    return None
-
-
-def select_frame(id: int):
-    # TODO: this needs to be fixed
-    return None
-
-
-def parse_and_eval(expr):
-    dbg = get_debugger()
-    if expr == "$pc":
-        return dbg.get_program_counter()
-    if expr == "$sp":
-        return dbg.get_context_x86_64().rsp
-    return int(expr)
-
-
-def get_eval(expr, type=None):
-    ctrl = get_debugger()._control._ctrl
-    ctrl.SetExpressionSyntax(1)
-    value = DbgEng._DEBUG_VALUE()
-    index = c_ulong()
-    if type == None:
-        type = DbgEng.DEBUG_VALUE_INT64
-    hr = ctrl.Evaluate(Expression="{}".format(expr).encode(
-    ), DesiredType=type, Value=byref(value), RemainderIndex=byref(index))
-    exception.check_err(hr)
-    if type == DbgEng.DEBUG_VALUE_INT8:
-        return value.u.I8
-    if type == DbgEng.DEBUG_VALUE_INT16:
-        return value.u.I16
-    if type == DbgEng.DEBUG_VALUE_INT32:
-        return value.u.I32
-    if type == DbgEng.DEBUG_VALUE_INT64:
-        return value.u.I64.I64
-    if type == DbgEng.DEBUG_VALUE_FLOAT32:
-        return value.u.F32
-    if type == DbgEng.DEBUG_VALUE_FLOAT64:
-        return value.u.F64
-    if type == DbgEng.DEBUG_VALUE_FLOAT80:
-        return value.u.F80Bytes
-    if type == DbgEng.DEBUG_VALUE_FLOAT82:
-        return value.u.F82Bytes
-    if type == DbgEng.DEBUG_VALUE_FLOAT128:
-        return value.u.F128Bytes
-
-
-def process_list(running=False):
-    """process_list() -> list of all processes"""
-    sysids = [0]
-    return sysids
-
-
-def thread_list():
-    """thread_list() -> list of all threads"""
-    dbg = get_debugger()
-    return dbg.get_thread_list()
-
-
-def module_list():
-    """thread_list() -> list of all threads"""
-    dbg = get_debugger()
-    return dbg.get_module_list()
-
-
-conv_map = {}
-
-
-def get_convenience_variable(id):
-    #val = get_target().GetEnvironment().Get(id)
-    if id not in conv_map:
-        return "auto"
-    val = conv_map[id]
-    if val is None:
-        return "auto"
-    return val
-
-
-def set_convenience_variable(id, value):
-    #env = get_target().GetEnvironment()
-    # return env.Set(id, value, True)
-    conv_map[id] = value
-
-
-def pos2snap(pos: int):
-    index = int(pos.major)
-    if index < 0 or index >= pyTTD.MAX_STEP:
-        return int(last.major)*1000
-    return index*1000+int(pos.minor)
diff --git a/Ghidra/Debug/Debugger-agent-drgn/src/main/py/src/ghidradrgn/commands.py b/Ghidra/Debug/Debugger-agent-drgn/src/main/py/src/ghidradrgn/commands.py
index 812840c48b7..3deafa49f0f 100644
--- a/Ghidra/Debug/Debugger-agent-drgn/src/main/py/src/ghidradrgn/commands.py
+++ b/Ghidra/Debug/Debugger-agent-drgn/src/main/py/src/ghidradrgn/commands.py
@@ -1296,16 +1296,6 @@ def map_address(address):
     return (base, addr)
 
 
-# def ghidra_trace_put_generic(node):
-#     """
-#     Put the current thread's frames into the Ghidra trace
-#     """
-#
-#     STATE.require_tx()
-#     with STATE.client.batch() as b:
-#         put_generic(node)
-
-
 def ghidra_trace_put_all():
     """
     Put everything currently selected into the Ghidra trace
diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/help/help/topics/TraceRmiLauncherServicePlugin/TraceRmiLauncherServicePlugin.html b/Ghidra/Debug/Debugger-rmi-trace/src/main/help/help/topics/TraceRmiLauncherServicePlugin/TraceRmiLauncherServicePlugin.html
index 37904af0092..b2782f91df9 100644
--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/help/help/topics/TraceRmiLauncherServicePlugin/TraceRmiLauncherServicePlugin.html
+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/help/help/topics/TraceRmiLauncherServicePlugin/TraceRmiLauncherServicePlugin.html
@@ -955,38 +955,21 @@ <H4>EXDI</H4>
     values are detected. If anyone understand how to extend this search (or knows how to set the
     base address to sidestep the scan), we would really love some guidance.</P>
 
-    <H3><A name="dbgeng_ttd"></A>TTD (Time-Travel Debugging)</H3>
+    <H3><A name="dbgeng_trace"></A>TTD (Time-Travel Debugging)</H3>
 
     <P>This is a nascent extension to our launcher for the Windows Debugger. The launcher itself
-    functions well, but lacks full integration. It is not yet properly packaged for the Ghidra
-    distribution, but is available in development environments. It also needs some additional
-    protocol support, namely to integrate its notion of time travel with Ghidra's notion. For the
-    time being, we map our time specifications as follows. MS TTD uses a tuple for its time specs,
-    both displayed in hexadecimal, e.g., "B5:1A". The first is the "major," which we believe counts
-    the events that warrant a snapshot. The second is the "minor," which we believe counts
-    instructions executed since the major event. Thus, we would like to map the major to a Ghidra
-    trace snapshot and the minor to steps of p-code emulation. For example, the "B5:1A" notation
-    would map to "181:26". It should be no surprise the notations are similar, since both MS TTD
-    and Ghidra (as well as several other "timeless" debuggers) use a snapshot-replay strategy to
-    recover past machine states. However, we have not yet worked out how to have Ghidra cooperate
-    with a back end in the replay part of this strategy. Currently, Ghidra will always apply p-code
-    emulation, despite having a perfectly good and performant back end available. So, for the time
-    being, we multiply the major number by 1000, thus reserving that many Ghidra snapshots between
-    major events for MS TTD minor steps. Thus, the notation "B5:1A" will actually map to "181026",
-    that is snapshot 181026 with no steps of p-code emulation. This hack will fall short if you
-    visit a time where the minor number exceeds 999.</P>
-
-    <P>Furthermore, if you use the Ghidra Debugger UI to visit a past snapshot, the back end is not
-    yet informed of your intent. You will probably only see stale records of the machine state.
-    Instead, please use the kd commands from the Terminal to navigate through time. The back end
-    (MS TTD) will perform the replay, record the snapshot, and command Ghidra to navigate
-    there.</P>
+    functions, but lacks full integration. In particular, Ghidra's concept of time is not
+	mapped directly to the TTD concept of time. TTD uses a major/minor scheme for ordering events,
+    where the major index changes when TTD must record a change in state.  Events, including thread
+	creation/termination, module loads/unloads, syscalls, and other asynchronous changes, merit 
+    new major indices. When you step forward or backward in a trace, the dbgeng API will increment
+	and decrement correspondingly.  Ghidra, on the other hand, will only increment.</P>
 
     <H4>Options</H4>
 
-    <P>This launcher has the same options as the WinDbg launcher, except that the DLL path must
-    contain <TT>dbgmodel.dll</TT> and the scripts that implement TTD. These are most easily
-    obtained by installing WinDbg Preview or later.</P>
+    <P>This launcher has basically the same options as the WinDbg launcher, except that arguments 
+	are not included and the DLL path must contain <TT>TTDReplay.dll</TT>
+	and the scripts that implement TTD. These are most easily obtained by installing WinDbg Preview or later.</P>
 
     <H2>Stock Java Launchers</H2>
 
diff --git a/Ghidra/Debug/Debugger/certification.manifest b/Ghidra/Debug/Debugger/certification.manifest
index 61f075738a5..95fcd108364 100644
--- a/Ghidra/Debug/Debugger/certification.manifest
+++ b/Ghidra/Debug/Debugger/certification.manifest
@@ -110,10 +110,12 @@ src/main/resources/images/record.png||GHIDRA||||END|
 src/main/resources/images/register-marker.png||GHIDRA||||END|
 src/main/resources/images/registers.png||GHIDRA||||END|
 src/main/resources/images/resume.png||GHIDRA||||END|
+src/main/resources/images/resumeback.png||GHIDRA||||END|
 src/main/resources/images/seek-present.png||GHIDRA||||END|
 src/main/resources/images/select-registers.png||GHIDRA||||END|
 src/main/resources/images/skipover.png||GHIDRA||||END|
 src/main/resources/images/stepback.png||GHIDRA||||END|
+src/main/resources/images/stepbackinto.png||GHIDRA||||END|
 src/main/resources/images/stepinto.png||GHIDRA||||END|
 src/main/resources/images/steplast.png||GHIDRA||||END|
 src/main/resources/images/stepout.png||GHIDRA||||END|
@@ -163,11 +165,13 @@ src/main/svg/record.svg||GHIDRA||||END|
 src/main/svg/register-marker.svg||GHIDRA||||END|
 src/main/svg/registers.svg||GHIDRA||||END|
 src/main/svg/resume.svg||GHIDRA||||END|
+src/main/svg/resumeback.svg||GHIDRA||||END|
 src/main/svg/seek-present.svg||GHIDRA||||END|
 src/main/svg/select-registers.svg||GHIDRA||||END|
 src/main/svg/skipover.svg||GHIDRA||||END|
 src/main/svg/stack.svg||GHIDRA||||END|
 src/main/svg/stepback.svg||GHIDRA||||END|
+src/main/svg/stepbackinto.svg||GHIDRA||||END|
 src/main/svg/stepinto.svg||GHIDRA||||END|
 src/main/svg/steplast.svg||GHIDRA||||END|
 src/main/svg/stepout.svg||GHIDRA||||END|
diff --git a/Ghidra/Debug/Debugger/data/debugger.theme.properties b/Ghidra/Debug/Debugger/data/debugger.theme.properties
index 03d71281da1..5a783a3be9e 100644
--- a/Ghidra/Debug/Debugger/data/debugger.theme.properties
+++ b/Ghidra/Debug/Debugger/data/debugger.theme.properties
@@ -104,6 +104,7 @@ icon.debugger.processor = memory16.gif // TODO this icon was missing 'kcmprocess
 icon.debugger.launch = launch.png
 icon.debugger.attach = attach.png
 icon.debugger.resume = resume.png
+icon.debugger.resume.back = resumeback.png
 icon.debugger.interrupt = interrupt.png
 icon.debugger.kill = kill.png
 icon.debugger.detach = detach.png
@@ -111,6 +112,8 @@ icon.debugger.record = record.png
 icon.debugger.step.into = stepinto.png
 icon.debugger.step.over = stepover.png
 icon.debugger.step.back = stepback.png
+icon.debugger.step.back.into = stepbackinto.png
+icon.debugger.step.back.over = stepback.png
 icon.debugger.step.finish = stepout.png
 icon.debugger.step.last = steplast.png
 icon.debugger.skip.over = skipover.png
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/DebuggerMemviewTraceListener.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/DebuggerMemviewTraceListener.java
index 4ac10309068..195451cf5ac 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/DebuggerMemviewTraceListener.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/DebuggerMemviewTraceListener.java
@@ -112,11 +112,14 @@ private void regionChanged(TraceMemoryRegion region) {
 			!(region instanceof TraceObjectMemoryRegion objRegion)) {
 			return;
 		}
-
+	
 		TraceObject obj = objRegion.getObject();
 		obj.getOrderedValues(Lifespan.ALL, TraceObjectMemoryRegion.KEY_RANGE, true).forEach(v -> {
+			if (region.getName(v.getMinSnap()).equals("full memory")) {
+				return;
+			}
 			MemoryBox box = new MemoryBox("Region " + region.getName(v.getMinSnap()),
-				MemviewBoxType.VIRTUAL_ALLOC, v.castValue(), v.getLifespan());
+				MemviewBoxType.REGION, v.castValue(), v.getLifespan());
 			updateList.add(box);
 		});
 		updateLabelDebouncer.contact(null);
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewMapModel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewMapModel.java
index 4febfd30b66..5d68a6ce317 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewMapModel.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewMapModel.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,8 +38,7 @@ class MemviewMapModel extends AbstractSortedTableModel<MemoryBox> {
 	private Map<String, MemoryBox> memMap = new HashMap<>();
 	private MemviewProvider provider;
 
-	private final static String COLUMN_NAMES[] =
-		{ NAME_COL, ASTART_COL, ASTOP_COL, TSTART_COL, TSTOP_COL };
+	private final static String COLUMN_NAMES[] = { NAME_COL, ASTART_COL, ASTOP_COL, TSTART_COL, TSTOP_COL };
 
 	public MemviewMapModel(MemviewProvider provider) {
 		super(ASTART);
@@ -109,9 +108,9 @@ public String getColumnName(int column) {
 	}
 
 	/**
-	 * Convenience method for locating columns by name. Implementation is naive so this should be
-	 * overridden if this method is to be called often. This method is not in the TableModel
-	 * interface and is not used by the JTable.
+	 * Convenience method for locating columns by name. Implementation is naive so
+	 * this should be overridden if this method is to be called often. This method
+	 * is not in the TableModel interface and is not used by the JTable.
 	 */
 	@Override
 	public int findColumn(String columnName) {
@@ -143,9 +142,10 @@ public boolean isCellEditable(int rowIndex, int columnIndex) {
 	}
 
 	/**
-	 * Returns the number of records managed by the data source object. A <B>JTable</B> uses this
-	 * method to determine how many rows it should create and display. This method should be quick,
-	 * as it is call by <B>JTable</B> quite frequently.
+	 * Returns the number of records managed by the data source object. A
+	 * <B>JTable</B> uses this method to determine how many rows it should create
+	 * and display. This method should be quick, as it is call by <B>JTable</B>
+	 * quite frequently.
 	 *
 	 * @return the number or rows in the model
 	 * @see #getColumnCount
@@ -165,8 +165,7 @@ public MemoryBox getBoxAt(int rowIndex) {
 		MemoryBox box = memList.get(rowIndex);
 		try {
 			box.getStart();
-		}
-		catch (ConcurrentModificationException e) {
+		} catch (ConcurrentModificationException e) {
 			update();
 		}
 		return memList.get(rowIndex);
@@ -180,25 +179,24 @@ public int getIndexForBox(MemoryBox box) {
 	public Object getColumnValueForRow(MemoryBox box, int columnIndex) {
 		try {
 			switch (columnIndex) {
-				case NAME:
-					return box.getId();
-				case ASTART:
-					return box.getRange().getMinAddress();
-				case ASTOP:
-					return box.getRange().getMaxAddress();
-				case TSTART:
-					return Long.toString(box.getStart());
-				case TSTOP:
-					long end = box.getEnd();
-					if (end == Long.MAX_VALUE) {
-						return "+" + '\u221e' + '\u2025';
-					}
-					return Long.toString(end);
-				default:
-					return "UNKNOWN";
+			case NAME:
+				return box.getId();
+			case ASTART:
+				return box.getRange().getMinAddress();
+			case ASTOP:
+				return box.getRange().getMaxAddress();
+			case TSTART:
+				return Long.toString(box.getStart(), 16);
+			case TSTOP:
+				long end = box.getEnd();
+				if (end == Long.MAX_VALUE) {
+					return "+" + '\u221e' + '\u2025';
+				}
+				return Long.toString(end, 16);
+			default:
+				return "UNKNOWN";
 			}
-		}
-		catch (ConcurrentModificationException e) {
+		} catch (ConcurrentModificationException e) {
 			update();
 		}
 		return null;
@@ -225,18 +223,18 @@ public MemoryMapComparator(int sortColumn) {
 		public int compare(MemoryBox b1, MemoryBox b2) {
 
 			switch (sortColumn) {
-				case NAME:
-					return b1.getId().compareToIgnoreCase(b2.getId());
-				case ASTART:
-					return (int) (b1.getStartAddress() - b2.getStartAddress());
-				case ASTOP:
-					return (int) (b1.getStopAddress() - b2.getStopAddress());
-				case TSTART:
-					return (int) (b1.getStartTime() - b2.getStartTime());
-				case TSTOP:
-					return (int) (b1.getStopTime() - b2.getStopTime());
-				default:
-					return 0;
+			case NAME:
+				return b1.getId().compareToIgnoreCase(b2.getId());
+			case ASTART:
+				return (int) (b1.getStartAddress() - b2.getStartAddress());
+			case ASTOP:
+				return (int) (b1.getStopAddress() - b2.getStopAddress());
+			case TSTART:
+				return (int) (b1.getStartTime() - b2.getStartTime());
+			case TSTOP:
+				return (int) (b1.getStopTime() - b2.getStopTime());
+			default:
+				return 0;
 			}
 		}
 	}
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java
index a7a53490a4c..03900d2b26b 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -348,7 +348,7 @@ public String getToolTipText(MouseEvent e) {
 		for (MemoryBox memoryBox : boxes) {
 			aval = memoryBox.getId();
 		}
-		return vertical ? tval + ":" + aval : aval + ":" + tval;
+		return vertical ? tval + " : " + aval : aval + " : " + tval;
 	}
 
 	private void parseBoxes(Collection<MemoryBox> boxes) {
@@ -487,7 +487,8 @@ public String getTagForAddr(long addr) {
 	public String getTagForTick(long tick) {
 		String tval = "";
 		if (0 <= tick && tick < timesArray.length) {
-			tval = Long.toString(timesArray[(int) tick]);
+			Long time = timesArray[(int) tick];
+			tval = Long.toString(time, 16);
 		}
 		return tval;
 	}
diff --git a/Ghidra/Debug/Debugger/src/main/resources/images/resumeback.png b/Ghidra/Debug/Debugger/src/main/resources/images/resumeback.png
new file mode 100644
index 00000000000..808fa6b11fb
Binary files /dev/null and b/Ghidra/Debug/Debugger/src/main/resources/images/resumeback.png differ
diff --git a/Ghidra/Debug/Debugger/src/main/resources/images/stepbackinto.png b/Ghidra/Debug/Debugger/src/main/resources/images/stepbackinto.png
new file mode 100644
index 00000000000..cbf1037d2b0
Binary files /dev/null and b/Ghidra/Debug/Debugger/src/main/resources/images/stepbackinto.png differ
diff --git a/Ghidra/Debug/Debugger/src/main/svg/resumeback.svg b/Ghidra/Debug/Debugger/src/main/svg/resumeback.svg
new file mode 100644
index 00000000000..0c46e537ade
--- /dev/null
+++ b/Ghidra/Debug/Debugger/src/main/svg/resumeback.svg
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<svg
+   viewBox="0 0 16 16"
+   version="1.1"
+   id="svg4819"
+   height="16"
+   width="16"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:dc="http://purl.org/dc/elements/1.1/">
+  <defs
+     id="defs4821" />
+  <metadata
+     id="metadata4824">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <path
+     id="path842"
+     d="M 12.5,2.1503906 V 13.849609 L 1.970703,8 Z"
+     style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#fffffe;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />
+  <path
+     id="path856"
+     d="M 12,3 V 13 L 3,8 Z"
+     style="opacity:1;fill:#008000;fill-opacity:1;stroke:none;stroke-width:1.76383;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
+</svg>
diff --git a/Ghidra/Debug/Debugger/src/main/svg/stepbackinto.svg b/Ghidra/Debug/Debugger/src/main/svg/stepbackinto.svg
new file mode 100644
index 00000000000..39569305533
--- /dev/null
+++ b/Ghidra/Debug/Debugger/src/main/svg/stepbackinto.svg
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<svg
+   height="16"
+   width="16"
+   id="svg2"
+   version="1.1"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:dc="http://purl.org/dc/elements/1.1/">
+  <metadata
+     id="metadata8">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <defs
+     id="defs6" />
+  <rect
+     y="10"
+     x="-15"
+     height="5"
+     width="14"
+     id="rect815"
+     style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.191062;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+     transform="scale(-1,1)" />
+  <path
+     style="opacity:1;vector-effect:none;fill:#d4aa00;fill-opacity:1;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+     d="M 5,9.0004758 H 7 V 5.5 C 7,3 7,3 9.5,3 H 15 V 5 H 9.5 C 9,5 9,5 9,5.5 v 3.5004758 l 2,-4.759e-4 -3,3.0004761 z"
+     id="path834" />
+  <rect
+     y="11"
+     x="-14"
+     height="3"
+     width="3"
+     id="rect819"
+     style="fill:#0166a9;fill-opacity:1;stroke:none;stroke-width:2.25;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+     transform="scale(-1,1)" />
+  <rect
+     y="11"
+     x="-5"
+     height="3"
+     width="3"
+     id="rect821"
+     style="fill:#0166a9;fill-opacity:1;stroke:none;stroke-width:2.25;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+     transform="scale(-1,1)" />
+  <path
+     id="rect4163"
+     d="M 5,9.0004758 H 7 V 5.5 C 7,3 7,3 9.5,3 H 15 V 5 H 9.5 C 9,5 9,5 9,5.5 v 3.5004758 l 2,-4.759e-4 -3,3.0004761 z"
+     style="opacity:1;vector-effect:none;fill:#d4aa00;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+</svg>
```
-----------------------------------
