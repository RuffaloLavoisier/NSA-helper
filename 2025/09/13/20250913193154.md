# Commit: 213a52ad6e74c7c1b31aa6b14032de10b4badd15
## Message: Merge remote-tracking branch 'origin/GP-5968_dev747368_handle_misreported_filesizes_better'
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/FileByteProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/FileByteProvider.java
index e50ac871c24..0893196f4d4 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/FileByteProvider.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/FileByteProvider.java
@@ -55,7 +55,15 @@ public FileByteProvider(File file, FSRL fsrl, AccessMode accessMode)
 		this.fsrl = fsrl;
 		this.accessMode = accessMode;
 		this.raf = new RandomAccessFile(file, accessModeToString(accessMode));
-		this.currentLength = raf.length();
+		try {
+			this.currentLength = getFilesize();
+		}
+		catch (IOException e) {
+			// we have to close raf here since the caller won't have a FileByteProvider to close
+			this.raf.close();
+			this.raf = null;
+			throw e;
+		}
 	}
 
 	/**
@@ -268,6 +276,26 @@ private void ensureBounds(long index, long length) throws IOException {
 		}
 	}
 
+	private long getFilesize() throws IOException {
+		// Note: we need to do these checks because some file systems (eg. /proc, /sys) will
+		// report inaccurate values for sizes of programmatically generated files.
+		long len = raf.length();
+		if (len > 0) {
+			raf.seek(len - 1);
+			try {
+				if (raf.read() >= 0) {
+					return len;
+				}
+			}
+			catch (IOException e) {
+				// fall thru
+			}
+			throw new IOException(
+				"Unable to determine file size: %s, reported as %d".formatted(file, len));
+		}
+		return len;
+	}
+
 	private long getBufferPos(long index) {
 		return (index / BUFFER_SIZE) * BUFFER_SIZE;
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java
index a7afa5919c0..6a4456cba44 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java
@@ -255,11 +255,9 @@ public boolean isFilesystemMountedAt(FSRL fsrl) {
 	 * @param fsrl {@link FSRL} of the desired file
 	 * @param monitor {@link TaskMonitor} so the user can cancel
 	 * @return a {@link RefdFile} which contains the resultant {@link GFile} and a
-	 * {@link FileSystemRef} that needs to be closed, or {@code null} if the filesystem
-	 * does not have the requested file.
-	 *
+	 * {@link FileSystemRef} that needs to be closed, never {@code null}
 	 * @throws CancelledException if the user cancels
-	 * @throws IOException if there was a file io problem
+	 * @throws IOException if file not found or there was a file io problem
 	 */
 	public RefdFile getRefdFile(FSRL fsrl, TaskMonitor monitor)
 			throws CancelledException, IOException {
@@ -267,8 +265,8 @@ public RefdFile getRefdFile(FSRL fsrl, TaskMonitor monitor)
 		try {
 			GFile gfile = ref.getFilesystem().lookup(fsrl.getPath());
 			if (gfile == null) {
-				throw new IOException("File [" + fsrl + "] not found in filesystem [" +
-					ref.getFilesystem().getFSRL() + "]");
+				throw new IOException("File [%s] not found in filesystem [%s]"
+						.formatted(fsrl.getPath(), ref.getFilesystem().getFSRL()));
 			}
 			RefdFile result = new RefdFile(ref, gfile);
 			ref = null;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java
index 70bdea68d76..3c209e398b8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java
@@ -16,7 +16,6 @@
 package ghidra.plugin.importer;
 
 import java.awt.Window;
-import java.io.Closeable;
 import java.io.IOException;
 import java.util.*;
 
@@ -43,6 +42,7 @@
 import ghidra.program.util.DefaultLanguageService;
 import ghidra.util.*;
 import ghidra.util.exception.CancelledException;
+import ghidra.util.exception.CryptoException;
 import ghidra.util.filechooser.ExtensionFileFilter;
 import ghidra.util.filechooser.GhidraFileFilter;
 import ghidra.util.task.TaskLauncher;
@@ -131,34 +131,30 @@ public static void showImportDialog(PluginTool tool, ProgramManager programManag
 
 		Objects.requireNonNull(monitor);
 
-		RefdFile referencedFile = null;
-		try {
-			referencedFile = fsService.getRefdFile(fsrl, monitor);
-
-			FSRL fullFsrl = fsService.getFullyQualifiedFSRL(fsrl, monitor);
-			boolean isFSContainer = fsService.isFileFilesystemContainer(fullFsrl, monitor);
-			if (referencedFile.file.getLength() == 0) {
-				Msg.showError(ImporterUtilities.class, null, "File is empty",
-					"File " + fsrl.getPath() + " is empty, nothing to import");
+		try (RefdFile referencedFile = fsService.getRefdFile(fsrl, monitor)) {
+			if (!ensureFileImportable(referencedFile, monitor)) {
 				return;
 			}
 
+			FSRL fullFsrl = fsService.getFullyQualifiedFSRL(fsrl, monitor);
 			GFileSystem fs = referencedFile.fsRef.getFilesystem();
 			if (fs instanceof GFileSystemProgramProvider) {
 				doFsImport(referencedFile, fullFsrl, destinationFolder, programManager, tool);
 				return;
 			}
 
-			if (!isFSContainer) {
+			if (fsService.isFileFilesystemContainer(fullFsrl, monitor)) {
+				// file is a container, ask user to pick single import, batch import or fs browser
+				importFromContainer(tool, programManager, destinationFolder, suggestedPath, monitor,
+					referencedFile, fullFsrl);
+			}
+			else {
 				// normal file; do a single-file import
 				showImportSingleFileDialog(fullFsrl, destinationFolder, suggestedPath, tool,
 					programManager, monitor);
 				return;
 			}
 
-			// file is a container, ask user to pick single import, batch import or fs browser
-			importFromContainer(tool, programManager, destinationFolder, suggestedPath, monitor,
-				referencedFile, fullFsrl);
 		}
 		catch (IOException ioe) {
 			String message = ioe.getMessage();
@@ -168,20 +164,6 @@ public static void showImportDialog(PluginTool tool, ProgramManager programManag
 		catch (CancelledException e) {
 			Msg.info(ImporterUtilities.class, "Show Import Dialog canceled");
 		}
-		finally {
-			close(referencedFile);
-		}
-	}
-
-	private static void close(Closeable c) {
-		if (c != null) {
-			try {
-				c.close();
-			}
-			catch (IOException e) {
-				// ignore
-			}
-		}
 	}
 
 	private static void importFromContainer(PluginTool tool, ProgramManager programManager,
@@ -601,4 +583,35 @@ public static LoadSpec getLoadSpec(Program program) {
 		return getLoadSpec(provider, program);
 	}
 	
+	private static boolean ensureFileImportable(RefdFile refdFile, TaskMonitor monitor) {
+		GFile f = refdFile.file;
+		GFileSystem fs = refdFile.fsRef.getFilesystem();
+
+		monitor.initialize(0);
+		monitor.setMessage("Testing file access: " + f.getName());
+		try (ByteProvider bp = fs.getByteProvider(f, monitor)) {
+			if (bp.length() == 0) {
+				Msg.showError(ImporterUtilities.class, null, "File is empty",
+					"File %s is empty, nothing to import".formatted(f.getPath()));
+				return false;
+			}
+			return true;
+		}
+		catch (CryptoException e) {
+			Msg.showError(ImporterUtilities.class, null, "Crypto / Password Error",
+				"Unable to access the specified file.\n" +
+					"This could be caused by not entering the correct password or " +
+					"because of missing crypto information.\n\n" + e.getMessage());
+			return false;
+		}
+		catch (IOException e) {
+			Msg.showError(ImporterUtilities.class, null, "File IO Error",
+				"Unable to access the specified file.\n\n" + e.getMessage());
+			return false;
+		}
+		catch (CancelledException e) {
+			return false;
+		}
+	}
+
 }
```
-----------------------------------
