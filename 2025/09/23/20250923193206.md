# Commit: bf71cc4b8cb4caff51afd37a9aa69107ed6d05a3
## Message: Merge remote-tracking branch 'origin/Ghidra_12.0'
## Diff:
```
diff --git a/Ghidra/Configurations/Public_Release/src/global/docs/WhatsNew.md b/Ghidra/Configurations/Public_Release/src/global/docs/WhatsNew.md
index 4cf4fcc37a0..2541270f085 100644
--- a/Ghidra/Configurations/Public_Release/src/global/docs/WhatsNew.md
+++ b/Ghidra/Configurations/Public_Release/src/global/docs/WhatsNew.md
@@ -49,14 +49,9 @@ by client versions prior to 12.0 which lack support for the new storage format.
 which introduce new link-files into a project will not be able to add such files into version 
 control if connected to older Ghidra Server versions.  
 
-**NOTE:** Ghidra Server: The Ghidra 12.x server is compatible with Ghidra 9.2 and later Ghidra
-clients although the presence of any newer link-files within a repository may not be handled 
-properly by client versions prior to 12.0 which lack support for the new storage format. Ghidra 12.0
-clients which introduce new link-files into a project will not be able to add such files into
-version control if connected to older Ghidra Server versions. Ghidra 12.x clients are compatible 
-with all  0.x and 9.x servers.  Although, due to potential Java version differences, it is 
+**NOTE:** Ghidra Server: Due to potential Java version differences, it is 
 recommended that Ghidra Server installations older than 10.2 be upgraded. Those using 10.2 and newer
-should not need a server upgrade.
+should not need a server upgrade unless they need to work with link-files within a shared repository.
 	
 **NOTE:** Programs imported with a Ghidra beta version or code built directly from source code
 outside of a release tag may not be compatible, and may have flaws that won't be corrected by using
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java
index 809180208ff..5fe9abceed1 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,6 +21,7 @@
 import java.util.regex.Pattern;
 
 import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleException;
 
 import generic.jar.ResourceFile;
 import ghidra.app.plugin.core.osgi.*;
@@ -105,6 +106,9 @@ public GhidraScript getScriptInstance(ResourceFile sourceFile, PrintWriter write
 				"Ghidra scripts in Java must extend " + GhidraScript.class.getName() + ". " +
 					sourceFile.getName() + " does not.");
 		}
+		catch (BundleException e) {
+			throw new GhidraScriptLoadException("BundleException: " + e.getMessage(), e);
+		}
 		catch (ClassNotFoundException e) {
 			throw new GhidraScriptLoadException("The class could not be found. " +
 				"It must be the public class of the .java file: " + e.getMessage(), e);
@@ -158,8 +162,15 @@ public Class<?> loadClass(ResourceFile sourceFile, PrintWriter writer) throws Ex
 			throw new ClassNotFoundException(
 				"Failed to get OSGi bundle containing script: " + sourceFile.toString());
 		}
-		Class<?> clazz = osgiBundle.loadClass(classname); // throws ClassNotFoundException
-		return clazz;
+		try {
+			return osgiBundle.loadClass(classname); // throws ClassNotFoundException
+		}
+		catch (ClassNotFoundException e) {
+			if (e.getCause() instanceof BundleException be) {
+				throw be;
+			}
+			throw e;
+		}
 	}
 
 	@Override
diff --git a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/security/PKIAuthenticationModule.java b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/security/PKIAuthenticationModule.java
index fe6532bc75c..df2abce0058 100644
--- a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/security/PKIAuthenticationModule.java
+++ b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/security/PKIAuthenticationModule.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -51,7 +51,7 @@ public PKIAuthenticationModule(boolean anonymousAllowed)
 			throws IOException, CertificateException {
 		this.anonymousAllowed = anonymousAllowed;
 		authorities = ApplicationKeyManagerUtils.getTrustedIssuers();
-		if (authorities == null) {
+		if (authorities == null || authorities.length == 0) {
 			throw new IOException("trusted PKI Certificate Authorities have not been configured");
 		}
 	}
@@ -73,8 +73,8 @@ public Callback[] getAuthenticationCallbacks() {
 			byte[] token = TokenGenerator.getNewToken(TOKEN_SIZE);
 			boolean usingSelfSignedCert =
 				ApplicationKeyManagerFactory.usingGeneratedSelfSignedCertificate();
-			SignedToken signedToken = ApplicationKeyManagerUtils.getSignedToken(
-				usingSelfSignedCert ? null : authorities, token);
+			SignedToken signedToken = ApplicationKeyManagerUtils
+					.getSignedToken(usingSelfSignedCert ? null : authorities, token);
 			sigCb = new SignatureCallback(authorities, token, signedToken.signature);
 		}
 		catch (Throwable t) {
@@ -107,9 +107,9 @@ public String authenticate(UserManager userMgr, Subject subject, Callback[] call
 
 		SignatureCallback sigCb = null;
 		if (callbacks != null) {
-			for (int i = 0; i < callbacks.length; i++) {
-				if (callbacks[i] instanceof SignatureCallback) {
-					sigCb = (SignatureCallback) callbacks[i];
+			for (Callback callback : callbacks) {
+				if (callback instanceof SignatureCallback) {
+					sigCb = (SignatureCallback) callback;
 					break;
 				}
 			}
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationKeyManagerUtils.java b/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationKeyManagerUtils.java
index 082ba095a65..e86696c0fdf 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationKeyManagerUtils.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationKeyManagerUtils.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -88,7 +88,8 @@ private ApplicationKeyManagerUtils() {
 	/**
 	 * Sign the supplied token byte array using an installed certificate from
 	 * one of the specified authorities
-	 * @param authorities trusted certificate authorities
+	 * @param authorities trusted certificate authorities used to constrain client certificate
+	 *   (may be null or empty array if CA constraint does not matter).
 	 * @param token token byte array
 	 * @return signed token object
 	 * @throws NoSuchAlgorithmException algorithym associated within signing certificate not found
@@ -108,8 +109,8 @@ public static SignedToken getSignedToken(Principal[] authorities, byte[] token)
 					continue;
 				}
 				X509KeyManager x509KeyManager = (X509KeyManager) keyManager;
-				String alias = x509KeyManager.chooseClientAlias(new String[] { RSA_TYPE },
-					authorities, null);
+				String alias =
+					x509KeyManager.chooseClientAlias(new String[] { RSA_TYPE }, authorities, null);
 				if (alias != null) {
 					privateKey = x509KeyManager.getPrivateKey(alias);
 					certificateChain = x509KeyManager.getCertificateChain(alias);
@@ -155,9 +156,9 @@ public static SignedToken getSignedToken(Principal[] authorities, byte[] token)
 	}
 
 	/**
-	 * Verify that the specified sigBytes reflect my signature of the specified
-	 * token.
-	 * @param authorities trusted certificate authorities
+	 * Verify that the specified sigBytes reflect my signature of the specified token.
+	 * @param authorities trusted certificate authorities used to constrain client certificate
+	 *   (may be null or empty array if CA constraint does not matter).
 	 * @param token byte array token
 	 * @param signature token signature
 	 * @return true if signature is my signature
@@ -199,7 +200,7 @@ public static X500Principal[] getTrustedIssuers() throws CertificateException {
 			}
 			X509TrustManager x509TrustManager = (X509TrustManager) trustManager;
 			X509Certificate[] acceptedIssuers = x509TrustManager.getAcceptedIssuers();
-			if (acceptedIssuers != null) {
+			if (acceptedIssuers != null && acceptedIssuers.length != 0) {
 				openTrust = false;
 				for (X509Certificate trustedCert : acceptedIssuers) {
 					set.add(trustedCert.getSubjectX500Principal());
@@ -356,8 +357,7 @@ public ProtectionParameter getProtectionParameter() {
 						"Unsupported certificate type: " + caCert.getType());
 				}
 				X509Certificate caX509Cert = (X509Certificate) caCert;
-				caX500Name =
-					new X500Name(caX509Cert.getSubjectX500Principal().getName());
+				caX500Name = new X500Name(caX509Cert.getSubjectX500Principal().getName());
 				keyUsage = new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment);
 				issuerKey = caEntry.getPrivateKey();
 			}
diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationTrustManagerFactory.java b/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationTrustManagerFactory.java
index ef4c27f540c..4e34f4cbca7 100644
--- a/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationTrustManagerFactory.java
+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/net/ApplicationTrustManagerFactory.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -165,6 +165,17 @@ static synchronized TrustManager[] getTrustManagers() {
 		}
 		return wrappedTrustManagers.clone();
 	}
+	
+	/**
+     * Get trust manager after performing any necessary initialization.
+     * @return trust managers
+     */
+    public static synchronized X509TrustManager getTrustManager() {
+        if (trustManager == null) {
+            init();
+        }
+        return trustManager;
+    }
 
 	/**
 	 * Invalidate the active keystore and key manager 
@@ -235,7 +246,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)
 		 */
 		@Override
 		public X509Certificate[] getAcceptedIssuers() {
-			return null; // no CA's have been stipulated
+			return NO_CERTS; // no CA's have been stipulated
 		}
 
 	}
diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ChangeManager.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ChangeManager.java
index 60825733d1e..10c8e0c9e75 100644
--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ChangeManager.java
+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ChangeManager.java
@@ -274,8 +274,6 @@ else if (node instanceof DomainFolderNode folderNode) {
 
 	private void addFileNode(DataTreeNode node, String fileName, boolean isFolderLink) {
 
-		Msg.debug(this, "addFileNode: " + node.getPathname() + "  " + fileName + "  " +
-			Boolean.toString(isFolderLink));
 		if (node.isLeaf() || !node.isLoaded()) {
 			return;
 		}
```
-----------------------------------
