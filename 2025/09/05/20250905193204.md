# Commit: 72c410fd1cbddf7d9630f3f653cf1882627ac531
## Message: Refactor of new methods; test
## Diff:
```
diff --git a/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/GTableDynamicColumnModelTest.java b/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/GTableDynamicColumnModelTest.java
index 75d500758ce..b883c4f7a21 100644
--- a/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/GTableDynamicColumnModelTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/GTableDynamicColumnModelTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,18 +15,18 @@
  */
 package docking.widgets.table;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 
 import java.awt.BorderLayout;
+import java.util.List;
 
 import javax.swing.JFrame;
 import javax.swing.JScrollPane;
+import javax.swing.table.TableColumn;
 
 import org.junit.*;
 
-import docking.widgets.table.model.DirData;
-import docking.widgets.table.model.TestGDynamicColumnTableModel;
+import docking.widgets.table.model.*;
 import ghidra.test.AbstractGhidraHeadedIntegrationTest;
 import ghidra.util.table.GhidraTable;
 
@@ -73,9 +73,8 @@ public void testRemoveColumn() throws Exception {
 	@Test
 	public void testAddColumn() throws Exception {
 
-		// Grab a column in the middle to remove
 		int count = model.getColumnCount();
-		DynamicTableColumn<DirData, ?, ?> column = model.getColumn(2);
+		DynamicTableColumn<DirData, ?, ?> column = new DirDataSizeColumn();
 
 		int index = 2; // in the middle
 		runSwing(() -> {
@@ -86,6 +85,93 @@ public void testAddColumn() throws Exception {
 		assertColumnPresent(column);
 	}
 
+	@Test
+	public void testTableColumnDescriptor_ShortcutColumnCreation() throws Exception {
+
+		frame.dispose();
+
+		model = new TestGDynamicColumnTableModel() {
+			@Override
+			protected TableColumnDescriptor<DirData> createTableColumnDescriptor() {
+				TableColumnDescriptor<DirData> descriptor = new TableColumnDescriptor<>();
+				descriptor.addVisibleColumn("Name", String.class, data -> data.getName());
+				descriptor.addVisibleColumn("Size", Integer.class, data -> data.getSize());
+				descriptor.addHiddenColumn("Date", String.class, data -> data.getTime());
+				return descriptor;
+			}
+		};
+		table = new GhidraTable(model);
+
+		frame = new JFrame("Ghidra Table Test");
+		frame.getContentPane().setLayout(new BorderLayout());
+		frame.getContentPane().add(new JScrollPane(table));
+		frame.pack();
+		frame.setVisible(true);
+
+		// Note: when building the column model, all columns are visible by default, including those
+		// created as hidden columns.  A swing process will run to update the hidden columns.  Thus,
+		// we need to flush the swing processes to get that update to happen.
+		waitForSwing();
+
+		assertEquals(3, model.getColumnCount());
+
+		GTableColumnModel columnModel = (GTableColumnModel) table.getColumnModel();
+		assertEquals(2, columnModel.getColumnCount());
+
+		assertColumns("Name", "Size");
+
+		showHiddenColumn("Date");
+		assertColumns("Name", "Size", "Date");
+	}
+
+	private void showHiddenColumn(String name) {
+		TableColumn tableColumn = getHiddenTableColumn(name);
+		GTableColumnModel columnModel = (GTableColumnModel) table.getColumnModel();
+		runSwing(() -> columnModel.setVisible(tableColumn, true));
+	}
+
+	private TableColumn getHiddenTableColumn(String name) {
+		GTableColumnModel columnModel = (GTableColumnModel) table.getColumnModel();
+		TableColumn tableColumn = runSwing(() -> {
+			List<TableColumn> allColumns = columnModel.getAllColumns();
+			for (TableColumn column : allColumns) {
+				Object headerValue = column.getHeaderValue();
+				if (headerValue.equals(name)) {
+					return column;
+				}
+			}
+			return null;
+		});
+		assertNotNull(tableColumn);
+
+		boolean isVisible = runSwing(() -> {
+			int index = tableColumn.getModelIndex();
+			return columnModel.isVisible(index);
+		});
+		assertFalse(isVisible);
+		return tableColumn;
+	}
+
+	private DynamicTableColumn<DirData, ?, ?> getColumn(String name) {
+		int count = model.getColumnCount();
+		for (int i = 0; i < count; i++) {
+
+			DynamicTableColumn<DirData, ?, ?> column = model.getColumn(i);
+			String columnName = column.getColumnName();
+			if (columnName.equals(name)) {
+				return column;
+			}
+		}
+		return null;
+	}
+
+	private void assertColumns(String... expectedNames) {
+		for (String expectedName : expectedNames) {
+			DynamicTableColumn<DirData, ?, ?> column = getColumn(expectedName);
+			assertNotNull("Column not found in model - " + expectedName, column);
+		}
+	}
+
 	private void assertColumnPresent(DynamicTableColumn<DirData, ?, ?> column) {
 		int count = model.getColumnCount();
 		for (int i = 0; i < count; i++) {
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/TableColumnDescriptor.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/TableColumnDescriptor.java
index b38708b7339..51eaf135f05 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/TableColumnDescriptor.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/TableColumnDescriptor.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,6 +16,7 @@
 package docking.widgets.table;
 
 import java.util.*;
+import java.util.function.Function;
 
 import ghidra.docking.settings.Settings;
 import ghidra.framework.plugintool.ServiceProvider;
@@ -98,22 +99,94 @@ public void addVisibleColumn(DynamicTableColumn<ROW_TYPE, ?, ?> column) {
 	}
 
 	/**
-	 * Adds a column to the descriptor via an anonymous accessor function instead of an anonymous object
-	 *
-	 * The column type needs to be explicitly specified because there is no way to prevent erasure of the generic
-	 * types of an anonymous function
+	 * @param column the column to add
+	 * @param sortOrdinal the <b>ordinal (i.e., 1, 2, 3...n)</b>, not the index (i.e, 0, 1, 2...n).
+	 * @param ascending true to sort ascending
+	 */
+	public void addVisibleColumn(DynamicTableColumn<ROW_TYPE, ?, ?> column, int sortOrdinal,
+			boolean ascending) {
+
+		columns.add(new TableColumnInfo(column, true, sortOrdinal, ascending));
+	}
+
+	/**
+	 * Adds a column to the descriptor via an anonymous accessor function instead.
+	 * <P>
+	 * If you would like to control the sorting behavior of your column, then use 
+	 * {@link #addVisibleColumn(String, Class, Function, int, boolean)}.
+	 * <P>
+	 * Note: any columns created via this method will not be discoverable by other tables.  To use
+	 * that feature, you must create a separate column class that extends 
+	 * {@link DynamicTableColumnExtensionPoint}.
+	 * 
+	 * @param name the column name, visible in the UI
+	 * @param columnTypeClass the column class type
+	 * @param rowToColumnFunction a function to convert a row object to the column object
+	 * @param <COLUMN_TYPE> the column type
+	 */
+	public <COLUMN_TYPE> void addVisibleColumn(String name, Class<COLUMN_TYPE> columnTypeClass,
+			Function<ROW_TYPE, COLUMN_TYPE> rowToColumnFunction) {
+		addVisibleColumn(name, columnTypeClass, rowToColumnFunction, -1, true);
+	}
+
+	/**
+	 * Adds a column to the descriptor via an anonymous accessor function instead.
+	 * <P>
+	 * Note: any columns created via this method will not be discoverable by other tables.  To use
+	 * that feature, you must create a separate column class that extends 
+	 * {@link DynamicTableColumnExtensionPoint}.
 	 *
+	 * @param name the column name, visible in the UI
+	 * @param columnTypeClass the column class type
+	 * @param rowToColumnFunction a function to convert a row object to the column object
+	 * @param sortOrdinal the <b>ordinal (i.e., 1, 2, 3...n)</b>, not the index (i.e, 0, 1, 2...n)
+	 * @param ascending true for sort ascending; false for descending
+	 * @param <COLUMN_TYPE> the column type
+	 */
+	public <COLUMN_TYPE> void addVisibleColumn(String name, Class<COLUMN_TYPE> columnTypeClass,
+			Function<ROW_TYPE, COLUMN_TYPE> rowToColumnFunction, int sortOrdinal,
+			boolean ascending) {
+
+		AbstractDynamicTableColumn<ROW_TYPE, COLUMN_TYPE, Object> column =
+			createColumnStub(name, columnTypeClass, rowToColumnFunction);
+		addVisibleColumn(column, sortOrdinal, ascending);
+	}
+
+	/**
+	 * Adds a column to the descriptor via an anonymous accessor function instead.  The column added
+	 * will not be displayed until enabled by the user.
+	 * <P>
+	 * Note: any columns created via this method will not be discoverable by other tables.  To use
+	 * that feature, you must create a separate column class that extends 
+	 * {@link DynamicTableColumnExtensionPoint}.
+	 * 
+	 * @param name the column name, visible in the UI
+	 * @param columnTypeClass the column class type
+	 * @param rowToColumnFunction a function to convert a row object to the column object
+	 * @param <COLUMN_TYPE> the column type
 	 */
-	public <COLUMN_TYPE> void addColumn(String name, Class<COLUMN_TYPE> columnTypeClass, RowObjectAccessor<ROW_TYPE, COLUMN_TYPE> rowObjectAccessor, boolean visible) {
-		AbstractDynamicTableColumn<ROW_TYPE, COLUMN_TYPE, Object> column = new AbstractDynamicTableColumn<>() {
+	public <COLUMN_TYPE> void addHiddenColumn(String name, Class<COLUMN_TYPE> columnTypeClass,
+			Function<ROW_TYPE, COLUMN_TYPE> rowToColumnFunction) {
+
+		AbstractDynamicTableColumn<ROW_TYPE, COLUMN_TYPE, Object> column =
+			createColumnStub(name, columnTypeClass, rowToColumnFunction);
+		addHiddenColumn(column);
+	}
+
+	private <COLUMN_TYPE> AbstractDynamicTableColumn<ROW_TYPE, COLUMN_TYPE, Object> createColumnStub(
+			String name, Class<COLUMN_TYPE> columnTypeClass,
+			Function<ROW_TYPE, COLUMN_TYPE> rowToColumnFunction) {
+
+		return new AbstractDynamicTableColumn<>() {
 			@Override
 			public String getColumnName() {
 				return name;
 			}
 
 			@Override
-			public COLUMN_TYPE getValue(ROW_TYPE rowObject, Settings settings, Object data, ServiceProvider serviceProvider) throws IllegalArgumentException {
-				return rowObjectAccessor.access(rowObject);
+			public COLUMN_TYPE getValue(ROW_TYPE rowObject, Settings settings, Object data,
+					ServiceProvider serviceProvider) throws IllegalArgumentException {
+				return rowToColumnFunction.apply(rowObject);
 			}
 
 			@Override
@@ -123,37 +196,10 @@ public Class<COLUMN_TYPE> getColumnClass() {
 
 			@Override
 			public Class<ROW_TYPE> getSupportedRowType() {
-				// The reflection tricks in the regular implementation won't work and will always return null
-				// because of type erasure
+				// returning null means this column will not be available to use in other tables
 				return null;
 			}
 		};
-		if (visible)  {
-			addVisibleColumn(column);
-		} else {
-			addHiddenColumn(column);
-		}
-	}
-	/**
-	 * Adds a visible column to the descriptor via an anonymous accessor function instead of an anonymous object
-	 *
-	 * The column type needs to be explicitly specified because there is no way to prevent erasure of the generic
-	 * types of an anonymous function
-	 *
-	 */
-	public <COLUMN_TYPE> void addColumn(String name, Class<COLUMN_TYPE> columnTypeClass, RowObjectAccessor<ROW_TYPE, COLUMN_TYPE> rowObjectAccessor) {
-		addColumn(name, columnTypeClass, rowObjectAccessor, true);
-	}
-
-	/**
-	 * @param column the column to add
-	 * @param sortOrdinal the <b>ordinal (i.e., 1, 2, 3...n)</b>, not the index (i.e, 0, 1, 2...n).
-	 * @param ascending true to sort ascending
-	 */
-	public void addVisibleColumn(DynamicTableColumn<ROW_TYPE, ?, ?> column, int sortOrdinal,
-			boolean ascending) {
-
-		columns.add(new TableColumnInfo(column, true, sortOrdinal, ascending));
 	}
 
 	private class TableColumnInfo implements Comparable<TableColumnInfo> {
@@ -179,16 +225,4 @@ public int compareTo(TableColumnInfo o) {
 			return sortIndex - o.sortIndex;
 		}
 	}
-
-	/**
-	 * A functional interface for accessing a column value from a row object
-	 * This allows for the creation of columns with anonymous functions via {@link #addColumn}
-	 * @param <ROW_TYPE>
-	 * @param <COLUMN_TYPE>
-	 */
-	@FunctionalInterface
-	public interface RowObjectAccessor<ROW_TYPE, COLUMN_TYPE> {
-		public COLUMN_TYPE access(ROW_TYPE rowObject) throws IllegalArgumentException;
-	}
-
 }
```
-----------------------------------
