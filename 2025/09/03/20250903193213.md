# Commit: 90d498e27c423ed63ea9a6a03809c1191db386cc
## Message: Merge remote-tracking branch 'origin/GP-0-dragonmacher-patch-merge'
## Diff:
```
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
index faf4dc46630..18ba63f001c 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
@@ -90,6 +90,7 @@ public class DecompilerPanel extends JPanel implements FieldMouseListener, Field
 		}
 	});
 
+	private Set<String> ignoredMiddleMouseTokens = Set.of("{", "}", ";");
 	private ActiveMiddleMouse activeMiddleMouse;
 	private int middleMouseHighlightButton;
 	private Color middleMouseHighlightColor;
@@ -264,11 +265,10 @@ private void toggleMiddleMouseHighlight(FieldLocation location, Field field) {
 		}
 
 		// exclude tokens that users do not want to highlight
-		if (token instanceof ClangOpToken) {
+		if (shouldIgnoreOpToken(token)) {
 			return;
 		}
-
-		if (token instanceof ClangSyntaxToken syntaxToken && !isNamespace(syntaxToken)) {
+		if (shouldIgnoreSyntaxTokenHighlight(token)) {
 			return;
 		}
 
@@ -277,26 +277,24 @@ private void toggleMiddleMouseHighlight(FieldLocation location, Field field) {
 		activeMiddleMouse = newMiddleMouse;
 	}
 
-	private boolean isNamespace(ClangSyntaxToken token) {
-
-		String text = token.getText();
-		if (text.length() <= 1) {
+	private boolean shouldIgnoreOpToken(ClangToken token) {
+		if (!(token instanceof ClangOpToken)) {
 			return false;
 		}
 
-		// see if we have a '::' token trailing this token
-		ClangLine line = token.getLineParent();
-		int index = line.indexOfToken(token);
-		for (int i = index + 1; i < line.getNumTokens(); i++) {
-			ClangToken nextToken = line.getToken(i);
-			String nextText = nextToken.getText();
-			if (nextText.isBlank()) {
-				continue;
-			}
+		// users would like to be able to highlight return statements
+		String text = token.toString();
+		return !text.equals("return");
+	}
+
+	private boolean shouldIgnoreSyntaxTokenHighlight(ClangToken token) {
 
-			return nextText.equals("::");
+		if (!(token instanceof ClangSyntaxToken syntaxToken)) {
+			return false;
 		}
-		return false;
+
+		String string = syntaxToken.toString();
+		return ignoredMiddleMouseTokens.contains(string);
 	}
 
 	void addHighlighterHighlights(ClangDecompilerHighlighter highlighter,
@@ -771,7 +769,6 @@ public void buttonPressed(FieldLocation location, Field field, MouseEvent ev) {
 
 		int clickCount = ev.getClickCount();
 		int buttonState = ev.getButton();
-
 		if (buttonState == MouseEvent.BUTTON1) {
 			if (DockingUtils.isControlModifier(ev) && clickCount == 2) {
 				tryToGoto(location, field, ev, true);
diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/ToolUtils.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/ToolUtils.java
index 73872ea8fc5..4af1dfcf081 100644
--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/ToolUtils.java
+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/ToolUtils.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -140,7 +140,7 @@ public static Map<String, ToolTemplate> loadUserTools() {
 		File[] toolFiles = USER_TOOLS_DIR.listFiles(filter);
 		if (toolFiles != null) {
 			for (File toolFile : toolFiles) {
-				ToolTemplate template = ToolUtils.readToolTemplate(toolFile);
+				ToolTemplate template = readToolTemplate(toolFile);
 				if (template != null) {
 					map.put(template.getName(), template);
 				}
@@ -202,9 +202,9 @@ public static void deleteTool(ToolTemplate template) {
 	}
 
 	public static void renameToolTemplate(ToolTemplate toolTemplate, String newName) {
-		ToolUtils.deleteTool(toolTemplate);
+		deleteTool(toolTemplate);
 		toolTemplate.setName(newName);
-		ToolUtils.writeToolTemplate(toolTemplate);
+		writeToolTemplate(toolTemplate);
 	}
 
 	public static boolean writeToolTemplate(ToolTemplate template) {
@@ -232,6 +232,8 @@ public static boolean writeToolTemplate(ToolTemplate template) {
 	}
 
 	public static ToolTemplate readToolTemplate(File toolFile) {
+
+		LOGGER.trace("Loading tool file {}", toolFile);
 		GhidraToolTemplate toolTemplate = null;
 		try (FileInputStream is = new FileInputStream(toolFile)) {
 
@@ -331,7 +333,7 @@ private static boolean skipTool(String toolName) {
 	public static String getUniqueToolName(ToolTemplate template) {
 		String name = template.getName();
 		int n = 1;
-		while (ToolUtils.getToolFile(name).exists()) {
+		while (getToolFile(name).exists()) {
 			name = name + "_" + n++;
 		}
 		return name;
```
-----------------------------------
