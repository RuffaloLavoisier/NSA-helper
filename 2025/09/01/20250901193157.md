# Commit: f71ae463d2046a19b0a19433efca2ad76ca61fb6
## Message: GP-5948 Improved auto vt dupe match's operand equivalency check to account for internal function ref operands.
## Diff:
```
diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
index 3bba2d35220..8512304a456 100644
--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
@@ -89,14 +89,9 @@ public class AutoVersionTrackingTask extends Task {
 	/**
 	 * Constructor for a modal/blocking AutoVersionTrackingTask
 	 *
-	
 	 * @param session The Version Tracking session containing the source, destination, correlator
 	 * and match information needed for this command.
 	 * @param toolOptions the options used when applying matches
-	 * @param minCombinedReferenceCorrelatorScore The minimum score used to limit matches created by
-	 * the Combined Reference Correlator.
-	 * @param minCombinedReferenceCorrelatorConfidence The minimum confidence used to limit matches
-	 * created by the Combined Reference Correlator.
 	 */
 	public AutoVersionTrackingTask(VTSession session, ToolOptions toolOptions) {
 		super(NAME, true, true, true);
@@ -378,12 +373,10 @@ private void doRun(TaskMonitor realMonitor) throws CancelledException {
 	}
 
 	/**
-	 * Method to create implied matches for the existing applied matches in the current session
-	 * @param applyGoodMatches if true, create applied matches for "good" implied matches based on
-	 * votes/conflict information. For all the applied implied matches, rerun the creation of 
-	 * applied matches until no new ones found.
+	 * Method to create implied matches for the existing applied matches in the current session 
 	 * @param applyGoodMatches if true, apply matches if minVotes met and maxConflicts not exceeded 
-	 * for particular match, if false, don't apply any matches
+	 * for particular match, if false, don't apply any matches. For all the applied implied matches, 
+	 * rerun the creation of applied matches until no new ones found.
 	 * @param minVotes minimum votes needed to apply a match
 	 * @param maxConflicts maximum conflicts allowed to apply a match
 	 * @param monitor the task monitor
@@ -646,7 +639,7 @@ private boolean applyMatches(Collection<VTMatch> matches, TaskMonitor monitor)
 				continue;
 			}
 
-			if (hasAcceptedRelatedAssociation(association, monitor)) {
+			if (hasAcceptedRelatedAssociation(association)) {
 				Msg.warn(AutoVersionTrackingTask.class,
 					"This association has a related association with an accepted match so cannot " +
 						"make this association accepted which would try to block the already accepted " +
@@ -702,12 +695,11 @@ private static boolean tryToSetAccepted(VTAssociation association) {
 	 * Method to test whether any related associations (ie associations with either the same source 
 	 * or the same destination address) have already been accepted
 	 * @param association the given association (src/dest match pair)
-	 * @param taskMonitor the task monitor
 	 * @return true if any related associations have already been accepted, false otherwise
 	 * @throws CancelledException if cancelled
 	 */
-	private boolean hasAcceptedRelatedAssociation(VTAssociation association,
-			TaskMonitor taskMonitor) throws CancelledException {
+	private boolean hasAcceptedRelatedAssociation(VTAssociation association)
+			throws CancelledException {
 
 		VTAssociationManager vtAssocManager = session.getAssociationManager();
 
@@ -745,7 +737,7 @@ private boolean hasAcceptedRelatedAssociation(VTAssociation association,
 	 * function pair association or it would have been identified as a unique match by the exact 
 	 * unique function instruction correltor. This method attempts to find unique matches from 
 	 * within the related subsets by comparing operand information. 
-	 * @param matches The set of matches from the duplicate function instruction correlator
+	 * @param matchSet The set of matches from the duplicate function instruction correlator
 	 * @param monitor Allows user to cancel
 	 * @return true if there are any markup errors, false if no markup errors
 	 * @throws CancelledException if cancelled
@@ -1169,7 +1161,8 @@ private boolean isEquivalentAddressOperand(Object op1, Object op2) {
 	 * Method to check to see if both addresses have functions at them or the same data type at them
 	 * @param addr1 the first Address
 	 * @param addr2 the second Address
-	 * @return
+	 * @return true if same operand type (ie both functions, both same data type, same internal 
+	 * function reference
 	 */
 	private boolean isSameOperandType(Address addr1, Address addr2) {
 
@@ -1179,9 +1172,22 @@ private boolean isSameOperandType(Address addr1, Address addr2) {
 			if (function2 != null) {
 				return true;
 			}
-			else {
-				return false;
+			return false;
+		}
+
+		// are both references to same offset in the mapped functions
+		function1 = sourceProgram.getFunctionManager().getFunctionContaining(addr1);
+		if (function1 != null) {
+			Function function2 =
+				destinationProgram.getFunctionManager().getFunctionContaining(addr2);
+			if (function2 != null) {
+				long offsetInFunction1 = getOffsetInFunction(function1, addr1);
+				long offsetInFunction2 = getOffsetInFunction(function2, addr2);
+				if (offsetInFunction1 == offsetInFunction2) {
+					return true;
+				}
 			}
+			return false;
 		}
 
 		Data data1 = sourceProgram.getListing().getDataAt(addr1);
@@ -1275,9 +1281,7 @@ private Map<Long, Map<Integer, Object>> mapFunctionScalarAndAddressOperands(
 			// get offset from top of function to use in function to operandMap map
 			// can be positive or negative offset (positive means instruction address is after 
 			// the entry address, negative means instruction address is before entry address)
-			Long entryOffset = function.getEntryPoint().getOffset();
-			Long instOffset = inst.getAddress().getOffset();
-			Long offset = instOffset - entryOffset;
+			long offset = getOffsetInFunction(function, inst.getAddress());
 
 			offsetToOperandsMap.put(offset, map);
 		}
@@ -1289,6 +1293,15 @@ private Map<Long, Map<Integer, Object>> mapFunctionScalarAndAddressOperands(
 		return offsetToOperandsMap;
 	}
 
+	private long getOffsetInFunction(Function function, Address addressInFunction) {
+
+		long entryOffset = function.getEntryPoint().getOffset();
+		long addrOffset = addressInFunction.getOffset();
+		long offset = addrOffset - entryOffset;
+
+		return offset;
+	}
+
 	/**
 	 * Method to create offset/operand mapping for each function in match set
 	 * if more than one identical offset/operand mapping in src or dest piles then remove
@@ -1343,7 +1356,7 @@ private boolean tryToAcceptMatchAndApplyMarkup(VTMatch match, TaskMonitor monito
 		// skip already accepted or blocked matches
 		if (association.getStatus() == VTAssociationStatus.AVAILABLE) {
 
-			if (hasAcceptedRelatedAssociation(association, monitor)) {
+			if (hasAcceptedRelatedAssociation(association)) {
 				Msg.warn(AutoVersionTrackingTask.class,
 					"This association has a related association with an accepted match so cannot " +
 						"make this association accepted which would try to block the already accepted " +
```
-----------------------------------
