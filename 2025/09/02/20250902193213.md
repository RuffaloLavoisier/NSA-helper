# Commit: 7a4100d54bff88530f11b577d4d2547d57630288
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
index 3bba2d35220..8512304a456 100644
--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
@@ -89,14 +89,9 @@ public class AutoVersionTrackingTask extends Task {
 	/**
 	 * Constructor for a modal/blocking AutoVersionTrackingTask
 	 *
-	
 	 * @param session The Version Tracking session containing the source, destination, correlator
 	 * and match information needed for this command.
 	 * @param toolOptions the options used when applying matches
-	 * @param minCombinedReferenceCorrelatorScore The minimum score used to limit matches created by
-	 * the Combined Reference Correlator.
-	 * @param minCombinedReferenceCorrelatorConfidence The minimum confidence used to limit matches
-	 * created by the Combined Reference Correlator.
 	 */
 	public AutoVersionTrackingTask(VTSession session, ToolOptions toolOptions) {
 		super(NAME, true, true, true);
@@ -378,12 +373,10 @@ private void doRun(TaskMonitor realMonitor) throws CancelledException {
 	}
 
 	/**
-	 * Method to create implied matches for the existing applied matches in the current session
-	 * @param applyGoodMatches if true, create applied matches for "good" implied matches based on
-	 * votes/conflict information. For all the applied implied matches, rerun the creation of 
-	 * applied matches until no new ones found.
+	 * Method to create implied matches for the existing applied matches in the current session 
 	 * @param applyGoodMatches if true, apply matches if minVotes met and maxConflicts not exceeded 
-	 * for particular match, if false, don't apply any matches
+	 * for particular match, if false, don't apply any matches. For all the applied implied matches, 
+	 * rerun the creation of applied matches until no new ones found.
 	 * @param minVotes minimum votes needed to apply a match
 	 * @param maxConflicts maximum conflicts allowed to apply a match
 	 * @param monitor the task monitor
@@ -646,7 +639,7 @@ private boolean applyMatches(Collection<VTMatch> matches, TaskMonitor monitor)
 				continue;
 			}
 
-			if (hasAcceptedRelatedAssociation(association, monitor)) {
+			if (hasAcceptedRelatedAssociation(association)) {
 				Msg.warn(AutoVersionTrackingTask.class,
 					"This association has a related association with an accepted match so cannot " +
 						"make this association accepted which would try to block the already accepted " +
@@ -702,12 +695,11 @@ private static boolean tryToSetAccepted(VTAssociation association) {
 	 * Method to test whether any related associations (ie associations with either the same source 
 	 * or the same destination address) have already been accepted
 	 * @param association the given association (src/dest match pair)
-	 * @param taskMonitor the task monitor
 	 * @return true if any related associations have already been accepted, false otherwise
 	 * @throws CancelledException if cancelled
 	 */
-	private boolean hasAcceptedRelatedAssociation(VTAssociation association,
-			TaskMonitor taskMonitor) throws CancelledException {
+	private boolean hasAcceptedRelatedAssociation(VTAssociation association)
+			throws CancelledException {
 
 		VTAssociationManager vtAssocManager = session.getAssociationManager();
 
@@ -745,7 +737,7 @@ private boolean hasAcceptedRelatedAssociation(VTAssociation association,
 	 * function pair association or it would have been identified as a unique match by the exact 
 	 * unique function instruction correltor. This method attempts to find unique matches from 
 	 * within the related subsets by comparing operand information. 
-	 * @param matches The set of matches from the duplicate function instruction correlator
+	 * @param matchSet The set of matches from the duplicate function instruction correlator
 	 * @param monitor Allows user to cancel
 	 * @return true if there are any markup errors, false if no markup errors
 	 * @throws CancelledException if cancelled
@@ -1169,7 +1161,8 @@ private boolean isEquivalentAddressOperand(Object op1, Object op2) {
 	 * Method to check to see if both addresses have functions at them or the same data type at them
 	 * @param addr1 the first Address
 	 * @param addr2 the second Address
-	 * @return
+	 * @return true if same operand type (ie both functions, both same data type, same internal 
+	 * function reference
 	 */
 	private boolean isSameOperandType(Address addr1, Address addr2) {
 
@@ -1179,9 +1172,22 @@ private boolean isSameOperandType(Address addr1, Address addr2) {
 			if (function2 != null) {
 				return true;
 			}
-			else {
-				return false;
+			return false;
+		}
+
+		// are both references to same offset in the mapped functions
+		function1 = sourceProgram.getFunctionManager().getFunctionContaining(addr1);
+		if (function1 != null) {
+			Function function2 =
+				destinationProgram.getFunctionManager().getFunctionContaining(addr2);
+			if (function2 != null) {
+				long offsetInFunction1 = getOffsetInFunction(function1, addr1);
+				long offsetInFunction2 = getOffsetInFunction(function2, addr2);
+				if (offsetInFunction1 == offsetInFunction2) {
+					return true;
+				}
 			}
+			return false;
 		}
 
 		Data data1 = sourceProgram.getListing().getDataAt(addr1);
@@ -1275,9 +1281,7 @@ private Map<Long, Map<Integer, Object>> mapFunctionScalarAndAddressOperands(
 			// get offset from top of function to use in function to operandMap map
 			// can be positive or negative offset (positive means instruction address is after 
 			// the entry address, negative means instruction address is before entry address)
-			Long entryOffset = function.getEntryPoint().getOffset();
-			Long instOffset = inst.getAddress().getOffset();
-			Long offset = instOffset - entryOffset;
+			long offset = getOffsetInFunction(function, inst.getAddress());
 
 			offsetToOperandsMap.put(offset, map);
 		}
@@ -1289,6 +1293,15 @@ private Map<Long, Map<Integer, Object>> mapFunctionScalarAndAddressOperands(
 		return offsetToOperandsMap;
 	}
 
+	private long getOffsetInFunction(Function function, Address addressInFunction) {
+
+		long entryOffset = function.getEntryPoint().getOffset();
+		long addrOffset = addressInFunction.getOffset();
+		long offset = addrOffset - entryOffset;
+
+		return offset;
+	}
+
 	/**
 	 * Method to create offset/operand mapping for each function in match set
 	 * if more than one identical offset/operand mapping in src or dest piles then remove
@@ -1343,7 +1356,7 @@ private boolean tryToAcceptMatchAndApplyMarkup(VTMatch match, TaskMonitor monito
 		// skip already accepted or blocked matches
 		if (association.getStatus() == VTAssociationStatus.AVAILABLE) {
 
-			if (hasAcceptedRelatedAssociation(association, monitor)) {
+			if (hasAcceptedRelatedAssociation(association)) {
 				Msg.warn(AutoVersionTrackingTask.class,
 					"This association has a related association with an accepted match so cannot " +
 						"make this association accepted which would try to block the already accepted " +
diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index 602f675cbdb..d216d902dcd 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -4894,13 +4894,13 @@ define pcodeop verw;
 #  of this instruction is always 64-bits and is always in memory".  Is it an error that the "Instruction" entry in the 
 #  box giving the definition does not specify m64?
 :VMPTRST m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=7 ) ... & m64  { vmptrst(m64); }
-:VMREAD rm32, Reg32  is vexMode=0 & opsize=1 & byte=0x0f; byte=0x78; rm32 & check_rm32_dest ... & Reg32 ...     { rm32 = vmread(Reg32); build check_rm32_dest; }
+:VMREAD rm32, Reg32  is $(PRE_NO) & vexMode=0 & opsize=1 & byte=0x0f; byte=0x78; rm32 & check_rm32_dest ... & Reg32 ...     { rm32 = vmread(Reg32); build check_rm32_dest; }
 @ifdef IA64
-:VMREAD rm64, Reg64  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x78; rm64 & Reg64 ...     { rm64 = vmread(Reg64); }
+:VMREAD rm64, Reg64  is $(LONGMODE_ON) & $(PRE_NO) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x78; rm64 & Reg64 ...     { rm64 = vmread(Reg64); }
 @endif
-:VMWRITE Reg32, rm32 is vexMode=0 & opsize=1 & byte=0x0f; byte=0x79; rm32 & Reg32 ... & check_Reg32_dest ...   { vmwrite(rm32,Reg32); build check_Reg32_dest; }
+:VMWRITE Reg32, rm32 is $(PRE_NO) & vexMode=0 & opsize=1 & byte=0x0f; byte=0x79; rm32 & Reg32 ... & check_Reg32_dest ...   { vmwrite(rm32,Reg32); build check_Reg32_dest; }
 @ifdef IA64
-:VMWRITE Reg64, rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x79; rm64 & Reg64 ...    { vmwrite(rm64,Reg64); }
+:VMWRITE Reg64, rm64 is $(LONGMODE_ON) & $(PRE_NO) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x79; rm64 & Reg64 ...    { vmwrite(rm64,Reg64); }
 @endif
 :VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4                           { vmxoff(); }
 # NB: this opcode is incorrect in the 2005 edition of the Intel manual. Opcode below is taken from the 2008 version.
@@ -10457,4 +10457,46 @@ define pcodeop PackedSwapDWords;
 define pcodeop MaskedMoveQWord;
 :MASKMOVQ            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF7; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = MaskedMoveQWord(mmxreg1, mmxreg2); }
 
+
+####
+####  SSE4a instructions
+####
+
+bitLen: val is imm8 [ val=imm8 & 0x3f; ] { export *[const]:1 val; }
+lsbOffset: val is imm8 [ val=imm8 & 0x3f; ] { export *[const]:1 val; }
+:EXTRQ XmmReg2, bitLen, lsbOffset is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x78; reg_opcode=0 & XmmReg2; bitLen; lsbOffset {
+	local mask:16 = ((1 << bitLen) - 1) << lsbOffset;
+	local val:16 = (XmmReg2 & mask) >> lsbOffset;
+	XmmReg2 = val;
+}
+
+:EXTRQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x79; XmmReg1 & XmmReg2 {
+	local len = XmmReg2[0,6];
+	local offs = XmmReg2[6,6];
+	local mask = ((1 << len) - 1) << offs;
+	local val = (XmmReg1 & mask) >> offs;
+	XmmReg1 = val;
+}
+
+:INSERTQ XmmReg1, XmmReg2, bitLen, lsbOffset  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x78; XmmReg1 & XmmReg2; bitLen; lsbOffset {
+	local mask:16 = ((1 << bitLen) - 1) << lsbOffset;
+	local val:16 = (zext(XmmReg2[0,64]) & ((1 << bitLen) - 1));
+	XmmReg1 = (XmmReg1 & ~zext(mask)) | (zext(val) << lsbOffset);
+}
+
+:INSERTQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x79; XmmReg1 & XmmReg2 {
+	local len = XmmReg2[64,6];
+	local offs = XmmReg2[72,6];
+	local mask:16 = ((1 << len) - 1) << offs;
+	local val:16 = (zext(XmmReg2[0,64]) & ((1 << len) - 1));
+	XmmReg1 = (XmmReg1 & ~zext(mask)) | (zext(val) << offs);
+}
+
+:MOVNTSD m64, XmmReg1 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2B; XmmReg1 ... & m64 {
+	m64 = XmmReg1[0,64];
+}
+
+:MOVNTSS m32, XmmReg1 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2B; XmmReg1 ... & m32 {
+	m32 = XmmReg1[0,32];
+}
 } # end with : lockprefx=0
```
-----------------------------------
