# Commit: a893955b03064f83490b8f76d60e090f4a2b3539
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Features/Base/data/PEFunctionsThatDoNotReturn b/Ghidra/Features/Base/data/PEFunctionsThatDoNotReturn
index 4ef288a838d..115bf6ff95c 100644
--- a/Ghidra/Features/Base/data/PEFunctionsThatDoNotReturn
+++ b/Ghidra/Features/Base/data/PEFunctionsThatDoNotReturn
@@ -18,3 +18,11 @@ longjmp
 quick_exit
 RpcRaiseException
 terminate
+___raise_securityfailure
+___report_rangecheckfailure
+?_Xregex_error@std@@YAXW4error_type@regex_constant@1@@Z
+?_Xbad_alloc@std@@YAXXZ
+?_Xlength_error@std@@YAXPBD@Z
+?_Xout_of_range@std@@YAXPBD@Z
+?_Xbad_function_call@std@@YAXXZ
+?terminate@@YAXXZ
diff --git a/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartAnalyzer.java b/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartAnalyzer.java
index 554642c0a4f..c02e18321e0 100644
--- a/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartAnalyzer.java
+++ b/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartAnalyzer.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -207,9 +207,10 @@ public class FunctionStartAction implements MatchAction {
 		private int validCodeMin = NO_VALID_INSTRUCTIONS_REQUIRED;
 		private int validCodeMax = VALID_INSTRUCTIONS_NO_MAX;
 		private String label = null;
-		private boolean isThunk = false;  // true if this function should be turned into a thunk
-		private boolean noreturn = false; // true to set function non-returning
-		boolean validFunction = false;    // must be defined at a function
+		private boolean isThunk = false;    // true if this function should be turned into a thunk
+		private boolean noreturn = false;   // true to set function non-returning
+		private String sectionName = null;  // required section name
+		boolean validFunction = false;      // must be defined at a function
 		private boolean contiguous = true;  // require validcode instructions be contiguous
 
 		@Override
@@ -225,6 +226,14 @@ public void apply(Program program, Address addr, Match match) {
 		}
 
 		protected boolean checkPreRequisites(Program program, Address addr) {
+			// check required section name
+			if (sectionName != null) {
+				MemoryBlock block = program.getMemory().getBlock(addr);
+				if (block == null || !block.getName().matches(sectionName)) {
+					return false;
+				}
+			}
+			
 			/**
 			 * If the match's mark point occurs in undefined data, schedule disassembly
 			 * and a function start at that address. If the match's mark point occurs at an instruction, but that
@@ -641,6 +650,10 @@ else if (fallThruOnlyStr.equalsIgnoreCase("true")) {
 						isThunk = true;
 						break;
 						
+					case "section":
+						sectionName = attrValue;
+						break;
+						
 					case "noreturn":
 						noreturn = true;
 						break;
@@ -816,7 +829,14 @@ public void postMatchApply(MatchAction[] actions, Address addr) {
 
 		AutoAnalysisManager analysisManager = AutoAnalysisManager.getAnalysisManager(program);
 		if (!disassemResult.isEmpty()) {
-			analysisManager.disassemble(disassemResult, AnalysisPriority.DISASSEMBLY);
+			// disassemble known function starts now
+			AddressSet doNowDisassembly = disassemResult.intersect(funcResult);
+			// this will disassemble at this analyzers priority
+			analysisManager.disassemble(doNowDisassembly);
+			
+			// delay disassemble of possible function starts
+			AddressSet delayedDisassembly = disassemResult.subtract(funcResult);
+			analysisManager.disassemble(delayedDisassembly, AnalysisPriority.DISASSEMBLY);
 		}
 		analysisManager.setProtectedLocations(codeLocations);
 
diff --git a/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartPreFuncAnalyzer.java b/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartPreFuncAnalyzer.java
index 2c40ab2babc..024d279e691 100644
--- a/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartPreFuncAnalyzer.java
+++ b/Ghidra/Features/BytePatterns/src/main/java/ghidra/app/analyzers/FunctionStartPreFuncAnalyzer.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -44,7 +44,7 @@ public ProgramDecisionTree getPatternDecisionTree() {
 	public FunctionStartPreFuncAnalyzer() {
 		super(FUNCTION_START_PRE_SEARCH, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
 		
-		setPriority(AnalysisPriority.BLOCK_ANALYSIS.after());
+		setPriority(AnalysisPriority.BLOCK_ANALYSIS.before());
 		setDefaultEnablement(true);
 		setSupportsOneTimeAnalysis();
 	}
diff --git a/Ghidra/Processors/x86/certification.manifest b/Ghidra/Processors/x86/certification.manifest
index 8d64f3e60b9..1b6dd3dfb3d 100644
--- a/Ghidra/Processors/x86/certification.manifest
+++ b/Ghidra/Processors/x86/certification.manifest
@@ -92,5 +92,6 @@ data/patterns/x86-64gcc_patterns.xml||GHIDRA||||END|
 data/patterns/x86-64win_patterns.xml||GHIDRA||||END|
 data/patterns/x86delphi_patterns.xml||GHIDRA||||END|
 data/patterns/x86gcc_patterns.xml||GHIDRA||||END|
+data/patterns/x86gcc_prepatterns.xml||GHIDRA||||END|
 data/patterns/x86win_patterns.xml||GHIDRA||||END|
 data/patterns/x86win_prepatterns.xml||GHIDRA||||END|
diff --git a/Ghidra/Processors/x86/data/patterns/prepatternconstraints.xml b/Ghidra/Processors/x86/data/patterns/prepatternconstraints.xml
index ea92c2ab1c8..51d98bbe1ed 100644
--- a/Ghidra/Processors/x86/data/patterns/prepatternconstraints.xml
+++ b/Ghidra/Processors/x86/data/patterns/prepatternconstraints.xml
@@ -7,6 +7,15 @@
   	<compiler id="borlandcpp">
   	  <patternfile>x86win_prepatterns.xml</patternfile>
   	</compiler>
+  	<compiler id="gcc">
+  	  <patternfile>x86gcc_prepatterns.xml</patternfile>
+  	</compiler>
   </language>
-
+  
+  <language id="x86:LE:64:default">
+  	<compiler id="gcc">
+  	  <patternfile>x86gcc_prepatterns.xml</patternfile>
+  	</compiler>
+  </language>
+  
 </patternconstraints>
diff --git a/Ghidra/Processors/x86/data/patterns/x86gcc_prepatterns.xml b/Ghidra/Processors/x86/data/patterns/x86gcc_prepatterns.xml
new file mode 100644
index 00000000000..190acf223f3
--- /dev/null
+++ b/Ghidra/Processors/x86/data/patterns/x86gcc_prepatterns.xml
@@ -0,0 +1,20 @@
+<patternlist>
+  
+  <pattern>
+     <data>
+        0xff25........   <!-- jmp -->
+        0x68......00     <!-- push -->
+        0xe9......ff     <!-- jmp -addr -->
+     </data> <!-- .plt thunk -->
+     <funcstart thunk="true" section=".plt"/>
+  </pattern>
+  
+  <pattern>
+     <data>
+        0xf3 0x0f 0x1e 0x1a        <!-- ENDBR64 -->
+        0xf2 0xff 0x25 .. .. .. .. <!-- jmp -->
+     </data> <!-- .plt thunk -->
+     <funcstart thunk="true" section=".plt"/>
+  </pattern>
+
+</patternlist>
```
-----------------------------------
