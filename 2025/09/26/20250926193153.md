# Commit: a3bd708160cf8c4282d10b51b14acee6b86924c3
## Message: GP-6008 Changed SourceType examination to base upon priorty instead of specific value equality when appropriate
## Diff:
```
diff --git a/Ghidra/Features/Base/ghidra_scripts/AutoRenameSimpleLabels.java b/Ghidra/Features/Base/ghidra_scripts/AutoRenameSimpleLabels.java
index 376453b6a47..09fd987e5f9 100644
--- a/Ghidra/Features/Base/ghidra_scripts/AutoRenameSimpleLabels.java
+++ b/Ghidra/Features/Base/ghidra_scripts/AutoRenameSimpleLabels.java
@@ -43,8 +43,7 @@
 public class AutoRenameSimpleLabels extends GhidraScript {
 
 	boolean isDefaultName(Symbol symbol) {
-		return symbol.getSource() == SourceType.DEFAULT ||
-			symbol.getSource() == SourceType.ANALYSIS;
+		return symbol.getSource().isLowerOrEqualPriorityThan(SourceType.ANALYSIS);
 	}
 
 	@Override
@@ -61,6 +60,9 @@ public void run() throws Exception {
 			//get this instruction's info
 			Symbol s = iter.next();
 			Address startAddr = s.getAddress();
+			if (!startAddr.isLoadedMemoryAddress()) {
+				continue;
+			}
 
 			// read the instruction type and operand
 			Instruction inst = getInstructionAt(startAddr);
diff --git a/Ghidra/Features/Base/ghidra_scripts/LabelDataScript.java b/Ghidra/Features/Base/ghidra_scripts/LabelDataScript.java
index 3be8fce5599..a2bf9b8b8d7 100644
--- a/Ghidra/Features/Base/ghidra_scripts/LabelDataScript.java
+++ b/Ghidra/Features/Base/ghidra_scripts/LabelDataScript.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,13 +43,12 @@ public void run() throws Exception {
 				(!data.getBaseDataType().getName().toLowerCase().contains("string")) &&
 				(!data.getBaseDataType().getName().toLowerCase().contains("unicode"))) {
 				Symbol sym = symbolTable.getPrimarySymbol(data.getMinAddress());
-				if ((sym != null) && ((sym.getSource() == SourceType.DEFAULT) ||
-					(sym.getSource() == SourceType.ANALYSIS))) {
-					String newLabel =
-						data.getDefaultLabelPrefix(null) + "_" +
-							SymbolUtilities.replaceInvalidChars(
-								data.getDefaultValueRepresentation(), false) +
-							"_" + data.getMinAddress().toString();
+				if (sym != null &&
+					sym.getSource().isLowerOrEqualPriorityThan(SourceType.ANALYSIS)) {
+					String newLabel = data.getDefaultLabelPrefix(null) +
+						"_" + SymbolUtilities
+								.replaceInvalidChars(data.getDefaultValueRepresentation(), false) +
+						"_" + data.getMinAddress().toString();
 					Symbol newSym = symbolTable.createLabel(data.getMinAddress(), newLabel,
 						SourceType.ANALYSIS);
 					println(data.getMinAddress().toString() + " " + newLabel);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/NewFunctionStackAnalysisCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/NewFunctionStackAnalysisCmd.java
index dc6430d6709..48923d0106b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/NewFunctionStackAnalysisCmd.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/NewFunctionStackAnalysisCmd.java
@@ -44,7 +44,7 @@ public class NewFunctionStackAnalysisCmd extends BackgroundCommand<Program> {
 	private static final int MAX_LOCAL_OFFSET = -(64 * 1024);  // max size of local reference space
 
 	private final static String X86_NAME = "x86";
-	
+
 	private boolean dontCreateNewVariables = false;
 
 	private final boolean forceProcessing;
@@ -55,7 +55,7 @@ public class NewFunctionStackAnalysisCmd extends BackgroundCommand<Program> {
 	private Program program;
 	private Register stackReg;
 	private int purge = 0;
-	
+
 	private boolean isX86 = false;
 
 	static String DEFAULT_FUNCTION_COMMENT = " FUNCTION";
@@ -105,7 +105,7 @@ public NewFunctionStackAnalysisCmd(AddressSetView entries, boolean createStackPa
 	@Override
 	public boolean applyTo(Program p, TaskMonitor monitor) {
 		program = p;
-		
+
 		isX86 = checkForX86(p);
 
 		int count = 0;
@@ -145,8 +145,10 @@ public boolean applyTo(Program p, TaskMonitor monitor) {
 	}
 
 	private boolean checkForX86(Program p) {
-		return program.getLanguage().getProcessor().equals(
-			Processor.findOrPossiblyCreateProcessor(X86_NAME)) && program.getDefaultPointerSize() <= 32;
+		return program.getLanguage()
+				.getProcessor()
+				.equals(Processor.findOrPossiblyCreateProcessor(X86_NAME)) &&
+			program.getDefaultPointerSize() <= 32;
 	}
 
 	/**
@@ -221,7 +223,7 @@ private boolean analyzeFunction(Function f, TaskMonitor monitor) throws Cancelle
 
 	private boolean isProtectedVariable(Variable var) {
 		return !var.isStackVariable() || !Undefined.isUndefined(var.getDataType()) ||
-			var.getSource() == SourceType.IMPORTED || var.getSource() == SourceType.USER_DEFINED ||
+			var.getSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED) ||
 			var.isCompoundVariable();
 	}
 
@@ -339,9 +341,11 @@ private void checkForStackOffset(VarnodeContext context, Instruction instr,
 							return;
 						}
 					}
-					long extendedOffset = extendOffset(address.getOffset(), stackReg.getBitLength());
-					
-					defineFuncVariable(symEval, func, instr, opIndex, (int) extendedOffset, sortedVariables);
+					long extendedOffset =
+						extendOffset(address.getOffset(), stackReg.getBitLength());
+
+					defineFuncVariable(symEval, func, instr, opIndex, (int) extendedOffset,
+						sortedVariables);
 				}
 			}
 
@@ -634,8 +638,8 @@ else if (obj[i] instanceof Scalar) {
 //		return true;
 //	}
 
-	private void defineFuncVariable(SymbolicPropogator symEval, Function func, Instruction instr, int opIndex, int stackOffset,
-			List<Variable> sortedVariables) {
+	private void defineFuncVariable(SymbolicPropogator symEval, Function func, Instruction instr,
+			int opIndex, int stackOffset, List<Variable> sortedVariables) {
 
 		ReferenceManager refMgr = program.getReferenceManager();
 		int refSize = getRefSize(symEval, instr, opIndex);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AbstractDemanglerAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AbstractDemanglerAnalyzer.java
index 70d3dae2a55..59c76223d16 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AbstractDemanglerAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AbstractDemanglerAnalyzer.java
@@ -224,7 +224,7 @@ else if (!parentNamespace.isGlobal()) {
 		if (symbol.getSymbolType() == SymbolType.FUNCTION) {
 			Function function = (Function) symbol.getObject();
 			if (!function.isThunk() &&
-				function.getSignatureSource().isHigherPriorityThan(SourceType.ANALYSIS)) {
+				function.getSignatureSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 				return true;
 			}
 		}
@@ -297,8 +297,7 @@ protected void apply(MangledContext mangledContext, DemangledObject demangled, M
 				return;
 			}
 			String errorString = demangled.getErrorMessage();
-			logApplyErrorMessage(log, demangled, mangledContext.getAddress(), null,
-				errorString);
+			logApplyErrorMessage(log, demangled, mangledContext.getAddress(), null, errorString);
 		}
 		catch (Exception e) {
 			logApplyErrorMessage(log, demangled, mangledContext.getAddress(), e, null);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationContextEvaluator.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationContextEvaluator.java
index d3e345d530c..b06d87ed6ca 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationContextEvaluator.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationContextEvaluator.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -427,7 +427,7 @@ private void createFunctionApplySignature(AutoAnalysisManager aMgr, Program prog
 			}
 
 			SourceType mostTrusted = getMostTrustedParameterSource(func);
-			if (SourceType.ANALYSIS.isLowerPriorityThan(mostTrusted)) {
+			if (mostTrusted.isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 				return;
 			}
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
index 7d3ca7f0014..2d31c9333e2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
@@ -225,6 +225,8 @@ private void markupGoFunctions(TaskMonitor monitor) throws IOException, Cancelle
 				continue;
 			}
 
+			// NOTE: DWARF may have applied function signature with IMPORTED source type but
+			// this analyzer must apply more details
 			Function func = markupSession.createFunctionIfMissing(funcname, funcns, funcAddr);
 			if (func == null ||
 				func.getSignatureSource().isHigherPriorityThan(SourceType.IMPORTED)) {
@@ -503,8 +505,8 @@ private Address createFakeContextMemory(long len) {
 		Address mbStart = max.subtract(offset_from_eom + len - 1);
 		MemoryBlock newMB =
 			MemoryBlockUtils.createUninitializedBlock(program, false, "ARTIFICAL_GOLANG_CONTEXT",
-				mbStart, len, "Artifical memory block created to hold Go context data types",
-				null, true, true, false, null);
+				mbStart, len, "Artifical memory block created to hold Go context data types", null,
+				true, true, false, null);
 		newMB.setArtificial(true);
 		return newMB.getStart();
 	}
@@ -1034,7 +1036,6 @@ record CallSiteInfo(Reference ref, Function callingFunc, Function calledFunc,
 				Register register, java.util.function.Function<GoType, DataType> returnTypeMapper) {
 		}
 
-
 		private GoRttiMapper goBinary;
 		private Program program;
 		private MarkupSession markupSession;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/PefAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/PefAnalyzer.java
index 82862fc7579..125e13fd2a5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/PefAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/PefAnalyzer.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -109,8 +109,9 @@ private AddressSet getInstructionSet(Program program, AddressSetView functionSet
 			}
 			Function function = functions.next();
 			try {
-				program.getProgramContext().setRegisterValue(function.getEntryPoint(),
-					function.getEntryPoint(), regVal);
+				program.getProgramContext()
+						.setRegisterValue(function.getEntryPoint(), function.getEntryPoint(),
+							regVal);
 			}
 			catch (ContextChangeException e) {
 				// should never happen when changing r2 register
@@ -149,11 +150,8 @@ private void markupGlueCode(Listing listing, SymbolTable symbolTable, Instructio
 			return;
 		}
 		Function function = listing.getFunctionContaining(instruction.getMinAddress());
-		if (function == null) {
-			return;
-		}
-		if (function.getSymbol().getSource() == SourceType.IMPORTED ||
-			function.getSymbol().getSource() == SourceType.USER_DEFINED) {
+		if (function == null ||
+			function.getSymbol().getSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 			return;
 		}
 		Symbol symbol = symbolTable.getPrimarySymbol(symbolAddress);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearFlowAndRepairCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearFlowAndRepairCmd.java
index 8b0a1d3a29d..eedb4721a89 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearFlowAndRepairCmd.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearFlowAndRepairCmd.java
@@ -717,11 +717,9 @@ private AddressSetView findInstructionFlow(Program program, Address firstAddr,
 						continue; // do not include data
 					}
 					Symbol s = symbolTable.getPrimarySymbol(blockAddr);
-					if (s != null && s.getSymbolType() == SymbolType.FUNCTION) {
-						SourceType source = s.getSource();
-						if (source == SourceType.USER_DEFINED || source == SourceType.IMPORTED) {
-							continue; // keep imported or user-defined function
-						}
+					if (s != null && s.getSymbolType() == SymbolType.FUNCTION &&
+						s.getSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
+						continue;
 						// TODO: GP-5872 Clearing thunks explicitly created by loader or pattern
 						// generally have default SourceType and may not have references
 						// to them.  We need to prevent these thunks from getting cleared.
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java
index b0826593fb6..74827196a16 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -378,8 +378,7 @@ protected boolean isAlreadyDemangled(Program program, Address address) {
 		if (f != null && f.getSymbol().getSource() == SourceType.USER_DEFINED) {
 			return true;
 		}
-		if (f == null || f.getSignatureSource() == SourceType.DEFAULT ||
-			f.getSignatureSource() == SourceType.ANALYSIS) {
+		if (f == null || f.getSignatureSource().isLowerOrEqualPriorityThan(SourceType.ANALYSIS)) {
 			return false;
 		}
 		return super.isAlreadyDemangled(program, address);
@@ -809,7 +808,7 @@ protected boolean isDefinedFunctionDataTypes(Function func) {
 				continue;
 			}
 			// if the parameters source is higher than
-			if (parameter.getSource().isHigherPriorityThan(SourceType.ANALYSIS)) {
+			if (parameter.getSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 				return true;
 			}
 		}
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerParameterIdCmd.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerParameterIdCmd.java
index f418edefc70..8c7119cbd0c 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerParameterIdCmd.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerParameterIdCmd.java
@@ -150,12 +150,12 @@ private void resetFunctionSourceTypes(Set<Address> set, TaskMonitor monitor)
 				// since decompile could fail and leave the source types changed.
 				Parameter retParam = func.getReturn();
 				if (retParam != null) {
-					if (!retParam.getSource().isHigherPriorityThan(sourceTypeClearLevel)) {
+					if (retParam.getSource().isLowerOrEqualPriorityThan(sourceTypeClearLevel)) {
 						func.setReturn(retParam.getDataType(), retParam.getVariableStorage(),
 							SourceType.DEFAULT);
 					}
 				}
-				if (!func.getSignatureSource().isHigherPriorityThan(sourceTypeClearLevel)) {
+				if (func.getSignatureSource().isLowerOrEqualPriorityThan(sourceTypeClearLevel)) {
 					func.setSignatureSource(SourceType.DEFAULT);
 				}
 			}
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java
index 895e7f0b235..158125d8670 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,7 +36,7 @@
 public class OverridePrototypeAction extends AbstractDecompilerAction {
 
 	public OverridePrototypeAction() {
-		super("Override Signature"); 
+		super("Override Signature");
 		setHelpLocation(new HelpLocation(HelpTopics.DECOMPILER, "ActionOverrideSignature"));
 		setPopupMenuData(new MenuData(new String[] { "Override Signature" }, "Decompile"));
 	}
@@ -174,11 +174,9 @@ private String generateSignature(PcodeOp op, String name, Function calledfunc) {
 		// for the initial signature.  HighFunction does not make it easy to grab 
 		// existing override prototype
 
-		if (calledfunc != null) {
-			SourceType signatureSource = calledfunc.getSignatureSource();
-			if (signatureSource == SourceType.DEFAULT || signatureSource == SourceType.ANALYSIS) {
-				calledfunc = null; // ignore
-			}
+		if (calledfunc != null &&
+			calledfunc.getSignatureSource().isLowerOrEqualPriorityThan(SourceType.ANALYSIS)) {
+			calledfunc = null; // ignore
 		}
 
 		StringBuffer buf = new StringBuffer();
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompiler/validator/DecompilerParameterIDValidator.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompiler/validator/DecompilerParameterIDValidator.java
index 2726f45207b..98e44bfed80 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompiler/validator/DecompilerParameterIDValidator.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompiler/validator/DecompilerParameterIDValidator.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -63,6 +63,8 @@ private static int checkNumberAnalyzed(Program prog, TaskMonitor monitor) {
 
 			if (inst != null) {
 				final SourceType signatureSource = func.getSignatureSource();
+				// TODO: There is a misconception that ANALYSIS source type can be used to 
+				// determine if Param ID Analyzer has been used.  This should be re-examined.
 				if (signatureSource == SourceType.ANALYSIS) {
 					++numFuncsWithParameterID;
 				}
diff --git a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/cmd/ApplyFidEntriesCommand.java b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/cmd/ApplyFidEntriesCommand.java
index bab3a95d2df..645f37be2d9 100644
--- a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/cmd/ApplyFidEntriesCommand.java
+++ b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/cmd/ApplyFidEntriesCommand.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -273,9 +273,8 @@ private boolean hasUserOrImportedSymbols(Function function) {
 		SymbolTable symbolTable = program.getSymbolTable();
 		SymbolIterator symbols = symbolTable.getSymbolsAsIterator(function.getEntryPoint());
 		for (Symbol symbol : symbols) {
-			SourceType sourceType = symbol.getSource();
-			if (sourceType == SourceType.USER_DEFINED || sourceType == SourceType.IMPORTED) {
-				return true;
+			if (symbol.getSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
+				return true; // symbol has trusted source
 			}
 		}
 		return false;
diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java
index 0fe546c3b42..05b56bb98a2 100644
--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java
+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java
@@ -2341,25 +2341,6 @@ private void dumpLabels() {
 		}
 	}
 
-	//==============================================================================================
-	boolean shouldForcePrimarySymbol(Address address, boolean forceIfMangled) {
-		Symbol primarySymbol = program.getSymbolTable().getPrimarySymbol(address);
-		if (primarySymbol != null) {
-
-			if (primarySymbol.getName().startsWith("?") && forceIfMangled &&
-				applicatorOptions.allowDemotePrimaryMangledSymbols()) {
-				return true;
-			}
-
-			SourceType primarySymbolSource = primarySymbol.getSource();
-
-			if (!SourceType.ANALYSIS.isHigherPriorityThan(primarySymbolSource)) {
-				return true;
-			}
-		}
-		return false;
-	}
-
 	//==============================================================================================
 	boolean addToPlateUnique(Address address, String comment) {
 		if (StringUtils.isBlank(comment)) {
@@ -2411,8 +2392,8 @@ private Symbol createSymbolInternal(Address address, SymbolPath symbolPath,
 
 		Function existingFunction = program.getListing().getFunctionAt(address);
 		if (existingFunction != null) { // Maybe I should care if there is a data type there too.
-			if (existingFunction.getSignatureSource().isHigherPriorityThan(SourceType.ANALYSIS)) {
-				// Existing is USER or IMPORTED
+			if (existingFunction.getSignatureSource()
+					.isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 				return doCreateSymbol(address, symbolPath, false, plateAddition);
 			}
 		}
diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/FunctionSymbolApplier.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/FunctionSymbolApplier.java
index 7538dee4b04..3cf2e60d36a 100644
--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/FunctionSymbolApplier.java
+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/FunctionSymbolApplier.java
@@ -79,8 +79,7 @@ public Address getAddressForDisassembly() {
 		return applicator.getAddress(symbol);
 	}
 
-	private void processSymbol(MsSymbolIterator iter)
-			throws CancelledException, PdbException {
+	private void processSymbol(MsSymbolIterator iter) throws CancelledException, PdbException {
 
 		Address address = applicator.getAddress(symbol);
 		String name = symbol.getName();
@@ -186,8 +185,7 @@ private boolean setFunctionDefinition(Function function, Address address)
 		}
 		// Remaining are non-thunks
 
-		if (function.getSignatureSource().isHigherPriorityThan(SourceType.ANALYSIS)) {
-			// return if IMPORTED or USER_DEFINED
+		if (function.getSignatureSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 			return false;
 		}
 
diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/ManagedProcedureSymbolApplier.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/ManagedProcedureSymbolApplier.java
index 3ae8d810339..2a2db4658d3 100644
--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/ManagedProcedureSymbolApplier.java
+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/ManagedProcedureSymbolApplier.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -86,8 +86,7 @@ public Address getAddressForDisassembly() {
 
 	// TODO.  Investigate more.  This is not working for at least one CLI dll in that we are
 	// not getting correct addresses.  There is no omap and the one section is unnamed.
-	private void processSymbol(MsSymbolIterator iter)
-			throws CancelledException, PdbException {
+	private void processSymbol(MsSymbolIterator iter) throws CancelledException, PdbException {
 
 		Address address = applicator.getAddress(symbol);
 		String name = symbol.getName();
@@ -124,8 +123,7 @@ private void processSymbol(MsSymbolIterator iter)
 	}
 
 	@Override
-	public void deferredApply(MsSymbolIterator iter)
-			throws PdbException, CancelledException {
+	public void deferredApply(MsSymbolIterator iter) throws PdbException, CancelledException {
 		// Pealing the symbol off again, as the iterator is coming in fresh, and we need the symbol
 		getValidatedSymbol(iter, true);
 
@@ -260,9 +258,8 @@ void setLocalVariable(Address address, String name, DataType dataType) {
 			return; // silently return.
 		}
 		// Currently just placing a comment.
-		String comment =
-			context.getIndent(symbolBlockNestingLevel + 1) + "static local (stored at " +
-				address + ") " + dataType.getName() + " " + name;
+		String comment = context.getIndent(symbolBlockNestingLevel + 1) +
+			"static local (stored at " + address + ") " + dataType.getName() + " " + name;
 		context.getComments().addPreComment(currentBlockAddress, comment);
 	}
 
@@ -300,8 +297,7 @@ void setLocalVariable(Address address, String name, DataType dataType) {
 	private boolean setFunctionDefinition(Function function, Address address,
 			AbstractManagedProcedureMsSymbol symbol) throws CancelledException, PdbException {
 
-		if (function.getSignatureSource().isHigherPriorityThan(SourceType.ANALYSIS)) {
-			// return if IMPORTED or USER_DEFINED
+		if (function.getSignatureSource().isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 			return false;
 		}
 
diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/correlator/program/SimilarSymbolNameProgramCorrelator.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/correlator/program/SimilarSymbolNameProgramCorrelator.java
index ffda750fff4..48922bdac39 100644
--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/correlator/program/SimilarSymbolNameProgramCorrelator.java
+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/correlator/program/SimilarSymbolNameProgramCorrelator.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -106,8 +106,7 @@ private void addSymbolsToMap(SymbolIterator symbolIt, boolean isSourceProgram, i
 			if (!addressSet.contains(symbol.getAddress())) {
 				continue;
 			}
-			if (symbol.getSource() == SourceType.DEFAULT ||
-				symbol.getSource() == SourceType.ANALYSIS) {
+			if (symbol.getSource().isLowerOrEqualPriorityThan(SourceType.ANALYSIS)) {
 				continue;
 			}
 
diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java
index 4f0ba0b4163..eb9d0e3d863 100644
--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java
+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -979,38 +979,29 @@ private boolean tryToForceNames(Function toFunction) throws VersionTrackingApply
 
 	private boolean isFirstHigherPriorityWhenUserPriority(SourceType first, SourceType second,
 			boolean replaceSamePriorityNames) {
-		if (first == second && first != SourceType.DEFAULT) {
-			return replaceSamePriorityNames;
-		}
-		if (first == SourceType.USER_DEFINED) {
-			return (second == SourceType.IMPORTED || second == SourceType.ANALYSIS ||
-				second == SourceType.DEFAULT);
-		}
-		if (first == SourceType.IMPORTED) {
-			return (second == SourceType.ANALYSIS || second == SourceType.DEFAULT);
+		if (first == SourceType.DEFAULT) {
+			return false;
 		}
-		if (first == SourceType.ANALYSIS) {
-			return (second == SourceType.DEFAULT);
+		if (first == second) {
+			return replaceSamePriorityNames;
 		}
-		return false;
+		return first.isHigherPriorityThan(second);
 	}
 
 	private boolean isFirstHigherPriorityWhenImportedPriority(SourceType first, SourceType second,
 			boolean replaceSamePriorityNames) {
-		if (first == second && first != SourceType.DEFAULT) {
+		if (first == SourceType.DEFAULT) {
+			return false;
+		}
+		if (first == second) {
 			return replaceSamePriorityNames;
 		}
+		// NOTE: If a new SourceType is added with a priority in between IMPORTED and USER_DEFINED
+		// VT and this code will need to change.
 		if (first == SourceType.IMPORTED) {
-			return (second == SourceType.USER_DEFINED || second == SourceType.ANALYSIS ||
-				second == SourceType.DEFAULT);
-		}
-		if (first == SourceType.USER_DEFINED) {
-			return (second == SourceType.ANALYSIS || second == SourceType.DEFAULT);
-		}
-		if (first == SourceType.ANALYSIS) {
-			return (second == SourceType.DEFAULT);
+			return true; // IMPORTED is highest priority
 		}
-		return false;
+		return first.isHigherPriorityThan(second);
 	}
 
 	private void replaceParameterComments(Function toFunction, CommentChoices commentChoice) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
index 44421edeca7..9b83a39fba5 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
@@ -585,12 +585,9 @@ void updateSignatureSourceAfterVariableChange(SourceType variableSourceType,
 		if (Undefined.isUndefined(variableDataType)) {
 			return;
 		}
-		SourceType type = SourceType.ANALYSIS;
-		if (variableSourceType != type && variableSourceType.isHigherPriorityThan(type)) {
-			type = variableSourceType;
-		}
-		if (type.isHigherPriorityThan(getStoredSignatureSource())) {
-			setSignatureSource(type);
+		// TODO: It seems that the lowest parameter priority should win out (see GP-6013)
+		if (variableSourceType.isHigherPriorityThan(getStoredSignatureSource())) {
+			setSignatureSource(variableSourceType);
 		}
 	}
 
@@ -604,14 +601,14 @@ SourceType getInferredSignatureSource() {
 		boolean isReturnUndefined = Undefined.isUndefined(returnType);
 		SourceType type = isReturnUndefined ? SourceType.DEFAULT : SourceType.ANALYSIS;
 
+		// TODO: It seems that the lowest parameter priority should win out (see GP-6013)
 		Parameter[] parameters = getParameters();
 		for (Parameter parameter : parameters) {
 			if (Undefined.isUndefined(parameter.getDataType())) {
 				continue;
 			}
 			SourceType paramSourceType = parameter.getSource();
-			if (paramSourceType != SourceType.ANALYSIS &&
-				paramSourceType.isHigherPriorityThan(SourceType.ANALYSIS)) {
+			if (paramSourceType.isHigherOrEqualPriorityThan(SourceType.IMPORTED)) {
 				type = paramSourceType;
 			}
 			else {
@@ -1458,7 +1455,7 @@ else if (returnVar.isUniqueVariable()) {
 				symbolMap.put(s, paramDb);
 			}
 
-			if (source.isHigherPriorityThan(getStoredSignatureSource())) {
+			if (source != getStoredSignatureSource()) {
 				setSignatureSource(source);
 			}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SourceType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SourceType.java
index a6f1cce5660..186039e71b7 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SourceType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SourceType.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -42,7 +42,7 @@ public String getDisplayString() {
 	}
 
 	/**
-	 * Determines if this source type is a higher priority than the one being
+	 * Determine if this source type has a higher priority than the one being
 	 * passed to this method as a parameter.
 	 * USER_DEFINED objects are higher priority than IMPORTED objects which are higher
 	 * priority than ANALYSIS objects which are higher priority than DEFAULT objects.
@@ -55,7 +55,20 @@ public boolean isHigherPriorityThan(SourceType source) {
 	}
 
 	/**
-	 * Determines if this source type is a lower priority than the one being
+	 * Determine if this source type has the same or higher priority than the one being
+	 * passed to this method as a parameter.
+	 * USER_DEFINED objects are higher priority than IMPORTED objects which are higher
+	 * priority than ANALYSIS objects which are higher priority than DEFAULT objects.
+	 * @param source the source type whose priority is to be compared with this one's.
+	 * @return true if this source type is a higher priority.
+	 * false if this source type is the same priority or lower priority.
+	 */
+	public boolean isHigherOrEqualPriorityThan(SourceType source) {
+		return this.priority >= source.priority;
+	}
+
+	/**
+	 * Determine if this source type has a lower priority than the one being
 	 * passed to this method as a parameter.
 	 * DEFAULT objects are lower priority than ANALYSIS objects which are lower
 	 * priority than IMPORTED objects which are lower priority than USER_DEFINED objects.
@@ -66,4 +79,17 @@ public boolean isHigherPriorityThan(SourceType source) {
 	public boolean isLowerPriorityThan(SourceType source) {
 		return this.priority < source.priority;
 	}
+
+	/**
+	 * Determine if this source type has the same or lower priority than the one being
+	 * passed to this method as a parameter.
+	 * DEFAULT objects are lower priority than ANALYSIS objects which are lower
+	 * priority than IMPORTED objects which are lower priority than USER_DEFINED objects.
+	 * @param source the source type whose priority is to be compared with this one's.
+	 * @return true if this source type is a lower priority.
+	 * false if this source type is the same priority or higher priority.
+	 */
+	public boolean isLowerOrEqualPriorityThan(SourceType source) {
+		return this.priority <= source.priority;
+	}
 }
```
-----------------------------------
