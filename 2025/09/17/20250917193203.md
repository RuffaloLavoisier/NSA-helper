# Commit: 7231c8b1e8ee381b1a16bac633e8777647683f8f
## Message: Merge remote-tracking branch 'origin/Ghidra_12.0'
## Diff:
```
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataView.java
index 37506e20383..1d4e5038aea 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceDefinedDataView.java
@@ -134,8 +134,8 @@ else if (dataType instanceof Dynamic) {
 
 			// Truncate, then check that against existing code units.
 			long endSnap = computeTruncatedMax(lifespan, null, createdRange);
-			TraceAddressSnapRange tasr = new ImmutableTraceAddressSnapRange(createdRange,
-				Lifespan.span(startSnap, endSnap));
+			TraceAddressSnapRange tasr =
+				new ImmutableTraceAddressSnapRange(createdRange, Lifespan.span(startSnap, endSnap));
 			if (!space.undefinedData.coversRange(tasr)) {
 				// TODO: Figure out the conflicting unit?
 				throw new CodeUnitInsertionException("Code units cannot overlap");
@@ -170,26 +170,4 @@ else if (dataType instanceof Dynamic) {
 		}
 	}
 
-	@Override
-	protected void unitRemoved(DBTraceData unit) {
-		super.unitRemoved(unit);
-		DataType dataType = unit.getBaseDataType();
-		if (dataType instanceof Composite || dataType instanceof Array ||
-			dataType instanceof Dynamic) {
-			space.trace.setChanged(new TraceChangeRecord<>(TraceEvents.COMPOSITE_DATA_REMOVED,
-				space.space, unit.getBounds(), unit, null));
-		}
-	}
-
-	@Override
-	protected void unitSpanChanged(Lifespan oldSpan, DBTraceData unit) {
-		super.unitSpanChanged(oldSpan, unit);
-		DataType dataType = unit.getBaseDataType();
-		if (dataType instanceof Composite || dataType instanceof Array ||
-			dataType instanceof Dynamic) {
-			space.trace.setChanged(
-				new TraceChangeRecord<>(TraceEvents.COMPOSITE_DATA_LIFESPAN_CHANGED,
-					space.space, unit, oldSpan, unit.getLifespan()));
-		}
-	}
 }
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/AbstractDBTraceProgramViewListing.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/AbstractDBTraceProgramViewListing.java
index 5ae8b33e3a5..87c457c233d 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/AbstractDBTraceProgramViewListing.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/AbstractDBTraceProgramViewListing.java
@@ -20,8 +20,8 @@
 
 import org.apache.commons.collections4.IteratorUtils;
 
-import generic.util.MergeSortingIterator;
 import generic.util.FlattenedIterator;
+import generic.util.MergeSortingIterator;
 import ghidra.program.database.ProgramDB;
 import ghidra.program.database.code.InstructionDB;
 import ghidra.program.database.function.OverlappingFunctionException;
@@ -688,24 +688,6 @@ public CodeUnit getDefinedCodeUnitBefore(Address addr) {
 		}
 	}
 
-	@Override
-	public DataIterator getCompositeData(boolean forward) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public DataIterator getCompositeData(Address start, boolean forward) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public DataIterator getCompositeData(AddressSetView addrSet, boolean forward) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
 	@Override
 	public Iterator<String> getUserDefinedProperties() {
 		// TODO Auto-generated method stub
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java
index 4b4fd6a09a9..20746c66cf6 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java
@@ -115,10 +115,6 @@ public EventTranslator() {
 			listenFor(TraceEvents.PRE_COMMENT_CHANGED, this::commentPreChanged);
 			listenFor(TraceEvents.REPEATABLE_COMMENT_CHANGED, this::commentRepeatableChanged);
 
-			listenFor(TraceEvents.COMPOSITE_DATA_ADDED, this::compositeDataAdded);
-			listenFor(TraceEvents.COMPOSITE_DATA_LIFESPAN_CHANGED, this::compositeLifespanChanged);
-			listenFor(TraceEvents.COMPOSITE_DATA_REMOVED, this::compositeDataRemoved);
-
 			listenFor(TraceEvents.DATA_TYPE_ADDED, this::dataTypeAdded);
 			listenFor(TraceEvents.DATA_TYPE_CHANGED, this::dataTypeChanged);
 			listenFor(TraceEvents.DATA_TYPE_REPLACED, this::dataTypeReplaced);
@@ -322,8 +318,7 @@ private void codeDataTypeReplaced(AddressSpace space, TraceAddressSnapRange rang
 				range.getX2(), null, null, null));
 		}
 
-		private void codeDataTypeSettingsChanged(AddressSpace space,
-				TraceAddressSnapRange range) {
+		private void codeDataTypeSettingsChanged(AddressSpace space, TraceAddressSnapRange range) {
 			DomainObjectEventQueues queues = isVisible(space, range);
 			if (queues == null) {
 				return;
@@ -369,45 +364,6 @@ private void commentRepeatableChanged(AddressSpace space, TraceAddressSnapRange
 			commentChanged(CommentType.REPEATABLE, space, range, oldValue, newValue);
 		}
 
-		private void compositeDataAdded(AddressSpace space, TraceAddressSnapRange range,
-				TraceData oldIsNull, TraceData added) {
-			DomainObjectEventQueues queues = isCodeVisible(space, added);
-			if (queues == null) {
-				return;
-			}
-			queues.fireEvent(new ProgramChangeRecord(ProgramEvent.COMPOSITE_ADDED,
-				added.getMinAddress(), added.getMaxAddress(), null, null, added));
-		}
-
-		private void compositeLifespanChanged(AddressSpace space, TraceData data, Lifespan oldSpan,
-				Lifespan newSpan) {
-			DomainObjectEventQueues queues = getEventQueues(space);
-			if (queues == null) {
-				return;
-			}
-			boolean inOld = isCodeVisible(data, oldSpan);
-			boolean inNew = isCodeVisible(data, newSpan);
-			if (inOld && !inNew) {
-				queues.fireEvent(new ProgramChangeRecord(ProgramEvent.COMPOSITE_REMOVED,
-					data.getMinAddress(), data.getMaxAddress(), null, data, null));
-			}
-			if (!inOld && inNew) {
-				queues.fireEvent(new ProgramChangeRecord(ProgramEvent.COMPOSITE_ADDED,
-					data.getMinAddress(), data.getMaxAddress(), null, null, data));
-			}
-		}
-
-		private void compositeDataRemoved(AddressSpace space, TraceAddressSnapRange range,
-				TraceData removed, TraceData newIsNull) {
-			DomainObjectEventQueues queues = isCodeVisible(space, removed);
-			if (queues == null) {
-				return;
-			}
-			// TODO: ProgramDB doesn't send this.... Should I?
-			queues.fireEvent(new ProgramChangeRecord(ProgramEvent.COMPOSITE_REMOVED,
-				removed.getMinAddress(), removed.getMaxAddress(), null, removed, null));
-		}
-
 		private void dataTypeAdded(long id, DataType oldIsNull, DataType added) {
 			fireEventAllViews(new ProgramChangeRecord(ProgramEvent.DATA_TYPE_ADDED, null, null,
 				null, oldIsNull, added));
@@ -452,8 +408,8 @@ private void instructionFlowOverrideChanged(AddressSpace space,
 				instruction.getMinAddress(), instruction.getMinAddress(), null, null, null));
 		}
 
-		private void instructionFallThroughChanged(AddressSpace space,
-				TraceInstruction instruction, boolean oldFallThrough, boolean newFallThrough) {
+		private void instructionFallThroughChanged(AddressSpace space, TraceInstruction instruction,
+				boolean oldFallThrough, boolean newFallThrough) {
 			DomainObjectEventQueues queues = isCodeVisible(space, instruction);
 			if (queues == null) {
 				return;
@@ -1460,8 +1416,7 @@ protected DomainObjectEventQueues getEventQueues(AddressSpace space) {
 		return eventQueues;
 	}
 
-	protected DomainObjectEventQueues isVisible(AddressSpace space,
-			TraceAddressSnapRange range) {
+	protected DomainObjectEventQueues isVisible(AddressSpace space, TraceAddressSnapRange range) {
 		return viewport.containsAnyUpper(range.getLifespan()) ? getEventQueues(space) : null;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugByteManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugByteManager.java
index ea0279f57ce..dc9235d4237 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugByteManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugByteManager.java
@@ -32,7 +32,8 @@
 import ghidra.xml.*;
 
 /**
- * Manager to hold byte information from the <bytechunk> tags inside the Decompiler Debug's XML.
+ * Manager to hold byte information from the {@code <bytechunk>} tags inside the Decompiler Debug's 
+ * XML.
  */
 public class DecompileDebugByteManager {
 
@@ -53,7 +54,7 @@ public DecompileDebugByteManager(TaskMonitor monitor,
 	}
 
 	/**
-	 * Parse the <bytechunk> tag - has the memory offset and the raw bytes
+	 * Parse the {@code <bytechunk>} tag - has the memory offset and the raw bytes
 	 * 
 	 * @param parser XmlPullParser
 	 * @param log Xml
@@ -66,7 +67,7 @@ public void parse(XmlPullParser parser, XmlMessageLog log) {
 	}
 
 	/**
-	 * Handle parsing and creating bytechunks & pulling out the byte string as a byte array.
+	 * Handle parsing and creating bytechunks and pulling out the byte string as a byte array.
 	 * 
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog
@@ -89,7 +90,7 @@ private void processByteChunk(XmlPullParser parser, XmlMessageLog log) {
 	}
 
 	/**
-	 *  Create memory blocks with the raw bytes from the central function and any other blocks
+	 * Create memory blocks with the raw bytes from the central function and any other blocks
 	 * such as for pointers or other data types that the Decompile.xml file was generated from. 
 	 * 
 	 * @param rawBytes raw program bytes
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugDataTypeManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugDataTypeManager.java
index bf7d506138c..e91fdb9ddfd 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugDataTypeManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugDataTypeManager.java
@@ -34,7 +34,7 @@
 
 /**
  * Manager for parsing and storing data type objects from the XML - identified by 
- * the <coretypes> and <typegrp> tags. 
+ * the {@code <coretypes>} and {@code <typegrp>} tags. 
  * 
  * NOTE: In the typegrp subtree, ID is often on a different line from the element's name and 
  * metatype, so we need a way to reference this for use in the map -- String idHolder var 
@@ -62,13 +62,15 @@ public DecompileDebugDataTypeManager(TaskMonitor monitor, Program prog) {
 
 	/**
 	 * Parse Data Type tag, handling types:
-	 * <type>
-	 * <typeref>
-	 * <def>
-	 * <void>
+	 * <ul>
+	 * <li>{@code <type>}</li>
+	 * <li>{@code <typeref>}</li>
+	 * <li>{@code <def>}</li>
+	 * <li>{@code <void>}</li>
+	 * </ul>
+	 * 
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog
-	 * 
 	 * @return retrieved DataType 
 	 */
 	public DataType parseDataTypeTag(XmlPullParser parser, XmlMessageLog log) {
@@ -98,7 +100,7 @@ public DataType parseDataTypeTag(XmlPullParser parser, XmlMessageLog log) {
 	}
 
 	/**
-	 *  Parse the <type> tag
+	 * Parse the {@code <type>} tag
 	 *  
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog
@@ -138,7 +140,7 @@ private DataType parseType(XmlPullParser parser, XmlMessageLog log) {
 	}
 
 	/**
-	 * TypeDefs (<def> tags) are new definitions of types - basically, a re-naming.
+	 * TypeDefs ({@cod <def>} tags) are new definitions of types - basically, a re-naming.
 	 * 
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog
@@ -197,7 +199,7 @@ private DataType parseEnum(XmlPullParser parser, XmlMessageLog log) {
 	}
 
 	/**
-	 * Parse & create union types 
+	 * Parse and create union types 
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog 
 	 * 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFormatManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFormatManager.java
index 6aab6903a4b..420b369bf71 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFormatManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFormatManager.java
@@ -30,6 +30,8 @@
 import ghidra.app.util.bin.ByteProvider;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.app.util.opinion.DecompileDebugXmlLoader.DecompileDebugProgramInfo;
+import ghidra.formats.gfilesystem.FSRL;
+import ghidra.formats.gfilesystem.FileSystemService;
 import ghidra.framework.store.LockException;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressOverflowException;
@@ -65,16 +67,16 @@ public DecompileDebugFormatManager(File file) {
 		this.file = file;
 	}
 
-	/*
+	/**
 	 * Constructs a new program Decompiler Debug XML manager using the provided ByteProvider.
-	 *  <p>
+	 * <p>
 	 * If {@link ByteProvider} has a {@link FSRL} and it is a simple local filepath,
 	 * convert that to a normal local java.io.File instance instead of using the
 	 * {@link ByteProvider}'s File property which is probably located in the
 	 * {@link FileSystemService} filecache directory, which will break the ability
 	 * to find the *.bytes file associated with this .xml file.
-	 * <p>
-	 * @param provider
+	 * 
+	 * @param provider The provider
 	 */
 	public DecompileDebugFormatManager(ByteProvider provider) {
 		this.file = (provider.getFSRL() != null && provider.getFSRL().getNestingDepth() == 1)
@@ -82,10 +84,12 @@ public DecompileDebugFormatManager(ByteProvider provider) {
 				: provider.getFile();
 	}
 
-	/*
+	/**
 	 * Initial parsing of the XML file to obtain the binary image info with load specs.
 	 * 
 	 * @return DecompileDebugProgramInfo binary image / load spec details 
+	 * @throws SAXException If there was a problem parsing the XML
+	 * @throws IOException If there was an IO-related error
 	 */
 	public DecompileDebugProgramInfo getProgramInfo() throws SAXException, IOException {
 		XmlPullParser parser =
@@ -118,22 +122,26 @@ else if (element.isStart("bytechunk")) {
 	 * Perform the parsing from the underlying decompile debug XML file and populates the program fields.
 	 * See @DecompileDebug.java for reference on the generation of the XML file.
 	 * Tags currently supported/expected: 
-	 * - <binaryimage>
-	 * - <coretypes>
-	 * - <typegrp>
-	 * - <save_state>
-	 * - <db>
-	 * - <commentdb>
-	 * - <stringmanage>
+	 * <ul>
+	 * <li>{@code <binaryimage>}</li>
+	 * <li>{@code <coretypes>}</li>
+	 * <li>{@code <typegrp>}</li>
+	 * <li>{@code <save_state>}</li>
+	 * <li>{@code <db>}</li>
+	 * <li>{@code <commentdb>}</li>
+	 * <li>{@code <stringmanage>}</li>
+	 *</ul>
 	 *
 	 * NOTE: the following subtree tags are not yet supported:
-	 * - <context_points>
-	 * - <optionslist> 
+	 * <ul>
+	 * <li>{@code <context_points>}</li>
+	 * <li>{@code <optionslist>}</li>
+	 * </ul>
 	 *
 	 * @param prog created program 
 	 * @param monitor task monitor
 	 * @param programName  name of program
-	 *@return MessageLog
+	 * @return MessageLog
 	 * @throws LoadException If there is a parsing issue with the XML file. 
 	 */
 	public MessageLog read(Program prog, TaskMonitor monitor, String programName)
@@ -234,8 +242,10 @@ public MessageLog read(Program prog, TaskMonitor monitor, String programName)
 	}
 
 	/**
-	 * Parse elements in the <db> subtree. Elements we currently handle include:
-	 * - <scope> 
+	 * Parse elements in the {@code <db>} subtree. Elements we currently handle include:
+	 * <ul>
+	 * <li>{@code <scope>}</li>
+	 * </ul>
 	 * 
 	 * @param parser XmlPullParser
 	 * @param monitor TaskMonitor
@@ -292,12 +302,12 @@ private void handleDBElements(XmlPullParser parser, TaskMonitor monitor, Program
 
 	/**
 	 * Parse element subtrees within the scope tag. 
-	 * 
+	 * <p>
 	 * NOTE: The scope tag must be parsed prior to a call to this message with the value 
 	 * of the namespace object sent as the first parameter. 
-	 *  
-	 * NOTE: it is expected that the wrapper <symbollist> tag is being used around the collection of 
-	 * <mapsymp> tags.
+	 * <p>
+	 * NOTE: it is expected that the wrapper {@code <symbollist>} tag is being used around the 
+	 * collection of {@code <mapsymp>} tags.
 	 * 
 	 * @param namespace Namespace
 	 * @param parser XmlPullParser
@@ -355,7 +365,8 @@ else if (symbolType.equals("symbol")) {
 	}
 
 	/**
-	 * Handle the <binaryimage> tag and subtree which includes the <bytechunk> tag(s).
+	 * Handle the {@code <binaryimage>} tag and subtree which includes the {@code <bytechunk>} 
+	 * tag(s).
 	 * 
 	 * @param parser XmlPullparser
 	 * @param monitor TaskMonitor
@@ -382,7 +393,7 @@ private void handleBinaryImageElements(XmlPullParser parser, TaskMonitor monitor
 	}
 
 	/**
-	 * Handle generation of labels from the <labelsym> tag
+	 * Handle generation of labels from the {@code <labelsym>} tag
 	 * @param prog program 
 	 * @param parser XmlPullParser
 	 * @param log XmlMessageLog
@@ -415,9 +426,9 @@ private void parseLabelSymbol(Program prog, XmlPullParser parser, XmlMessageLog
 	}
 
 	/**
-	 * Parse <symbol> tag under the <mapsym> tag -- meaning, they are outside of a function, 
-	 * most likely these are data references.
-	 * 
+	 * Parse {@code <symbol>} tag under the {@code <mapsym>} tag -- meaning, they are outside of a 
+	 * function, most likely these are data references.
+	 * <p>
 	 * NOTE: We are currently not pulling the bytes for referenced functions or data, as a result
 	 * we need to generate an initialized memory block for data references to avoid errors 
 	 * in the Listing pane. 
@@ -500,10 +511,11 @@ private void parseComments(XmlPullParser parser, TaskMonitor monitor, Program pr
 	}
 
 	/**
-	 * Parse comments from the <commentdb> tag and add to listing via setupComments method. 
-	 * 
-	 * Note: <commentdb> has two <addr> tags.  The first is the function address, and the second 
-	 * is the (CodeUnit) address where the comment should be placed. Discard the first address.   
+	 * Parse comments from the {@code <commentdb>} tag and add to listing via setupComments method. 
+	 * <p>
+	 * Note: {@code <commentdb>} has two {@code <addr>} tags.  The first is the function address, 
+	 * and the second is the {@link CodeUnit} address where the comment should be placed. Discard 
+	 * the first address.   
 	 * 
 	 * @param parser XmlPullParser
 	 * @param prog Program
@@ -550,14 +562,15 @@ private void setupComments(CommentType decodedType, Address commentAddr, String
 
 	/**
 	 * See @DecompileCallback.java for the encoding of the comments by @DecompileDebug.java. 
-	 * The method <encodeCommentsType> encodes the comment types found in @CodeUnit.java 
+	 * The method {@code <encodeCommentsType>} encodes the comment types found in @CodeUnit.java 
 	 * in 4 alternative labels:
-	 * CodeUnit.EOL_COMMENT = "user1"
-	 * CodeUnit.PRE_COMMENT = "user2"
-	 * CodeUnit.POST_COMMENT = "user3"
-	 * CodeUnit.PLATE_COMMENT = "header"
-	 * 
-	 * In order to generate comments using @CodeUnit.java, we will need to re-encode the user<1-3> 
+	 * <ul>
+	 * <li>{@code CodeUnit.EOL_COMMENT = "user1"}</li>
+	 * <li>{@code CodeUnit.PRE_COMMENT = "user2"}</li>
+	 * <li>{@code CodeUnit.POST_COMMENT = "user3"}</li>
+	 * <li>{@code CodeUnit.PLATE_COMMENT = "header"}</li>
+	 * </ul>
+	 * In order to generate comments using @CodeUnit.java, we will need to re-encode the user[1-3] 
 	 * and header type labels from the DecompileDebug XML back into the CodeUnit constant values of:
 	 * 0-3 (respectively).
 	 * 
@@ -566,29 +579,17 @@ private void setupComments(CommentType decodedType, Address commentAddr, String
 	 * @return CodeUnit comment type (0-3) 
 	 */
 	private CommentType decodeCommentType(String typeName) {
-		CommentType commentType;
-		switch (typeName) {
-			case "user1":
-				commentType = CommentType.EOL;
-				break;
-			case "user2":
-				commentType = CommentType.PRE;
-				break;
-			case "user3":
-				commentType = CommentType.POST;
-				break;
-			case "header":
-				commentType = CommentType.PLATE;
-				break;
-			default:
-				commentType = CommentType.valueOf("");
-				break;
-		}
-		return commentType;
+		return switch (typeName) {
+			case "user1" -> CommentType.EOL;
+			case "user2" -> CommentType.PRE;
+			case "user3" -> CommentType.POST;
+			case "header" -> CommentType.PLATE;
+			default -> CommentType.valueOf("");
+		};
 	}
 
 	/**
-	 * Loop through the <type> tags in the <coretypes> subtree
+	 * Loop through the {@code <type>} tags in the {@code <coretypes>} subtree
 	 * 
 	 * @param parser XmlPullParser
 	 * @param prog built program
@@ -605,7 +606,7 @@ private void parseDataTypes(XmlPullParser parser, TaskMonitor monitor, Program p
 	}
 
 	/**
-	 * Parse the <stringmanage> subtree 
+	 * Parse the {@code <stringmanage>} subtree 
 	 * 
 	 * @param parser XmlPullParser
 	 * @param monitor TaskMonitor
@@ -620,7 +621,7 @@ private void parseStrings(XmlPullParser parser, TaskMonitor monitor, Program pro
 	}
 
 	/**
-	 * Parse the <string> tag and insert into the program
+	 * Parse the {@code <string>} tag and insert into the program
 	 * 
 	 * @param parser XmlPullParser 
 	 * @param monitor TaskMonitor
@@ -650,7 +651,7 @@ private void parseAndAddStrings(XmlPullParser parser, TaskMonitor monitor, Progr
 	}
 
 	/**
-	 * Handle the parsing of the context pointset inside of the <contextpointset> subtree
+	 * Handle the parsing of the context pointset inside of the {@code <contextpointset>} subtree
 	 * 
 	 * @param parser XmlPullParser
 	 * @param monitor TaskMonitor
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFunctionManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFunctionManager.java
index 301d2113780..30b06fcb958 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFunctionManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DecompileDebugFunctionManager.java
@@ -63,14 +63,14 @@ public DecompileDebugFunctionManager(Program prog, TaskMonitor monitor,
 	}
 
 	/**
-	 * Setup functions from within the <symbollist> tag.
+	 * Setup functions from within the {@code <symbollist>} tag.
 	 * Functions referenced by the central function are loaded the same except we do not 
 	 * (currently) have the memory/program context for them. Thus, they will show up in the Listing
 	 * with a red "X". 
 	 * NOTE: This is the expected functionality. 
 	 * 
 	 * @param parser XmlPullParser
-	 * @param scopeMap Map<String, Namespace> used for getting parent namespace 
+	 * @param scopeMap {@code Map<String, Namespace>} used for getting parent namespace 
 	 * @param log XmlMessageLog
 	 */
 	public void parseFunctionSignature(XmlPullParser parser, Map<Long, Namespace> scopeMap,
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/scalartable/ScalarSearchTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/scalartable/ScalarSearchTest.java
index 231f6990a30..a5728614971 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/scalartable/ScalarSearchTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/scalartable/ScalarSearchTest.java
@@ -36,7 +36,8 @@
 import ghidra.program.model.address.AddressSet;
 import ghidra.program.model.data.*;
 import ghidra.program.model.lang.LanguageID;
-import ghidra.program.model.listing.*;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Program;
 import ghidra.test.AbstractGhidraHeadedIntegrationTest;
 import ghidra.test.TestEnv;
 import ghidra.util.exception.RollbackException;
@@ -44,7 +45,9 @@
 @Category(NightlyCategory.class)
 public class ScalarSearchTest extends AbstractGhidraHeadedIntegrationTest {
 
-	private static final String COMPOSITE_DATA_ADDRESS = "00400050";
+	private static final int ARRAY_ELEMENT_COUNT = 6;
+	private static final String ARRAY_DATA_ADDRESS = "00400050";
+
 	private static final String DATA_STRING_ADDRESS = "0041fee4";
 	private static final String BYTE_SCALAR_ADDRESS = "00421eb0";
 	private static final String CHAR_SCALAR_ADDRESS = "00421ed0";
@@ -98,7 +101,7 @@ public void setUp() throws Exception {
 
 		int txId = program.startTransaction("Test");
 		try {
-			createCompositeDataType();
+			createArrayDataType();
 			createByteDataType();
 			createCharDataType();
 			createDWordDataType();
@@ -212,9 +215,9 @@ public void testMinGreaterThanMax() throws Exception {
 	}
 
 	@Test
-	public void testCompositeDataInTable() throws Exception {
+	public void testArrayDataInTable() throws Exception {
 		searchProgramAndDisplayResults(program, null, minScalarVal, maxScalarVal);
-		assertScalarsFromCompositeDataInTable();
+		assertScalarsFromArrayDataInTable();
 	}
 
 	@Test
@@ -417,25 +420,18 @@ private void assertNoRowsGiven(int minValue, int maxValue) {
 		assertEquals(0, data.size());
 	}
 
-	private void assertScalarsFromCompositeDataInTable() {
-
-		Listing listing = program.getListing();
-		DataIterator compositeData = listing.getCompositeData(true);
-		Data composite = compositeData.next();
-		assertTrue("Expected array; found: " + composite, composite.getDataType() instanceof Array);
+	private void assertScalarsFromArrayDataInTable() {
 
-		//@formatter:off
 		List<ScalarRowObject> data = getTableData();
-		List<Address> addresses =
-			data.stream()
-				.map(rowObject -> rowObject.getAddress())
-				.collect(Collectors.toList())
-				;
-		//@formatter:on
-
-		int n = composite.getNumComponents();
-		for (int i = 0; i < n; i++) {
-			Data child = composite.getComponent(i);
+		List<Address> addresses = data.stream().map(rowObject -> rowObject.getAddress()).toList();
+
+		Address arrayAddr = program.getAddressFactory().getAddress(ARRAY_DATA_ADDRESS);
+		Data arrayData = program.getListing().getDefinedDataAt(arrayAddr);
+		assertNotNull(arrayData);
+		assertEquals("byte[6]", arrayData.getDataType().getName());
+
+		for (int i = 0; i < ARRAY_ELEMENT_COUNT; i++) {
+			Data child = arrayData.getComponent(i);
 			Address a = child.getAddress();
 			assertTrue(addresses.contains(a));
 		}
@@ -497,18 +493,12 @@ private void assertNestedScalarsInTable(Program p) {
 			tableAddress.add(rowObject.getAddress());
 		}
 
-		DataIterator compositeData = p.getListing().getCompositeData(true);
+		Address structAddr = p.getAddressFactory().getAddress(NESTED_STRUCTURE_DATA_ADDRESS);
+		Data compositeData = p.getListing().getDefinedDataAt(structAddr);
+		assertEquals("NESTED_STRUCTURE", compositeData.getDataType().getName());
 
-		while (compositeData.hasNext()) {
-
-			Data structureData = compositeData.next();
-			Address address = structureData.getComponent(0).getAddress();
-
-			if (!tableAddress.contains(address)) {
-				fail("Table not created correctly: could not find address " + address +
-					"in scalar table.");
-			}
-		}
+		assertTrue("Table not created correctly: could not find address " + structAddr +
+			"in scalar table.", tableAddress.contains(structAddr));
 	}
 
 	private void setFilterValues(int min, int max) {
@@ -555,15 +545,14 @@ private Program buildProgram() throws Exception {
 			"A_virt2@401120", 16);
 		createFunction(builder, "00401130", "55 8b ec 51 89 4d fc b8 08 00 00 00 8b e5 5d c3",
 			"B_virt2@401130", 16);
-		createFunction(builder, "00401140", "48 83 ec cc",
-			"C_virt2@401140", 4);
+		createFunction(builder, "00401140", "48 83 ec cc", "C_virt2@401140", 4);
 		createFunction(builder, "00401150", "55 8b ec 51 89 4d fc b8 cc 00 00 00 8b e5 5d c3",
 			"C_virt2@401150", 16);
 
-		createBytes(builder, COMPOSITE_DATA_ADDRESS,
-			"0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 " +
-				"72 6f 67 72 61 6d 20 63 61 6e 6e 6f 74 20 62 65 20 72 75 6e " +
-				"20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 " + "00 00 00 00");
+		createBytes(builder, ARRAY_DATA_ADDRESS,
+			"0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 " +
+				"61 6e 6e 6f 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d " +
+				"0d 0a 24 00 00 00 00 00 00 00");
 		createBytes(builder, BYTE_SCALAR_ADDRESS, "c4");
 		createBytes(builder, CHAR_SCALAR_ADDRESS, "28");
 		createBytes(builder, DWORD_SCALAR_ADDRESS, "08 34 23 cd");
@@ -686,9 +675,9 @@ private ScalarSearchDialog launchScalarSearchDialog(Program customProgram, Addre
 		return dialog;
 	}
 
-	private void createCompositeDataType() throws Exception {
+	private void createArrayDataType() throws Exception {
 		ArrayDataType arrayDataType = new ArrayDataType(new ByteDataType(), 6, 2);
-		createData(addr(Long.parseLong(COMPOSITE_DATA_ADDRESS, 16)), arrayDataType);
+		createData(addr(Long.parseLong(ARRAY_DATA_ADDRESS, 16)), arrayDataType);
 	}
 
 	private void createByteDataType() throws Exception {
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/code/CodeUnitIteratorTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/code/CodeUnitIteratorTest.java
index 3f942145073..e4e861e2de8 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/code/CodeUnitIteratorTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/code/CodeUnitIteratorTest.java
@@ -1239,169 +1239,6 @@ public void testGetDataBackwards() throws Exception {
 		dtm.close();
 	}
 
-	@Test
-	public void testGetCompositeData() throws Exception {
-		startTransaction();
-		mem.createInitializedBlock("test", addr(0), 1000, (byte) 0, TaskMonitor.DUMMY, false);
-
-		Structure struct = new StructureDataType("struct_1", 100);
-		Structure struct2 = new StructureDataType("struct_2", 0);
-		Structure struct3 = new StructureDataType("struct_3", 0);
-		DataTypeManager dtm = new StandAloneDataTypeManager("dummyDTM");
-		int id = dtm.startTransaction("");
-
-		struct = (Structure) dtm.resolve(struct, null);
-		struct2 = (Structure) dtm.resolve(struct2, null);
-		struct3 = (Structure) dtm.resolve(struct3, null);
-
-		struct2.add(new ByteDataType());
-		struct2.add(new StringDataType(), 20);
-		struct2.add(new QWordDataType());
-		struct3.add(struct2);
-
-		struct.replace(0, struct2, struct2.getLength());
-		struct.replace(1, new StringDataType(), 10);
-
-		listing.createData(addr(0), struct, 0);
-
-		listing.createData(addr(300), struct2, 0);
-
-		listing.createData(addr(250), struct3, 0);
-		endTransaction();
-
-		DataIterator iter = listing.getCompositeData(true);
-		assertTrue(iter.hasNext());
-		Data d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(0), d.getMinAddress());
-		assertEquals(addr(99), d.getMaxAddress());
-
-		d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(250), d.getMinAddress());
-		assertEquals("struct_3", d.getDataType().getName());
-
-		d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(300), d.getMinAddress());
-		assertEquals(3, d.getNumComponents());
-
-		assertTrue(!iter.hasNext());
-		d = iter.next();
-		assertNull(d);
-		dtm.endTransaction(id, true);
-		dtm.close();
-	}
-
-	@Test
-	public void testGetCompositeDataStartingAt() throws Exception {
-		startTransaction();
-		mem.createInitializedBlock("test", addr(0), 1000, (byte) 0, TaskMonitor.DUMMY, false);
-
-		Structure struct = new StructureDataType("struct_1", 100);
-		Structure struct2 = new StructureDataType("struct_2", 0);
-		Structure struct3 = new StructureDataType("struct_3", 0);
-		DataTypeManager dtm = new StandAloneDataTypeManager("dummyDTM");
-		int id = dtm.startTransaction("");
-		struct = (Structure) dtm.resolve(struct, null);
-		struct2 = (Structure) dtm.resolve(struct2, null);
-		struct3 = (Structure) dtm.resolve(struct3, null);
-
-		struct2.add(new ByteDataType());
-		struct2.add(new StringDataType(), 20);
-		struct2.add(new QWordDataType());
-		struct3.add(struct2);
-
-		struct.replace(0, struct2, struct2.getLength());
-		struct.replace(1, new StringDataType(), 10);
-
-		listing.createData(addr(0), struct, 0);
-
-		listing.createData(addr(300), struct2, 0);
-
-		listing.createData(addr(250), struct3, 0);
-
-		Union union = new UnionDataType("union_1");
-		union.add(struct3);
-		union.add(struct2);
-
-		listing.createData(addr(600), union, 0);
-		endTransaction();
-
-		DataIterator iter = listing.getCompositeData(addr(275), true);
-		assertTrue(iter.hasNext());
-
-		Data d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(300), d.getMinAddress());
-
-		d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(600), d.getMinAddress());
-
-		assertTrue(!iter.hasNext());
-		assertNull(iter.next());
-		dtm.endTransaction(id, true);
-		dtm.close();
-
-	}
-
-	@Test
-	public void testGetCompositeDataInSet() throws Exception {
-		startTransaction();
-		mem.createInitializedBlock("test", addr(0), 1000, (byte) 0, TaskMonitor.DUMMY, false);
-
-		Structure struct = new StructureDataType("struct_1", 100);
-		Structure struct2 = new StructureDataType("struct_2", 0);
-		Structure struct3 = new StructureDataType("struct_3", 0);
-		DataTypeManager dtm = new StandAloneDataTypeManager("dummyDTM");
-		int id = dtm.startTransaction("");
-		struct = (Structure) dtm.resolve(struct, null);
-		struct2 = (Structure) dtm.resolve(struct2, null);
-		struct3 = (Structure) dtm.resolve(struct3, null);
-
-		struct2.add(new ByteDataType());
-		struct2.add(new StringDataType(), 20);
-		struct2.add(new QWordDataType());
-		struct3.add(struct2);
-
-		struct.replace(0, struct2, struct2.getLength());
-		struct.replace(1, new StringDataType(), 10);
-
-		listing.createData(addr(0), struct, 0);
-
-		listing.createData(addr(300), struct2, 0);
-
-		listing.createData(addr(450), struct3, 0);
-
-		Union union = new UnionDataType("union_1");
-		union.add(struct3);
-		union.add(struct2);
-
-		listing.createData(addr(800), union, 0);
-		endTransaction();
-
-		AddressSet set = new AddressSet();
-		set.addRange(addr(5), addr(10));
-		set.addRange(addr(100), addr(200));
-		set.addRange(addr(300), addr(320));
-		set.addRange(addr(400), addr(500));
-
-		DataIterator iter = listing.getCompositeData(set, true);
-		Data d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(300), d.getMinAddress());
-		d = iter.next();
-		assertNotNull(d);
-		assertEquals(addr(450), d.getMinAddress());
-
-		d = iter.next();
-		assertNull(d);
-		dtm.endTransaction(id, true);
-		dtm.close();
-
-	}
-
 	@Test
 	public void testGetDefinedDataIterator() throws Exception {
 		startTransaction();
diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emu/jit/analysis/JitTypeBehavior.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emu/jit/analysis/JitTypeBehavior.java
index 196a67123e9..905033947b6 100644
--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emu/jit/analysis/JitTypeBehavior.java
+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/emu/jit/analysis/JitTypeBehavior.java
@@ -21,6 +21,7 @@
 import ghidra.pcode.emu.jit.analysis.JitType.*;
 import ghidra.pcode.emu.jit.op.JitCopyOp;
 import ghidra.pcode.emu.jit.op.JitPhiOp;
+import ghidra.program.model.pcode.Varnode;
 
 /**
  * The behavior/requirement for an operand's type.
@@ -177,6 +178,9 @@ public static JitTypeBehavior forJavaType(Class<?> cls) {
 		if (cls == void.class) {
 			return null;
 		}
+		if (cls == Varnode.class) {
+			return ANY;
+		}
 		if (cls.isPrimitive()) {
 			throw new AssertionError();
 		}
diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DataTreeNode.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DataTreeNode.java
index 5413f340b45..c9ea4326217 100644
--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DataTreeNode.java
+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DataTreeNode.java
@@ -95,7 +95,7 @@ public final boolean isCut() {
 	public abstract ProjectData getProjectData();
 
 	/**
-	 * @returns domain folder/file pathname within project
+	 * {@return domain folder/file pathname within project}
 	 */
 	public abstract String getPathname();
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ListingDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ListingDB.java
index 27d9a25ab79..483d2832e51 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ListingDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ListingDB.java
@@ -235,22 +235,6 @@ public Data getUndefinedDataBefore(Address addr, TaskMonitor monitor) {
 		return codeMgr.getFirstUndefinedDataBefore(addr, monitor);
 	}
 
-	@Override
-	public DataIterator getCompositeData(boolean forward) {
-		return codeMgr.getCompositeData(forward ? program.getMinAddress() : program.getMaxAddress(),
-			forward);
-	}
-
-	@Override
-	public DataIterator getCompositeData(Address start, boolean forward) {
-		return codeMgr.getCompositeData(start, forward);
-	}
-
-	@Override
-	public DataIterator getCompositeData(AddressSetView addrSet, boolean forward) {
-		return codeMgr.getCompositeData(addrSet, forward);
-	}
-
 	@Override
 	public Iterator<String> getUserDefinedProperties() {
 		return codeMgr.getUserDefinedProperties();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java
index 90afd338b19..e66d387bb88 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java
@@ -115,8 +115,9 @@ public class ProgramDB extends DomainObjectAdapterDB implements Program, ChangeM
 	 *                            Multiple blocks are permitted within a single overlay space.
 	 * 13-Dec-2024 - version 29   Added source file manager. 
 	 *  3-Jun-2025 - version 30   Symbol Table schema V4 with external symbol data indexing
+	 * 15-Sep-2025 - version 31   Code Mananger dropped Composites property map use
 	 */
-	static final int DB_VERSION = 30;
+	static final int DB_VERSION = 31;
 
 	/**
 	 * UPGRADE_REQUIRED_BFORE_VERSION should be changed to DB_VERSION anytime the
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
index e63f4ce315a..1ac2dff24d9 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/CodeManager.java
@@ -64,7 +64,6 @@ public class CodeManager implements ErrorHandler, ManagerDB {
 	private ProgramContext contextMgr;
 	private ReferenceManager refManager;
 	private PropertyMapManager propertyMapMgr;
-	private VoidPropertyMapDB compositeMgr;
 	private IntPropertyMapDB lengthMgr;
 
 	private boolean contextLockingEnabled = false;
@@ -97,8 +96,6 @@ public CodeManager(DBHandle handle, AddressMap addrMap, OpenMode openMode, Lock
 
 		cache = new DBObjectCache<>(1000);
 		protoMgr = new PrototypeManager(handle, addrMap, openMode, monitor);
-		compositeMgr =
-			new VoidPropertyMapDB(dbHandle, openMode, this, null, addrMap, "Composites", monitor);
 		lengthMgr =
 			new IntPropertyMapDB(dbHandle, openMode, this, null, addrMap, "Lengths", monitor);
 
@@ -131,6 +128,15 @@ private void checkOldFallThroughMaps(DBHandle handle, OpenMode openMode, TaskMon
 		}
 	}
 
+	private void removeOldCompositeMap() throws IOException {
+		// Remove old Composites Void property map associated with tracking composite 
+		// placement in memory.  This tracking mechanism was never used.
+		String oldTableName = "Property Map - Composites";
+		if (dbHandle.getTable(oldTableName) != null) {
+			dbHandle.deleteTable(oldTableName);
+		}
+	}
+
 	/*
 	 * Convert old fall-through overrides into References.
 	 */
@@ -235,6 +241,7 @@ public void programReady(OpenMode openMode, int currentRevision, TaskMonitor mon
 			throws IOException, CancelledException {
 		if (openMode == OpenMode.UPGRADE) {
 			upgradeOldFallThroughMaps(monitor);
+			removeOldCompositeMap();
 		}
 	}
 
@@ -751,7 +758,6 @@ private void deleteAddressRange(Address start, Address end, boolean keepComments
 		lock.acquire();
 		boolean success = false;
 		try {
-			compositeMgr.removeRange(start, end);
 			monitor.checkCancelled();
 			instAdapter.deleteRecords(start, end);
 			monitor.checkCancelled();
@@ -2061,12 +2067,6 @@ else if (dataType instanceof Dynamic) {
 			data = getDataDB(record);
 			baseDt = data.getBaseDataType();
 
-			if (dataType instanceof Composite || dataType instanceof Array ||
-				dataType instanceof Dynamic) {
-				compositeMgr.add(addr);
-				program.setChanged(ProgramEvent.COMPOSITE_ADDED, addr, endAddr, null, null);
-			}
-
 			// fire event
 			program.setChanged(ProgramEvent.CODE_ADDED, addr, endAddr, null, data);
 
@@ -2399,43 +2399,6 @@ public int getNumDefinedData() {
 		return 0;
 	}
 
-	/**
-	  * Returns a composite data iterator beginning at the specified start address.
-	  *
-	  * @param start the address to begin iterator
-	  * @param forward true means get iterator in forward direction
-	  * @return the composite data iterator
-	  */
-	public DataIterator getCompositeData(Address start, boolean forward) {
-		try {
-			return new DataKeyIterator(this, addrMap,
-				compositeMgr.getAddressKeyIterator(start, forward));
-		}
-		catch (IOException e) {
-			program.dbError(e);
-		}
-		return null;
-	}
-
-	/**
-	 * Returns a composite data iterator limited to the addresses in the specified address set.
-	 *
-	 * @param addrSet the address set to limit the iterator
-	 * @param forward determines if the iterator will go from the lowest address to the highest or 
-	 * the other way around. 
-	 * @return DataIterator the composite data iterator
-	 */
-	public DataIterator getCompositeData(AddressSetView addrSet, boolean forward) {
-		try {
-			return new DataKeyIterator(this, addrMap,
-				compositeMgr.getAddressKeyIterator(addrSet, forward));
-		}
-		catch (IOException e) {
-			program.dbError(e);
-		}
-		return null;
-	}
-
 	/**
 	 * Returns an iterator over all codeUnits in the program from the given start address to either 
 	 * the end address or the start address, depending if the iterator is forward or not.
@@ -2856,7 +2819,6 @@ private void moveDefinedCodeUnits(Address startAddr, Address newStartAddr, long
 		try {
 			Address endAddr = startAddr.add(length - 1);
 
-			compositeMgr.moveRange(startAddr, endAddr, newStartAddr);
 			monitor.checkCancelled();
 
 			lengthMgr.moveRange(startAddr, endAddr, newStartAddr);
@@ -3205,7 +3167,6 @@ public void invalidateCache(boolean all) {
 		try {
 			cache.invalidate();
 			lengthMgr.invalidate();
-			compositeMgr.invalidate();
 			protoMgr.clearCache();
 		}
 		finally {
@@ -3227,12 +3188,7 @@ public void invalidateCodeUnitCache() {
 	 */
 	public void memoryChanged(Address addr, Address end) {
 		lock.acquire();
-//    	CodeUnit cu = getCodeUnitContaining(addr);
-//    	if (cu != null) {
-//    		addr = cu.getMinAddress();
-//    	}
 		try {
-//    		cache.invalidate(addrMap.getKey(addr), addrMap.getKey(end));
 			cache.invalidate();
 		}
 		finally {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/Listing.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/Listing.java
index 294db1a4dad..3ddbcc0bf1e 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/Listing.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/Listing.java
@@ -604,39 +604,6 @@ public AddressSetView getUndefinedRanges(AddressSetView set, boolean initialized
 	 */
 	public CodeUnit getDefinedCodeUnitBefore(Address addr);
 
-	/**
-	 * Get an iterator over all the composite data objects (Arrays, Structures,
-	 * and Union) in the program.
-	 *
-	 * @param forward true means get iterator that starts at the minimum address
-	 *            and iterates forward. Otherwise it starts at the maximum
-	 *            address and iterates backwards.
-	 * @return an iterator over all the composite data objects.
-	 */
-	public DataIterator getCompositeData(boolean forward);
-
-	/**
-	 * Get an iterator over all the composite data objects (Arrays, Structures,
-	 * and Union) in the program at or after the given Address.
-	 *
-	 * @param start start of the iterator
-	 * @param forward true means get iterator in forward direction
-	 * @return an iterator over all the composite data objects starting with the
-	 *         given address.
-	 */
-	public DataIterator getCompositeData(Address start, boolean forward);
-
-	/**
-	 * Get an iterator over all the composite data objects (Arrays, Structures,
-	 * and Union) within the specified address set in the program.
-	 *
-	 * @param addrSet the address set
-	 * @param forward true means get iterator in forward direction
-	 * @return an iterator over all the composite data objects in the given
-	 *         address set.
-	 */
-	public DataIterator getCompositeData(AddressSetView addrSet, boolean forward);
-
 	/**
 	 * Returns an iterator over all user defined property names.
 	 *
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/StubListing.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/StubListing.java
index f6722b6ea76..043a257b931 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/StubListing.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/StubListing.java
@@ -267,21 +267,6 @@ public CodeUnit getDefinedCodeUnitBefore(Address addr) {
 		throw new UnsupportedOperationException();
 	}
 
-	@Override
-	public DataIterator getCompositeData(boolean forward) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public DataIterator getCompositeData(Address start, boolean forward) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public DataIterator getCompositeData(AddressSetView addrSet, boolean forward) {
-		throw new UnsupportedOperationException();
-	}
-
 	@Override
 	public Iterator<String> getUserDefinedProperties() {
 		throw new UnsupportedOperationException();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ChangeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ChangeManager.java
index 842101131bc..e98dd70595b 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ChangeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ChangeManager.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -199,20 +199,6 @@ public void setPropertyChanged(String propertyName, Address codeUnitAddr, Object
 	@Deprecated
 	public static final ProgramEvent DOCR_CODE_MOVED = FRAGMENT_CHANGED;
 
-	/**
-	 * Structure was added.
-	 * @deprecated Event type numeric constants have been changed to enums. Use the enum directly.
-	 */
-	@Deprecated
-	public static final ProgramEvent DOCR_COMPOSITE_ADDED = COMPOSITE_ADDED;
-
-	/**
-	 * Structure was removed.
-	 * @deprecated Event type numeric constants have been changed to enums. Use the enum directly.
-	 */
-	@Deprecated
-	public static final ProgramEvent DOCR_COMPOSITE_REMOVED = COMPOSITE_REMOVED;
-
 	/**
 	 * Data was replaced.
 	 * @deprecated Event type numeric constants have been changed to enums. Use the enum directly.
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramEvent.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramEvent.java
index e3870e0f8f5..528a0f66d11 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramEvent.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramEvent.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,9 +37,6 @@ public enum ProgramEvent implements EventType {
 	CODE_REMOVED,						// instructions or data cleared at an address
 	CODE_REPLACED,						// the instruction or data type at an address was changed
 
-	COMPOSITE_ADDED,					// a non-primitive data type was added
-	COMPOSITE_REMOVED,					// a non-primitive data type was removed
-
 	CODE_UNIT_PROPERTY_CHANGED,			// a property map value changed
 	CODE_UNIT_PROPERTY_ALL_REMOVED,		// a property map was removed
 	CODE_UNIT_PROPERTY_RANGE_REMOVED,	// a ranges of values was removed
```
-----------------------------------
