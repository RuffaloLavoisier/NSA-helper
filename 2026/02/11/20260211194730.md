# Commit: b09b34c64edbbbd6612f8c4d62ebd50a65f68490
## Message: GP-5882 Avoid change notification cascade when deleted datatype dependencies are changed or deleted. Fix impact to composite editor. Improve datatype replace validation.
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
index 3d20fb27de7..56e3868fce1 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java
@@ -1331,17 +1331,30 @@ public void dataTypeRemoved(DataTypeManager dtm, DataTypePath path) {
 			return;
 		}
 
-		DataType dataType = viewDTM.getDataType(path);
-		if (dataType == null) {
-			return;
-		}
-
 		if (!path.equals(originalDataTypePath)) {
+
+			DataType dataType = viewDTM.getDataType(path);
+			if (dataType == null) {
+				return;
+			}
+
 			if (!viewDTM.isViewDataTypeFromOriginalDTM(dataType)) {
 				return;
 			}
+
+			// Preserve pointers to edited composite
+			DataType basePtrDt = dataType;
+			if (basePtrDt instanceof Pointer ptr) {
+				basePtrDt = ptr.getDataType();
+			}
+			if (basePtrDt == viewComposite) {
+				// ignore removal of pointers to edited composite so that they persist if
+				// reloadFromView is used.
+				return;
+			}
+
 			if (hasSubDt(viewComposite, path)) {
-				String msg = "Removed sub-component data type \"" + path;
+				String msg = "Removed sub-component data type \"" + path + "\"";
 				setStatus(msg, true);
 			}
 			viewDTM.withTransaction("Removed Dependency", () -> {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/rich/RichObjectCountDataType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/rich/RichObjectCountDataType.java
index a4b411f49f0..6e87e1f72d0 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/rich/RichObjectCountDataType.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/rich/RichObjectCountDataType.java
@@ -107,8 +107,4 @@ public void dataTypeNameChanged(DataType dt, String oldName) {
 		// ignored
 	}
 
-	@Override
-	public boolean dependsOn(DataType dt) {
-		return false;
-	}
 }
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
index 13dfb24b802..b88a0bc8a2b 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/compositeeditor/StructureEditorNotifiedTest.java
@@ -89,18 +89,98 @@ public void testEditedDataTypeRemoved() throws Exception {
 		assertEquals(4, getLength(10));
 
 		programDTM.remove(complexStructure);
-		programDTM.getCategory(pgmRootCat.getCategoryPath())
-				.removeCategory("Temp", TaskMonitor.DUMMY);
 
 		DialogComponentProvider dlg = waitForDialogComponent("Close Structure Editor?");
 		pressButton(dlg.getComponent(), "No");
 		waitForSwing();
 
-		// complexStructure* gets removed and becomes BadDataType in this editor.
 		assertEquals(num, model.getNumComponents());
 		assertEquals(len, model.getLength());
 		assertEquals("The original Structure has been deleted", model.getStatus());
+
+		// Verify pointer to edited composite remains valid within editor
+		dataType10 = getDataType(10);
+		assertEquals("complexStructure *", dataType10.getDisplayName());
 		assertEquals(4, getLength(10));
+		assertFalse(dataType10.isDeleted());
+
+		assertTrue(model.hasChanges());
+	}
+
+	@Test
+	public void testCategoryRemoved() throws Exception {
+
+		Category tempCat = modifyProgram(program, p -> {
+			Category tempCategory = pgmRootCat.createCategory("Temp");
+			tempCategory.moveDataType(complexStructure, DataTypeConflictHandler.DEFAULT_HANDLER);
+			return tempCategory;
+		});
+
+		init(complexStructure, tempCat);
+		int num = model.getNumComponents();
+		int len = model.getLength();
+		DataType dataType4 = getDataType(4);
+		assertEquals("simpleUnion", dataType4.getDisplayName());
+		assertEquals(8, getLength(4));
+
+		programDTM.getCategory(new CategoryPath("/aa")).removeCategory("bb", TaskMonitor.DUMMY);
+		waitForSwing();
+
+		// NOTE: No prompt when non-edited data types are removed - direct update imposed
+
+		assertEquals(num, model.getNumComponents());
+		assertEquals(len, model.getLength());
+		assertEquals("", model.getStatus());
+
+		// Verify pointer to edited composite remains valid within editor
+		dataType4 = getDataType(4);
+		assertEquals("-BAD-", dataType4.getDisplayName());
+		assertEquals(8, getLength(4));
+
+		assertFalse(model.hasChanges());
+	}
+
+	@Test
+	public void testModifiedCategoryRemoved() throws Exception {
+
+		Category tempCat = modifyProgram(program, p -> {
+			Category tempCategory = pgmRootCat.createCategory("Temp");
+			tempCategory.moveDataType(complexStructure, DataTypeConflictHandler.DEFAULT_HANDLER);
+			return tempCategory;
+		});
+
+		init(complexStructure, tempCat);
+
+		runSwingWithException(() -> {
+			model.insert(model.getNumComponents(), new ByteDataType(), 1);
+			model.insert(model.getNumComponents(), new PointerDataType(), 4);
+		});
+
+		waitForSwing();
+
+		int num = model.getNumComponents();
+		int len = model.getLength();
+		DataType dataType4 = getDataType(4);
+		assertEquals("simpleUnion", dataType4.getDisplayName());
+		assertEquals(8, getLength(4));
+
+		programDTM.getCategory(new CategoryPath("/aa")).removeCategory("bb", TaskMonitor.DUMMY);
+		waitForSwing();
+
+		DialogComponentProvider dlg = waitForDialogComponent("Reload Structure Editor?");
+		pressButton(dlg.getComponent(), "No");
+		waitForSwing();
+
+		assertEquals(num, model.getNumComponents());
+		assertEquals(len, model.getLength());
+		assertEquals("Removed sub-component data type \"/aa/bb/simpleUnion\"", model.getStatus());
+
+		// Verify pointer to edited composite remains valid within editor
+		dataType4 = getDataType(4);
+		assertEquals("-BAD-", dataType4.getDisplayName());
+		assertEquals(8, getLength(4));
+
+		assertTrue(model.hasChanges());
 	}
 
 	@Test
@@ -504,8 +584,7 @@ public void testComponentDataTypeRemoved() {
 		assertEquals(23, model.getNumComponents());
 		assertEquals(0x145, model.getLength());
 
-		runSwing(
-			() -> complexStructure.getDataTypeManager().remove(simpleUnion));
+		runSwing(() -> complexStructure.getDataTypeManager().remove(simpleUnion));
 		waitForSwing();
 		assertEquals(23, model.getNumComponents());
 		assertTrue(dt3.isEquivalent(getDataType(3)));
@@ -535,8 +614,7 @@ public void testOnlyComponentDataTypeRemoved() throws Exception {
 		assertEquals(1, model.getNumComponents());
 		assertTrue(simpleStructure.isEquivalent(getDataType(0)));
 
-		runSwing(
-			() -> simpleStructure.getDataTypeManager().remove(simpleStructure));
+		runSwing(() -> simpleStructure.getDataTypeManager().remove(simpleStructure));
 		waitForSwing();
 
 		assertEquals(1, model.getNumComponents());// component becomes BadDataType
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/model/data/DataTypeTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/model/data/DataTypeTest.java
index 774bbad8010..ec0fb10d561 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/model/data/DataTypeTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/model/data/DataTypeTest.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -121,6 +121,50 @@ public void testConflictRenameAndAdd() {
 
 	}
 
+	@Test
+	public void testReplaceWith() {
+		int txId = program.startTransaction("Pointer Test");
+
+		Structure struct1 =
+			(Structure) dtm.resolve(createStruct("abc", new ByteDataType(), 10), null);
+
+		Structure struct2 =
+			(Structure) dtm.resolve(createStruct("xyz", new ByteDataType(), 10), null);
+
+		Pointer ptr1 = (Pointer) dtm.resolve(new PointerDataType(struct1), null); // ptr1 -> struct1
+
+		Pointer ptr2 = (Pointer) dtm.resolve(new PointerDataType(struct2), null); // ptr2 -> struct2
+
+		struct1.add(ptr2);
+		struct2.add(ptr1);
+
+		// ptr1 -> struct1 { ptr2 -> struct2 { ptr1 } }
+
+		try {
+			DataType dt = dtm.replaceDataType(struct2, ptr2, false);
+			// ptr2 cannot exist without struct2
+			fail("Expected dependency exception");
+		}
+		catch (DataTypeDependencyException e) {
+			// expected - ignore
+		}
+
+		DataTypeComponent dtc = struct1.getComponent(10);
+		assertEquals(ptr2, dtc.getDataType());
+		try {
+			struct1 = (Structure) dtm.replaceDataType(ptr2, struct1, false);
+			// Replacement will trip on dependency and force replacement with undefined component
+			dtc = struct1.getComponent(10);
+			assertEquals(DataType.DEFAULT, dtc.getDataType());
+		}
+		catch (DataTypeDependencyException e) {
+			fail("Unexpected dependsOn error");
+		}
+
+		program.endTransaction(txId, true);
+
+	}
+
 	@Test
 	public void testReplaceWithStructureContainingReplacedStructure() {
 		int txId = program.startTransaction("Add Struct");
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ArrayDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ArrayDB.java
index 0f95035c917..ecd532fc2de 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ArrayDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/ArrayDB.java
@@ -265,15 +265,17 @@ public boolean isEquivalent(DataType dt) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
+		if (deleting) {
+			return;
+		}
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		lock.acquire();
 		try {
-			checkIsValid();
-			if (newDt == this || newDt.getLength() < 0) {
-				newDt = DataType.DEFAULT;
-			}
-
+			checkDeleted();
 			if (oldDt == getDataType()) {
-
+				if (newDt == this) {
+					newDt = DataType.DEFAULT;
+				}
 				int oldElementLength = getElementLength();
 				int newElementLength =
 					elementLength = newDt.getLength() < 0 ? oldElementLength : -1;
@@ -345,9 +347,13 @@ public void setName(String name) throws InvalidNameException, DuplicateNameExcep
 
 	@Override
 	public void dataTypeSizeChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			if (checkIsValid() && dt == getDataType() && dt.getLength() > 0) {
+			checkDeleted();
+			if (dt == getDataType() && dt.getLength() > 0) {
 				elementLength = -1;
 				notifySizeChanged(true);
 			}
@@ -359,9 +365,13 @@ public void dataTypeSizeChanged(DataType dt) {
 
 	@Override
 	public void dataTypeAlignmentChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			if (checkIsValid() && dt == getDataType()) {
+			checkDeleted();
+			if (dt == getDataType()) {
 				notifyAlignmentChanged(true);
 			}
 		}
@@ -392,18 +402,33 @@ protected void doSetNameRecord(String newName) throws InvalidNameException {
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
-		if (getDataType() == dt) {
-			elementLength = -1;
-			dataMgr.addDataTypeToDelete(key);
+		if (deleting) {
+			return;
+		}
+		lock.acquire();
+		try {
+			checkDeleted();
+			if (dt == getDataType()) {
+				elementLength = -1;
+				dataMgr.addDataTypeToDelete(this, key);
+				deleting = true;
+			}
+		}
+		finally {
+			lock.release();
 		}
 	}
 
 	@Override
 	public void dataTypeNameChanged(DataType dt, String oldName) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			String myOldName = getOldName();
-			if (checkIsValid() && dt == getDataType()) {
+			checkDeleted();
+			if (dt == getDataType()) {
+				String myOldName = getOldName();
 				refreshName();
 				if (!getName().equals(myOldName)) {
 					notifyNameChanged(myOldName);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CompositeDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CompositeDB.java
index 74237059a01..12b5e41c4e8 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CompositeDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/CompositeDB.java
@@ -313,33 +313,13 @@ public boolean isPartOf(DataType dataTypeOfInterest) {
 		}
 	}
 
-	/**
-	 * This method throws an exception if the indicated data type is an ancestor of
-	 * this data type. In other words, the specified data type has a component or
-	 * sub-component containing this data type.
-	 * 
-	 * @param dataType the data type
-	 * @throws DataTypeDependencyException if the data type is an ancestor of this
-	 *                                     data type.
-	 */
-	protected void checkAncestry(DataType dataType) throws DataTypeDependencyException {
-		if (this.equals(dataType)) {
-			throw new DataTypeDependencyException(
-				"Data type " + getDisplayName() + " can't contain itself.");
-		}
-		else if (DataTypeUtilities.isSecondPartOfFirst(dataType, this)) {
-			throw new DataTypeDependencyException("Data type " + dataType.getDisplayName() +
-				" has " + getDisplayName() + " within it.");
-		}
-	}
-
 	protected DataType doCheckedResolve(DataType dt) throws DataTypeDependencyException {
 		if (dt instanceof Pointer) {
 			pointerPostResolveRequired = true;
 			return resolve(((Pointer) dt).newPointer(DataType.DEFAULT));
 		}
 		dt = resolve(dt);
-		checkAncestry(dt);
+		DataTypeUtilities.checkAncestry(this, dt);
 		return dt;
 	}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
index ea1750f91e8..2381daeca47 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
@@ -44,6 +44,7 @@ abstract class DataTypeDB extends DatabaseObject implements DataType {
 	private final static TypeDefSettingsDefinition[] EMPTY_TYPEDEF_DEFINITIONS =
 		new TypeDefSettingsDefinition[0];
 	protected boolean resolving;
+	protected boolean deleting;
 	protected boolean pointerPostResolveRequired;
 	protected Lock lock;
 	private volatile String name;
@@ -57,6 +58,16 @@ protected DataTypeDB(DataTypeManagerDB dataMgr, DBObjectCache<DataTypeDB> cache,
 		this.lock = dataMgr.lock;
 	}
 
+	/**
+	 * Invoked by {@link DataTypeManagerDB} when operation has started to delete this datatype.
+	 * In this state any invocation of other datatype changes should be ignored as reflected
+	 * by {@code deleting} variable.  Once this state is changed and cannot be reverted for this 
+	 * instance.
+	 */
+	protected final void deleteStarted() {
+		deleting = true;
+	}
+
 	/**
 	 * Clears the current name so that the next invocation of {@link #getName()} will
 	 * force its update via {@link #doGetName()}.  It is important that {@link #doGetName()}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
index 28cb21906c9..58dfc2794e3 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java
@@ -1884,23 +1884,17 @@ private void disassociateAllDataTypes(UniversalID sourceArchiveID) {
 
 	@Override
 	public DataType replaceDataType(DataType existingDt, DataType replacementDt,
-			boolean updateCategoryPath) throws DataTypeDependencyException {
-		// Note: we should probably disallow replacementDt to be an instanceof
-		// Dynamic or FactoryDataType
+			boolean updateCategoryPath)
+			throws DataTypeDependencyException, IllegalArgumentException {
 		lock.acquire();
 		try {
-			// Don't support replacement with Factory or Dynamic datatype
-			if (replacementDt instanceof Dynamic || replacementDt instanceof FactoryDataType) {
-				throw new IllegalArgumentException(
-					"Datatype replacment with dynamic or factory type not permitted.");
-			}
 			if (!contains(existingDt)) {
 				throw new IllegalArgumentException(
 					"Datatype to replace is not contained in this datatype manager.");
 			}
-			if (existingDt instanceof BadDataType) {
-				throw new IllegalArgumentException("BAD Datatype can be deleted but not replaced.");
-			}
+
+			DataTypeUtilities.checkValidReplacement(existingDt, replacementDt);
+
 			boolean fixupName = false;
 			if (!contains(replacementDt)) {
 				replacementDt = replacementDt.clone(this);
@@ -2000,12 +1994,21 @@ private void replaceQueuedDataTypes() {
 			dataTypeReplacementMap.put(replacedId, replacementId);
 		}
 
-		// perform any neccessary external use replacements
+		// perform any necessary external use replacements
 		replaceDataTypesUsed(dataTypeReplacementMap);
 
 		// perform actual database updates (e.g., record updates, change notifications, etc.)
 		for (Pair<DataType, DataType> dataTypeReplacement : dataTypeReplacements) {
-			replaceDataType(dataTypeReplacement.first, dataTypeReplacement.second);
+
+			DataType replacedDt = dataTypeReplacement.first;
+			DataType replacementDt = dataTypeReplacement.second;
+
+			long replacedId = getID(replacedDt);
+
+			deleteDataType(replacedId, false); // notify as replacement next
+
+			// Provide replacement notification
+			dataTypeReplaced(replacedId, replacedDt.getDataTypePath(), replacementDt);
 		}
 	}
 
@@ -2015,26 +2018,6 @@ private void replaceQueuedDataTypes() {
 	 */
 	abstract protected void replaceDataTypesUsed(Map<Long, Long> dataTypeReplacementMap);
 
-	private void replaceDataType(DataType replacedDt, DataType replacementDt) {
-
-		DataTypePath replacedDtPath = replacedDt.getDataTypePath();
-		long replacedId = getID(replacedDt);
-
-		UniversalID id = replacedDt.getUniversalID();
-		idsToDataTypeMap.removeDataType(replacedDt.getSourceArchive(), id);
-
-		try {
-			parentChildAdapter.removeAllRecordsForParent(replacedId);
-		}
-		catch (IOException e) {
-			dbError(e);
-		}
-		deleteDataTypeRecord(replacedId);
-		dtCache.delete(replacedId);
-
-		dataTypeReplaced(replacedId, replacedDtPath, replacementDt);
-	}
-
 	private void replaceUsesInOtherDataTypes(DataType existingDt, DataType newDt) {
 		if (existingDt instanceof DataTypeDB) {
 			// Notify parents that a dependency has been replaced.  For pointers and arrays
@@ -2353,8 +2336,8 @@ private boolean removeInternal(DataType dataType) {
 		}
 
 		if (dataType instanceof BadDataType) {
-			// Cannot really replace BAD datatype which is generally not directly referenced
-			deleteDataType(BAD_DATATYPE_ID);
+			// Cannot really replace BAD datatype use as a place holder - just its managed instance 
+			deleteDataType(BAD_DATATYPE_ID, true);
 			return true;
 		}
 
@@ -2363,7 +2346,9 @@ private boolean removeInternal(DataType dataType) {
 			return false;
 		}
 
-		idsToDelete.add(id);
+		// Queue datatype for removal
+		addDataTypeToDelete(dataType, id);
+
 		removeQueuedDataTypes();
 		return true;
 	}
@@ -2380,7 +2365,8 @@ private void removeInternal(List<DataType> dataTypes) {
 				continue;
 			}
 
-			idsToDelete.add(id);
+			// Queue datatype for removal
+			addDataTypeToDelete(dt, id);
 		}
 
 		removeQueuedDataTypes();
@@ -2408,7 +2394,7 @@ private void removeQueuedDataTypes() {
 					"' has been retained for use by defined bitfields");
 				continue;
 			}
-			deleteDataType(id);
+			deleteDataType(id, true);
 		}
 		blockedRemovalsByID = null;
 	}
@@ -2562,7 +2548,10 @@ private boolean isSourceSettable(DataType dataType) {
 	 * Queue a datatype to deleted in response to another datatype being deleted.
 	 * @param id datatype ID to be removed
 	 */
-	protected void addDataTypeToDelete(long id) {
+	protected void addDataTypeToDelete(DataType dt, long id) {
+		if (dt instanceof DataTypeDB dbDt) {
+			dbDt.deleteStarted();
+		}
 		idsToDelete.add(Long.valueOf(id));
 	}
 
@@ -2578,6 +2567,9 @@ protected void addDataTypeToReplace(DataType oldDataType, DataType replacementDa
 		if (oldDataType == replacementDataType) {
 			throw new AssertionError("Invalid datatype replacement pair");
 		}
+		if (oldDataType instanceof DataTypeDB dbDt) {
+			dbDt.deleteStarted();
+		}
 		typesToReplace.add(new Pair<>(oldDataType, replacementDataType));
 	}
 
@@ -2606,7 +2598,7 @@ private void notifyDeleted(long dataTypeID) {
 
 	}
 
-	private void deleteDataType(long dataTypeID) {
+	private void deleteDataType(long dataTypeID, boolean notify) {
 
 		DataType dataType = getDataType(dataTypeID);
 		if (dataType == null) {
@@ -2618,6 +2610,7 @@ private void deleteDataType(long dataTypeID) {
 		}
 
 		deleteDataTypeRecord(dataTypeID);
+
 		try {
 			parentChildAdapter.removeAllRecordsForParent(dataTypeID);
 		}
@@ -2626,10 +2619,13 @@ private void deleteDataType(long dataTypeID) {
 		}
 		dtCache.delete(dataTypeID);
 		favoritesList.remove(dataType);
-		// DT Should delete data type update the sync time or last change time?
-//		updateLastSyncTime((new Date()).getTime()); // Update my Last Sync Time in the Archive ID table.
-		DataTypePath deletedDtPath = dataType.getDataTypePath();
-		dataTypeDeleted(dataTypeID, deletedDtPath);
+
+		// NOTE: There is no need to update archive sync time for removal.  It is only the
+		// possible updates to other datatypes that would need to trigger such a modification time.
+
+		if (notify) {
+			dataTypeDeleted(dataTypeID, dataType.getDataTypePath());
+		}
 	}
 
 	private void deleteDataTypeRecord(long dataTypeID) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeUtilities.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeUtilities.java
index 5d76895dc6d..6de06c754d9 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeUtilities.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeUtilities.java
@@ -190,6 +190,107 @@ public static boolean isSecondPartOfFirst(DataType firstDataType, DataType secon
 		return false;
 	}
 
+	/**
+	 * This method throws an exception if the indicated component data type is an ancestor of
+	 * the specified dataType (i.e., the specified component data type has a component or
+	 * sub-component containing the specified dataType).
+	 * 
+	 * @param dataType the data type
+	 * @param componentDataType component data type
+	 * @throws DataTypeDependencyException if ancestry check fails
+	 */
+	public static void checkAncestry(DataType dataType, DataType componentDataType)
+			throws DataTypeDependencyException {
+		if (DataTypeUtilities.isSecondPartOfFirst(componentDataType, dataType)) {
+			throw new DataTypeDependencyException(
+				"Data type " + componentDataType.getDisplayName() + " has " +
+					dataType.getDisplayName() + " within it.");
+		}
+	}
+
+	/**
+	 * Check if the specified replacement data type pair is invalid.
+	 * @param replacedDt existing data type being replaced
+	 * @param replacementDt replacement data type
+	 * @throws IllegalArgumentException if an invalid replaced/replacement data type pair is specified.
+	 */
+	public static void checkValidReplacement(DataType replacedDt, DataType replacementDt)
+			throws IllegalArgumentException {
+
+		DataTypeUtilities.checkValidReplacementDataType(replacedDt);
+		DataTypeUtilities.checkValidReplacementDataType(replacementDt);
+
+		checkForInvalidFunctionDefinitionReplacement(replacedDt, replacementDt);
+	}
+
+	/**
+	 * Validate the replacement data type.  Certain data types are not permitted
+	 * to participate in a replacement including a {@link FactoryDataType}, {@link Dynamic} or
+	 * {@link BitFieldDataType}.
+	 * @param dataType data type to be checked
+	 * @throws IllegalArgumentException if an invalid datatype is specified.
+	 */
+	private static void checkValidReplacementDataType(DataType dataType) {
+		if (dataType instanceof DataTypeDB) {
+			return;
+		}
+		if (dataType instanceof VoidDataType) {
+			throw new IllegalArgumentException("Replacement data type may not be 'void' data type");
+		}
+		if (dataType instanceof DefaultDataType) {
+			throw new IllegalArgumentException(
+				"Replacement data type may not be 'default' undefined data type");
+		}
+		if (dataType instanceof BitFieldDataType) {
+			throw new IllegalArgumentException(
+				"Replacement data type may not be a bitfield: " + dataType.getName());
+		}
+		if (dataType instanceof FactoryDataType) {
+			throw new IllegalArgumentException(
+				"Replacement data type may not be a Factory data type: " + dataType.getName());
+		}
+		if (dataType instanceof Dynamic) {
+			throw new IllegalArgumentException(
+				"Replacement data type may not be a Dynamic data type: " + dataType.getName());
+		}
+	}
+
+	/**
+	 * Determine if the replacement data type pair represents an invalid function definition 
+	 * replacement.
+	 * @param replacedDt replaced data type to be replaced
+	 * @param replacementDt new replacement data type
+	 * @throws IllegalArgumentException if an invalid replaced/replacement data type pair is specified.
+	 */
+	private static void checkForInvalidFunctionDefinitionReplacement(DataType replacedDt,
+			DataType replacementDt) throws IllegalArgumentException {
+
+		DataType replacedBaseDt = replacedDt;
+		if (replacedDt instanceof TypeDef replacedTypedef) {
+			replacedBaseDt = replacedTypedef.getBaseDataType();
+		}
+
+		DataType replacementBaseDt = replacementDt;
+		if (replacementDt instanceof TypeDef replacementTypedef) {
+			replacementBaseDt = replacementTypedef.getBaseDataType();
+		}
+
+		// Impose similarity constraints
+		if (replacedBaseDt instanceof FunctionDefinition) {
+			if (!(replacementBaseDt instanceof FunctionDefinition)) {
+				throw new IllegalArgumentException(
+					"Existing function definition \"" + replacedDt.getName() +
+						"\" may not be replaced with \"" + replacementDt.getName() + "\"");
+			}
+		}
+		else if (replacementBaseDt instanceof FunctionDefinition) {
+			throw new IllegalArgumentException("Existing data type \"" + replacedDt.getName() +
+				"\" may not be replaced with function definition \"" + replacementDt.getName() +
+				"\"");
+		}
+
+	}
+
 	/**
 	 * Returns true if the two dataTypes have the same sourceArchive and the same UniversalID
 	 *
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/EnumDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/EnumDB.java
index ab521337561..64cc3102dd8 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/EnumDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/EnumDB.java
@@ -731,11 +731,6 @@ record = rec;
 		return false;
 	}
 
-	@Override
-	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		// not applicable
-	}
-
 	@Override
 	protected void doSetCategoryPathRecord(long categoryID) throws IOException {
 		record.setLongValue(EnumDBAdapter.ENUM_CAT_COL, categoryID);
@@ -753,6 +748,11 @@ public void dataTypeDeleted(DataType dt) {
 		// not applicable
 	}
 
+	@Override
+	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
+		// not applicable
+	}
+
 	@Override
 	public void dataTypeNameChanged(DataType dt, String oldName) {
 		// not applicable
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/FunctionDefinitionDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/FunctionDefinitionDB.java
index 59306cec2b3..4c33bd2a80b 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/FunctionDefinitionDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/FunctionDefinitionDB.java
@@ -412,6 +412,9 @@ public void setComment(String comment) {
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
 			checkDeleted();
@@ -538,6 +541,10 @@ protected void doSetNameRecord(String name) throws IOException {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
+		if (deleting) {
+			return;
+		}
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		lock.acquire();
 		try {
 			checkDeleted();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
index fe3240f72d9..6b8ac7ba27d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
@@ -356,13 +356,17 @@ public boolean isEquivalent(DataType dt) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		if (newDt == this) {
-			newDt = DataType.DEFAULT;
+		if (deleting) {
+			return;
 		}
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		lock.acquire();
 		try {
-			if (checkIsValid() && getDataType() == oldDt) {
-
+			checkDeleted();
+			if (oldDt == getDataType()) {
+				if (newDt == this) {
+					newDt = DataType.DEFAULT;
+				}
 				// check for existing pointer to newDt
 				PointerDataType newPtr = new PointerDataType(newDt,
 					hasLanguageDependantLength() ? -1 : getLength(), dataMgr);
@@ -374,6 +378,7 @@ public void dataTypeReplaced(DataType oldDt, DataType newDt) {
 					return;
 				}
 
+				// If newDt pointer not found above revise this pointer which may include category change
 				if (!newDt.getCategoryPath().equals(oldDt.getCategoryPath())) {
 					// move this pointer to same category as newDt
 					try {
@@ -409,8 +414,19 @@ public void dataTypeReplaced(DataType oldDt, DataType newDt) {
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
-		if (getDataType() == dt) {
-			dataMgr.addDataTypeToDelete(key);
+		if (deleting) {
+			return;
+		}
+		lock.acquire();
+		try {
+			checkDeleted();
+			if (dt == getDataType()) {
+				dataMgr.addDataTypeToDelete(this, key);
+				deleting = true;
+			}
+		}
+		finally {
+			lock.release();
 		}
 	}
 
@@ -438,10 +454,14 @@ protected void doSetNameRecord(String newName) throws InvalidNameException {
 
 	@Override
 	public void dataTypeNameChanged(DataType dt, String oldName) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			String myOldName = getOldName();
-			if (checkIsValid() && dt == getDataType()) {
+			checkDeleted();
+			if (dt == getDataType()) {
+				String myOldName = getOldName();
 				refreshName();
 				if (!getName().equals(myOldName)) {
 					notifyNameChanged(myOldName);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/StructureDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/StructureDB.java
index 5c14268e8e5..cce82508789 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/StructureDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/StructureDB.java
@@ -193,7 +193,7 @@ private DataTypeComponent doAdd(DataType dataType, int length, String name, Stri
 			if (validatePackAndNotify) {
 				dataType = validateDataType(dataType);
 				dataType = resolve(dataType);
-				checkAncestry(dataType);
+				DataTypeUtilities.checkAncestry(this, dataType);
 			}
 
 			DataTypeComponentDB dtc = null;
@@ -335,7 +335,7 @@ public DataTypeComponent insert(int ordinal, DataType dataType, int length, Stri
 			dataType = validateDataType(dataType);
 
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
 			int idx;
 			if (isPackingEnabled()) {
@@ -1335,7 +1335,7 @@ public DataTypeComponent insertAtOffset(int offset, DataType dataType, int lengt
 			dataType = validateDataType(dataType);
 
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
 			if ((offset > structLength) && !isPackingEnabled()) {
 				numComponents += offset - structLength;
@@ -1467,7 +1467,7 @@ public DataTypeComponent replace(int ordinal, DataType dataType, int length,
 			dataType = validateDataType(dataType);
 
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
 			length = getPreferredComponentLength(dataType, length);
 
@@ -1579,7 +1579,7 @@ public DataTypeComponent replaceAtOffset(int offset, DataType dataType, int leng
 
 			dataType = validateDataType(dataType);
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
 			LinkedList<DataTypeComponentDB> replacedComponents = new LinkedList<>();
 
@@ -1778,17 +1778,17 @@ else if (structAlignment != oldAlignment) {
 
 	private void doReplaceWithPacked(Structure struct, DataType[] resolvedDts) {
 		// assumes components is clear and that alignment characteristics have been set
-		DataTypeComponent[] otherComponents = struct.getDefinedComponents();
-		for (int i = 0; i < otherComponents.length; i++) {
-			DataTypeComponent dtc = otherComponents[i];
-			DataType dt = dtc.getDataType();
-			int length = (dt instanceof Dynamic) ? dtc.getLength() : -1;
-			try {
+		try {
+			DataTypeComponent[] otherComponents = struct.getDefinedComponents();
+			for (int i = 0; i < otherComponents.length; i++) {
+				DataTypeComponent dtc = otherComponents[i];
+				DataType dt = dtc.getDataType();
+				int length = (dt instanceof Dynamic) ? dtc.getLength() : -1;
 				doAdd(resolvedDts[i], length, dtc.getFieldName(), dtc.getComment(), false);
 			}
-			catch (DataTypeDependencyException e) {
-				throw new AssertException(e); // ancestry check already performed by caller
-			}
+		}
+		catch (DataTypeDependencyException e) {
+			throw new AssertException(e); // ancestry check already performed by caller
 		}
 	}
 
@@ -1862,6 +1862,9 @@ private void doCopy(Structure struct, DataTypeComponent[] definedComponents,
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
 			checkDeleted();
@@ -1930,6 +1933,9 @@ private int getAvailableComponentSpace(int index) {
 
 	@Override
 	public void dataTypeSizeChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		if (dt instanceof BitFieldDataType) {
 			return; // unsupported
 		}
@@ -2052,10 +2058,13 @@ else if (length > dtcLen) {
 
 	@Override
 	public void dataTypeAlignmentChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
+			checkDeleted();
 			if (isPackingEnabled()) {
-				checkDeleted();
 				repack(true, true);
 			}
 		}
@@ -2379,9 +2388,10 @@ public String getDefaultLabelPrefix() {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		if (oldDt == this) {
+		if (deleting) {
 			return;
 		}
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		lock.acquire();
 		try {
 			checkDeleted();
@@ -2389,7 +2399,7 @@ public void dataTypeReplaced(DataType oldDt, DataType newDt) {
 			try {
 				replacementDt = validateDataType(replacementDt); // blocks DEFAULT use for packed
 				replacementDt = resolve(replacementDt);
-				checkAncestry(replacementDt);
+				DataTypeUtilities.checkAncestry(this, replacementDt);
 			}
 			catch (Exception e) {
 				// Handle bad replacement with use of undefined component
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/TypedefDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/TypedefDB.java
index 7ff5430054c..311986177d4 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/TypedefDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/TypedefDB.java
@@ -183,9 +183,13 @@ public String getRepresentation(MemBuffer buf, Settings settings, int length) {
 
 	@Override
 	public void dataTypeSizeChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			if (checkIsValid() && dt == getDataType()) {
+			checkDeleted();
+			if (dt == getDataType()) {
 				notifySizeChanged(true);
 			}
 		}
@@ -196,9 +200,13 @@ public void dataTypeSizeChanged(DataType dt) {
 
 	@Override
 	public void dataTypeAlignmentChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
-			if (checkIsValid() && dt == getDataType()) {
+			checkDeleted();
+			if (dt == getDataType()) {
 				notifyAlignmentChanged(true);
 			}
 		}
@@ -314,12 +322,17 @@ protected void doSetCategoryPathRecord(long categoryID) throws IOException {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		if (newDt == this || (newDt instanceof Dynamic) || (newDt instanceof FactoryDataType)) {
-			newDt = DataType.DEFAULT;
+		if (deleting) {
+			return;
 		}
 		lock.acquire();
 		try {
-			if (checkIsValid() && getDataType() == oldDt) {
+			checkDeleted();
+			if (oldDt == getDataType()) {
+				DataTypeUtilities.checkValidReplacement(oldDt, newDt);
+				if (newDt == this) {
+					newDt = DataType.DEFAULT;
+				}
 				settingsDef = null;
 				defaultSettings = null;
 				oldDt.removeParent(this);
@@ -351,15 +364,36 @@ else if (oldDt.getAlignment() != newDt.getAlignment()) {
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
-		if (getDataType() == dt) {
-			dataMgr.addDataTypeToDelete(key);
+		if (deleting) {
+			return;
+		}
+		lock.acquire();
+		try {
+			checkDeleted();
+			if (dt == getDataType()) {
+				dataMgr.addDataTypeToDelete(this, key);
+				deleting = true;
+			}
+		}
+		finally {
+			lock.release();
 		}
 	}
 
 	@Override
 	public void dataTypeNameChanged(DataType dt, String oldName) {
-		if (getDataType() == dt) {
-			updateAutoName(true);
+		if (deleting) {
+			return;
+		}
+		lock.acquire();
+		try {
+			checkDeleted();
+			if (dt == getDataType()) {
+				updateAutoName(true);
+			}
+		}
+		finally {
+			lock.release();
 		}
 	}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/UnionDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/UnionDB.java
index 2bad3845792..013c4baa35f 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/UnionDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/UnionDB.java
@@ -131,7 +131,7 @@ private DataTypeComponent doAdd(DataType dataType, int length, String name, Stri
 
 		if (validateAlignAndNotify) {
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 		}
 
 		length = getPreferredComponentLength(dataType, length);
@@ -169,7 +169,7 @@ public DataTypeComponent insert(int ordinal, DataType dataType, int length, Stri
 			dataType = adjustBitField(dataType);
 
 			dataType = resolve(dataType);
-			checkAncestry(dataType);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
 			getComputedAlignment(true); // ensure previous alignment has been stored
 
@@ -344,7 +344,6 @@ void doReplaceWith(UnionInternal union, boolean notify)
 		DataType[] resolvedDts = new DataType[otherComponents.length];
 		for (int i = 0; i < otherComponents.length; i++) {
 			resolvedDts[i] = doCheckedResolve(otherComponents[i].getDataType());
-			checkAncestry(resolvedDts[i]);
 		}
 
 		for (DataTypeComponentDB dtc : components) {
@@ -535,16 +534,15 @@ protected void fixupComponents() {
 
 	@Override
 	public void dataTypeAlignmentChanged(DataType dt) {
-		if (!isPackingEnabled()) {
+		if (deleting) {
 			return;
 		}
-		if (dt instanceof BitFieldDataType) {
-			return; // unsupported
-		}
 		lock.acquire();
 		try {
 			checkDeleted();
-			repack(true, true);
+			if (isPackingEnabled()) {
+				repack(true, true);
+			}
 		}
 		finally {
 			lock.release();
@@ -553,6 +551,9 @@ public void dataTypeAlignmentChanged(DataType dt) {
 
 	@Override
 	public void dataTypeSizeChanged(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		if (dt instanceof BitFieldDataType) {
 			return; // unsupported
 		}
@@ -719,6 +720,9 @@ else if (oldAlignment != unionAlignment) {
 
 	@Override
 	public void dataTypeDeleted(DataType dt) {
+		if (deleting) {
+			return;
+		}
 		lock.acquire();
 		try {
 			checkDeleted();
@@ -835,9 +839,10 @@ private void shiftOrdinals(int ordinal, int deltaOrdinal) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		if (oldDt == this) {
+		if (deleting) {
 			return;
 		}
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		lock.acquire();
 		try {
 			checkDeleted();
@@ -845,7 +850,7 @@ public void dataTypeReplaced(DataType oldDt, DataType newDt) {
 			try {
 				replacementDt = validateDataType(replacementDt); // blocks DEFAULT use
 				replacementDt = replacementDt.clone(dataMgr);
-				checkAncestry(replacementDt);
+				DataTypeUtilities.checkAncestry(this, replacementDt);
 			}
 			catch (Exception e) {
 				replacementDt = Undefined1DataType.dataType;
@@ -885,22 +890,6 @@ public void dataTypeNameChanged(DataType dt, String oldName) {
 		// ignored
 	}
 
-	@Override
-	public boolean dependsOn(DataType dt) {
-		lock.acquire();
-		try {
-			checkIsValid();
-			if (getNumComponents() == 1) {
-				DataTypeComponent dtc = getComponent(0);
-				return dtc.getDataType().dependsOn(dt);
-			}
-			return false;
-		}
-		finally {
-			lock.release();
-		}
-	}
-
 	@Override
 	public String getDefaultLabelPrefix() {
 		return "UNION_" + getName();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/ArrayDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/ArrayDataType.java
index 2f0e2c59350..2ac70b0ce04 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/ArrayDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/ArrayDataType.java
@@ -278,10 +278,11 @@ public boolean isDeleted() {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		if (newDt == this || newDt.getLength() < 0) {
-			newDt = DataType.DEFAULT;
-		}
 		if (dataType == oldDt) {
+			DataTypeUtilities.checkValidReplacement(oldDt, newDt);
+			if (newDt == this) {
+				newDt = DataType.DEFAULT;
+			}
 			String oldName = getName();
 			int oldLength = getLength();
 			int oldAlignment = getAlignment();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CompositeDataTypeImpl.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CompositeDataTypeImpl.java
index fecaeef6a02..39810f5f644 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CompositeDataTypeImpl.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CompositeDataTypeImpl.java
@@ -175,26 +175,6 @@ public boolean isPartOf(DataType dataTypeOfInterest) {
 		return DataTypeUtilities.isSecondPartOfFirst(this, dataTypeOfInterest);
 	}
 
-	/**
-	 * This method throws an exception if the indicated data type is an ancestor of
-	 * this data type (i.e., the specified data type has a component or
-	 * sub-component containing this data type).
-	 * 
-	 * @param dataType the data type
-	 * @throws IllegalArgumentException if the data type is an ancestor of this data
-	 *                                  type.
-	 */
-	protected void checkAncestry(DataType dataType) throws IllegalArgumentException {
-		if (this.equals(dataType)) {
-			throw new IllegalArgumentException(
-				"Data type " + getDisplayName() + " can't contain itself.");
-		}
-		else if (DataTypeUtilities.isSecondPartOfFirst(dataType, this)) {
-			throw new IllegalArgumentException("Data type " + dataType.getDisplayName() + " has " +
-				getDisplayName() + " within it.");
-		}
-	}
-
 	/**
 	 * This method throws an exception if the indicated data type is not a valid
 	 * data type for a component of this composite data type.  If the DEFAULT 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
index 8957bb7f99e..136ac17d7ed 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
@@ -243,10 +243,10 @@ public void setNameAndCategory(CategoryPath path, String name)
 	 * (i.e., {@code sizeof(long double)} ).
 	 * <p>
 	 * NOTE: Other than the {@link VoidDataType}, no datatype should ever return 0, even if 
-	 * {@link #isZeroLength()}, and only {@link Dynamic}/{@link FactoryDataType} datatypes 
-	 * should return -1.  If {@link #isZeroLength()} is true a length of 1 should be returned. 
+	 * {@link #isZeroLength()}, and {@link Dynamic}/{@link FactoryDataType} datatypes 
+	 * must return -1.  If {@link #isZeroLength()} is true a length of 1 should be returned. 
 	 * Where a zero-length datatype can be handled (e.g., {@link Composite}) the 
-	 * {@link #isZeroLength()} method should be used.
+	 * {@link #isZeroLength()} method should be checked for this condition.
 	 *
 	 * @return the length of this DataType
 	 */
@@ -505,7 +505,9 @@ public byte[] encodeRepresentation(String repr, MemBuffer buf, Settings settings
 	public void dataTypeDeleted(DataType dt);
 
 	/**
-	 * Informs this datatype that the given oldDT has been replaced with newDT
+	 * Informs this datatype that the given oldDT has been replaced with newDT.
+	 * Both datatype must be a fixed-length datatype and must avoid any circular 
+	 * dependency on this datatype.
 	 * <p>
 	 * TODO: This method is reserved for internal DB use. <br>
 	 *
@@ -559,7 +561,8 @@ public byte[] encodeRepresentation(String repr, MemBuffer buf, Settings settings
 	public int getAlignment();
 
 	/**
-	 * Check if this datatype depends on the existence of the given datatype.
+	 * Check if this datatype depends on the existence of the given datatype
+	 * (i.e., if the specified datatype is removed this datatype must also be removed).
 	 * <p>
 	 * For example byte[] depends on byte. If byte were deleted, then byte[] would also be deleted.
 	 *
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
index da1629d4546..ef51e220ca3 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeManager.java
@@ -197,7 +197,8 @@ public void findDataTypes(String name, List<DataType> list, boolean caseSensitiv
 
 	/**
 	 * Replace an existing dataType with another.  All instances and references will be updated to
-	 * use the replacement dataType.
+	 * use the replacement dataType.  Both datatypes must be fixed-length datatypes.  Replacement
+	 * of types such as FactoryDataType, Dynamic, BitFieldDataType, etc. are not allowed.
 	 * @param existingDt the dataType to be replaced.
 	 * @param replacementDt the dataType to use as the replacement.
 	 * @param updateCategoryPath if true, the replacementDt will have its categoryPath changed
@@ -205,9 +206,11 @@ public void findDataTypes(String name, List<DataType> list, boolean caseSensitiv
 	 * @return the resolved replacement dataType.
 	 * @throws DataTypeDependencyException if the replacement datatype depends on
 	 * the existing dataType;
+	 * @throws IllegalArgumentException if an invalid replacement datatype is specified.
 	 */
 	public DataType replaceDataType(DataType existingDt, DataType replacementDt,
-			boolean updateCategoryPath) throws DataTypeDependencyException;
+			boolean updateCategoryPath)
+			throws DataTypeDependencyException, IllegalArgumentException;
 
 	/**
 	 * Retrieve the data type with the fully qualified path. So you can get the data named
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FunctionDefinitionDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FunctionDefinitionDataType.java
index 37c7bfadb76..8ef9ffd7e8d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FunctionDefinitionDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FunctionDefinitionDataType.java
@@ -374,7 +374,7 @@ public boolean isEquivalentSignature(FunctionSignature signature) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		if (newDt == this) {
 			// avoid creating circular dependency
 			newDt = DataType.DEFAULT;
@@ -442,11 +442,6 @@ public void dataTypeNameChanged(DataType dt, String oldName) {
 		// ignore - no affect
 	}
 
-	@Override
-	public boolean dependsOn(DataType dt) {
-		return false;
-	}
-
 	@Override
 	public String toString() {
 		return getPrototypeString(true);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
index 7e92a700940..be8be30fc6d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
@@ -26,6 +26,7 @@
 import ghidra.program.model.symbol.*;
 import ghidra.util.DataConverter;
 import ghidra.util.StringUtilities;
+import ghidra.util.exception.DuplicateNameException;
 
 /**
  * Basic implementation for a pointer dataType
@@ -755,11 +756,21 @@ public boolean isDeleted() {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		if (referencedDataType == oldDt) {
+			if (newDt == this) {
+				newDt = DataType.DEFAULT;
+			}
 			referencedDataType.removeParent(this);
 			referencedDataType = newDt;
 			referencedDataType.addParent(this);
 			displayName = null;
+
+			if (!newDt.getCategoryPath().equals(oldDt.getCategoryPath())) {
+				// move this pointer to same category as newDt
+				super.setCategoryPath(newDt.getCategoryPath());
+			}
+
 			String oldName = name;
 			name = constructUniqueName(referencedDataType, length);
 			notifyNameChanged(oldName);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StructureDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StructureDataType.java
index 171fc77449d..4e0f883b5bb 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StructureDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StructureDataType.java
@@ -18,6 +18,7 @@
 import java.util.*;
 
 import ghidra.docking.settings.Settings;
+import ghidra.program.database.data.DataTypeUtilities;
 import ghidra.program.model.data.AlignedStructurePacker.StructurePackResult;
 import ghidra.program.model.mem.MemBuffer;
 import ghidra.util.UniversalID;
@@ -513,63 +514,73 @@ public DataTypeComponentImpl insertAtOffset(int offset, DataType dataType, int l
 			}
 		}
 
-		dataType = validateDataType(dataType);
+		try {
+			dataType = validateDataType(dataType);
 
-		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+			dataType = dataType.clone(dataMgr);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
-		if ((offset > structLength) && !isPackingEnabled()) {
-			numComponents += offset - structLength;
-			structLength = offset;
-		}
+			if ((offset > structLength) && !isPackingEnabled()) {
+				numComponents += offset - structLength;
+				structLength = offset;
+			}
 
-		// Any component insert at an offset should be placed after any zero-length components 
-		// at the same offset but before any non-zero-length component.
+			// Any component insert at an offset should be placed after any zero-length components 
+			// at the same offset but before any non-zero-length component.
 
-		int index = Collections.binarySearch(components, Integer.valueOf(offset),
-			OffsetComparator.INSTANCE);
+			int index = Collections.binarySearch(components, Integer.valueOf(offset),
+				OffsetComparator.INSTANCE);
 
-		int additionalShift = 0;
-		if (index >= 0) {
-			index = backupToFirstComponentContainingOffset(index, offset);
-			index = afterNonZeroComponentsAtOffset(index, offset);
-			if (index < components.size()) {
-				DataTypeComponentImpl dtc = components.get(index);
-				additionalShift = offset - dtc.getOffset();
+			int additionalShift = 0;
+			if (index >= 0) {
+				index = backupToFirstComponentContainingOffset(index, offset);
+				index = afterNonZeroComponentsAtOffset(index, offset);
+				if (index < components.size()) {
+					DataTypeComponentImpl dtc = components.get(index);
+					additionalShift = offset - dtc.getOffset();
+				}
+			}
+			else {
+				index = -index - 1;
 			}
-		}
-		else {
-			index = -index - 1;
-		}
 
-		int ordinal = offset;
-		if (index > 0) {
-			DataTypeComponent dtc = components.get(index - 1);
-			ordinal = dtc.getOrdinal() + offset - dtc.getEndOffset();
-		}
+			int ordinal = offset;
+			if (index > 0) {
+				DataTypeComponent dtc = components.get(index - 1);
+				ordinal = dtc.getOrdinal() + offset - dtc.getEndOffset();
+			}
 
-		if (dataType == DataType.DEFAULT) {
-			// assume non-packed insert of DEFAULT
-			shiftOffsets(index, 1 + additionalShift, 1 + additionalShift);
-			return new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
-		}
+			if (dataType == DataType.DEFAULT) {
+				// assume non-packed insert of DEFAULT
+				shiftOffsets(index, 1 + additionalShift, 1 + additionalShift);
+				return new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
+			}
 
-		length = getPreferredComponentLength(dataType, length);
+			length = getPreferredComponentLength(dataType, length);
 
-		DataTypeComponentImpl dtc = new DataTypeComponentImpl(dataType, this, length, ordinal,
-			offset, componentName, comment);
-		dataType.addParent(this);
-		shiftOffsets(index, 1 + additionalShift, length + additionalShift);
-		components.add(index, dtc);
-		repack(false);
-		notifySizeChanged();
-		return dtc;
+			DataTypeComponentImpl dtc = new DataTypeComponentImpl(dataType, this, length, ordinal,
+				offset, componentName, comment);
+			dataType.addParent(this);
+			shiftOffsets(index, 1 + additionalShift, length + additionalShift);
+			components.add(index, dtc);
+			repack(false);
+			notifySizeChanged();
+			return dtc;
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
+		}
 	}
 
 	@Override
 	public DataTypeComponent add(DataType dataType, int length, String componentName,
 			String comment) {
-		return doAdd(dataType, length, componentName, comment, true);
+		try {
+			return doAdd(dataType, length, componentName, comment, true);
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
+		}
 	}
 
 	/**
@@ -589,15 +600,18 @@ public DataTypeComponent add(DataType dataType, int length, String componentName
 	 * @return newly added component
 	 * @throws IllegalArgumentException if the specified data type is not allowed to be added to
 	 *             this composite data type or an invalid length is specified.
+	 * @throws DataTypeDependencyException if the specified datatype contains or represents 
+	 * 			   this structure
 	 */
 	private DataTypeComponentImpl doAdd(DataType dataType, int length, String componentName,
-			String comment, boolean packAndNotify) throws IllegalArgumentException {
+			String comment, boolean packAndNotify)
+			throws DataTypeDependencyException, IllegalArgumentException {
 
 		dataType = validateDataType(dataType);
 
 		dataType = dataType.clone(dataMgr);
 
-		checkAncestry(dataType);
+		DataTypeUtilities.checkAncestry(this, dataType);
 
 		DataTypeComponentImpl dtc;
 		if (dataType == DataType.DEFAULT) {
@@ -683,51 +697,57 @@ public DataTypeComponent insert(int ordinal, DataType dataType, int length,
 		if (ordinal == numComponents) {
 			return add(dataType, length, componentName, comment);
 		}
-		dataType = validateDataType(dataType);
 
-		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+		try {
+			dataType = validateDataType(dataType);
 
-		int idx;
-		if (isPackingEnabled()) {
-			idx = ordinal;
-		}
-		else {
-			// TODO: could improve insertion of bitfield which does not intersect
-			// existing ordinal bitfield at the bit-level
-			idx = Collections.binarySearch(components, Integer.valueOf(ordinal),
-				OrdinalComparator.INSTANCE);
-			if (idx > 0) {
-				DataTypeComponentImpl existingDtc = components.get(idx);
-				if (existingDtc.isBitFieldComponent()) {
-					// must shift down to eliminate possible overlap with previous component 
-					DataTypeComponentImpl previousDtc = components.get(idx - 1);
-					if (previousDtc.getEndOffset() == existingDtc.getOffset()) {
-						shiftOffsets(idx, 0, 1);
+			dataType = dataType.clone(dataMgr);
+			DataTypeUtilities.checkAncestry(this, dataType);
+
+			int idx;
+			if (isPackingEnabled()) {
+				idx = ordinal;
+			}
+			else {
+				// TODO: could improve insertion of bitfield which does not intersect
+				// existing ordinal bitfield at the bit-level
+				idx = Collections.binarySearch(components, Integer.valueOf(ordinal),
+					OrdinalComparator.INSTANCE);
+				if (idx > 0) {
+					DataTypeComponentImpl existingDtc = components.get(idx);
+					if (existingDtc.isBitFieldComponent()) {
+						// must shift down to eliminate possible overlap with previous component 
+						DataTypeComponentImpl previousDtc = components.get(idx - 1);
+						if (previousDtc.getEndOffset() == existingDtc.getOffset()) {
+							shiftOffsets(idx, 0, 1);
+						}
 					}
 				}
 			}
-		}
-		if (idx < 0) {
-			idx = -idx - 1;
-		}
-		if (dataType == DataType.DEFAULT) {
-			// assume non-packed insert of DEFAULT
-			shiftOffsets(idx, 1, 1);
-			return getComponent(ordinal);
-		}
+			if (idx < 0) {
+				idx = -idx - 1;
+			}
+			if (dataType == DataType.DEFAULT) {
+				// assume non-packed insert of DEFAULT
+				shiftOffsets(idx, 1, 1);
+				return getComponent(ordinal);
+			}
 
-		length = getPreferredComponentLength(dataType, length);
+			length = getPreferredComponentLength(dataType, length);
 
-		int offset = (getComponent(ordinal)).getOffset();
-		DataTypeComponentImpl dtc = new DataTypeComponentImpl(dataType, this, length, ordinal,
-			offset, componentName, comment);
-		dataType.addParent(this);
-		shiftOffsets(idx, 1, dtc.getLength());
-		components.add(idx, dtc);
-		repack(false);
-		notifySizeChanged();
-		return dtc;
+			int offset = (getComponent(ordinal)).getOffset();
+			DataTypeComponentImpl dtc = new DataTypeComponentImpl(dataType, this, length, ordinal,
+				offset, componentName, comment);
+			dataType.addParent(this);
+			shiftOffsets(idx, 1, dtc.getLength());
+			components.add(idx, dtc);
+			repack(false);
+			notifySizeChanged();
+			return dtc;
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
+		}
 	}
 
 	@Override
@@ -1241,32 +1261,36 @@ public void clearComponent(int ordinal) {
 	 */
 	@Override
 	public void replaceWith(DataType dataType) {
-		if (!(dataType instanceof StructureInternal)) {
+
+		if (!(dataType instanceof StructureInternal struct)) {
 			throw new IllegalArgumentException();
 		}
 
-		StructureInternal struct = (StructureInternal) dataType;
+		try {
+			components.clear();
+			numComponents = 0;
+			structLength = 0;
+			structAlignment = -1;
 
-		components.clear();
-		numComponents = 0;
-		structLength = 0;
-		structAlignment = -1;
+			this.packing = struct.getStoredPackingValue();
+			this.minimumAlignment = struct.getStoredMinimumAlignment();
 
-		this.packing = struct.getStoredPackingValue();
-		this.minimumAlignment = struct.getStoredMinimumAlignment();
+			if (struct.isPackingEnabled()) {
+				doReplaceWithPacked(struct);
+			}
+			else {
+				doReplaceWithNonPacked(struct);
+			}
 
-		if (struct.isPackingEnabled()) {
-			doReplaceWithPacked(struct);
+			repack(false);
+			notifySizeChanged(); // simplified assumption to force parents to update
 		}
-		else {
-			doReplaceWithNonPacked(struct);
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
 		}
-
-		repack(false);
-		notifySizeChanged(); // simplified assumption to force parents to update
 	}
 
-	private void doReplaceWithPacked(Structure struct) {
+	private void doReplaceWithPacked(Structure struct) throws DataTypeDependencyException {
 		// assumes components is clear and that alignment characteristics have been set
 		DataTypeComponent[] otherComponents = struct.getDefinedComponents();
 		for (DataTypeComponent dtc : otherComponents) {
@@ -1276,7 +1300,7 @@ private void doReplaceWithPacked(Structure struct) {
 		}
 	}
 
-	private void doReplaceWithNonPacked(Structure struct) throws IllegalArgumentException {
+	private void doReplaceWithNonPacked(Structure struct) throws DataTypeDependencyException {
 		// assumes components is clear and that alignment characteristics have been set.
 		if (struct.isNotYetDefined()) {
 			return;
@@ -1289,7 +1313,7 @@ private void doReplaceWithNonPacked(Structure struct) throws IllegalArgumentExce
 		for (int i = 0; i < otherComponents.length; i++) {
 			DataTypeComponent dtc = otherComponents[i];
 			DataType dt = dtc.getDataType().clone(dataMgr);
-			checkAncestry(dt);
+			DataTypeUtilities.checkAncestry(this, dt);
 
 			int length;
 			if (dtc.isBitFieldComponent() || (dt instanceof Dynamic)) {
@@ -1343,11 +1367,12 @@ else if (dtc.getDataType() == dt) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) throws IllegalArgumentException {
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		DataType replacementDt = newDt;
 		try {
 			replacementDt = validateDataType(replacementDt); // blocks DEFAULT use for packed
 			replacementDt = replacementDt.clone(dataMgr);
-			checkAncestry(replacementDt);
+			DataTypeUtilities.checkAncestry(this, replacementDt);
 		}
 		catch (Exception e) {
 			// Handle bad replacement with use of undefined component
@@ -1461,89 +1486,94 @@ public DataTypeComponent replace(int ordinal, DataType dataType, int length,
 			throw new IndexOutOfBoundsException(ordinal);
 		}
 
-		dataType = validateDataType(dataType);
+		try {
+			dataType = validateDataType(dataType);
 
-		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+			dataType = dataType.clone(dataMgr);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
-		length = getPreferredComponentLength(dataType, length);
+			length = getPreferredComponentLength(dataType, length);
 
-		LinkedList<DataTypeComponentImpl> replacedComponents = new LinkedList<>();
-		int offset;
+			LinkedList<DataTypeComponentImpl> replacedComponents = new LinkedList<>();
+			int offset;
 
-		int index = ordinal;
-		if (!isPackingEnabled()) {
-			index = Collections.binarySearch(components, Integer.valueOf(ordinal),
-				OrdinalComparator.INSTANCE);
-		}
-		if (index >= 0) {
-			// defined component
-			DataTypeComponentImpl origDtc = components.get(index);
-			offset = origDtc.getOffset();
-
-			if (isPackingEnabled() || length == 0) {
-				// case 1: packed structure or zero-length replacement - do 1-for-1 replacement
-				replacedComponents.add(origDtc);
+			int index = ordinal;
+			if (!isPackingEnabled()) {
+				index = Collections.binarySearch(components, Integer.valueOf(ordinal),
+					OrdinalComparator.INSTANCE);
 			}
-			else if (origDtc.getLength() == 0) {
-				// case 2: replaced component is zero-length (like-for-like replacement handled by case 1 above
-				throw new IllegalArgumentException(
-					"Zero-length component may only be replaced with another zero-length component");
-			}
-			else if (origDtc.isBitFieldComponent()) {
-				// case 3: replacing bit-field (must replace all bit-fields which overlap)
-				int minOffset = origDtc.getOffset();
-				int maxOffset = origDtc.getEndOffset();
+			if (index >= 0) {
+				// defined component
+				DataTypeComponentImpl origDtc = components.get(index);
+				offset = origDtc.getOffset();
 
-				replacedComponents.add(origDtc);
+				if (isPackingEnabled() || length == 0) {
+					// case 1: packed structure or zero-length replacement - do 1-for-1 replacement
+					replacedComponents.add(origDtc);
+				}
+				else if (origDtc.getLength() == 0) {
+					// case 2: replaced component is zero-length (like-for-like replacement handled by case 1 above
+					throw new IllegalArgumentException(
+						"Zero-length component may only be replaced with another zero-length component");
+				}
+				else if (origDtc.isBitFieldComponent()) {
+					// case 3: replacing bit-field (must replace all bit-fields which overlap)
+					int minOffset = origDtc.getOffset();
+					int maxOffset = origDtc.getEndOffset();
+
+					replacedComponents.add(origDtc);
 
-				// consume bit-field overlaps before
-				for (int i = index - 1; i >= 0; i--) {
-					origDtc = components.get(i);
-					if (origDtc.getLength() == 0 || !origDtc.containsOffset(minOffset)) {
-						break;
+					// consume bit-field overlaps before
+					for (int i = index - 1; i >= 0; i--) {
+						origDtc = components.get(i);
+						if (origDtc.getLength() == 0 || !origDtc.containsOffset(minOffset)) {
+							break;
+						}
+						replacedComponents.add(0, origDtc);
 					}
-					replacedComponents.add(0, origDtc);
-				}
 
-				// consume bit-field overlaps after
-				for (int i = index + 1; i < components.size(); i++) {
-					origDtc = components.get(i);
-					if (origDtc.getLength() == 0 || !origDtc.containsOffset(maxOffset)) {
-						break;
+					// consume bit-field overlaps after
+					for (int i = index + 1; i < components.size(); i++) {
+						origDtc = components.get(i);
+						if (origDtc.getLength() == 0 || !origDtc.containsOffset(maxOffset)) {
+							break;
+						}
+						replacedComponents.add(origDtc);
 					}
+				}
+				else {
+					// case 4: sized component replacemnt - do 1-for-1 replacement 
 					replacedComponents.add(origDtc);
 				}
 			}
 			else {
-				// case 4: sized component replacemnt - do 1-for-1 replacement 
-				replacedComponents.add(origDtc);
-			}
-		}
-		else {
-			// case 5: undefined component replaced (non-packed only)
-			index = -index - 1;
-			offset = ordinal;
-			if (index > 0) {
-				// use previous defined component to compute undefined offset
-				DataTypeComponent dtc = components.get(index - 1);
-				offset = dtc.getEndOffset() + ordinal - dtc.getOrdinal();
-				if (dtc.getLength() == 0) {
-					--offset;
+				// case 5: undefined component replaced (non-packed only)
+				index = -index - 1;
+				offset = ordinal;
+				if (index > 0) {
+					// use previous defined component to compute undefined offset
+					DataTypeComponent dtc = components.get(index - 1);
+					offset = dtc.getEndOffset() + ordinal - dtc.getOrdinal();
+					if (dtc.getLength() == 0) {
+						--offset;
+					}
 				}
+				DataTypeComponentImpl origDtc =
+					new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
+				if (dataType == DataType.DEFAULT) {
+					return origDtc; // no change
+				}
+				replacedComponents.add(origDtc);
 			}
-			DataTypeComponentImpl origDtc =
-				new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
-			if (dataType == DataType.DEFAULT) {
-				return origDtc; // no change
-			}
-			replacedComponents.add(origDtc);
-		}
 
-		DataTypeComponent replaceComponent = doComponentReplacement(replacedComponents, offset,
-			dataType, length, componentName, comment);
+			DataTypeComponent replaceComponent = doComponentReplacement(replacedComponents, offset,
+				dataType, length, componentName, comment);
 
-		return replaceComponent != null ? replaceComponent : getComponent(ordinal);
+			return replaceComponent != null ? replaceComponent : getComponent(ordinal);
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
+		}
 	}
 
 	@Override
@@ -1557,78 +1587,83 @@ public DataTypeComponent replaceAtOffset(int offset, DataType dataType, int leng
 				"Offset " + offset + " is beyond end of structure (" + structLength + ").");
 		}
 
-		dataType = validateDataType(dataType);
-		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+		try {
+			dataType = validateDataType(dataType);
+			dataType = dataType.clone(dataMgr);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
-		LinkedList<DataTypeComponentImpl> replacedComponents = new LinkedList<>();
+			LinkedList<DataTypeComponentImpl> replacedComponents = new LinkedList<>();
 
-		DataTypeComponentImpl origDtc = null;
-		int index = Collections.binarySearch(components, Integer.valueOf(offset),
-			OffsetComparator.INSTANCE);
-		if (index >= 0) {
+			DataTypeComponentImpl origDtc = null;
+			int index = Collections.binarySearch(components, Integer.valueOf(offset),
+				OffsetComparator.INSTANCE);
+			if (index >= 0) {
 
-			// defined component found - advance to last one containing offset
-			index = advanceToLastComponentContainingOffset(index, offset);
-			origDtc = components.get(index);
+				// defined component found - advance to last one containing offset
+				index = advanceToLastComponentContainingOffset(index, offset);
+				origDtc = components.get(index);
 
-			// case 1: only defined component(s) at offset are zero-length
-			if (origDtc.getLength() == 0) {
-				if (isPackingEnabled()) {
-					// if packed: insert after zero-length component 
-					return insert(index + 1, dataType, length, componentName, comment);
+				// case 1: only defined component(s) at offset are zero-length
+				if (origDtc.getLength() == 0) {
+					if (isPackingEnabled()) {
+						// if packed: insert after zero-length component 
+						return insert(index + 1, dataType, length, componentName, comment);
+					}
+					// if non-packed: replace undefined component which immediately follows the zero-length component
+					replacedComponents.add(new DataTypeComponentImpl(DataType.DEFAULT, this, 1,
+						origDtc.getOrdinal() + 1, offset));
 				}
-				// if non-packed: replace undefined component which immediately follows the zero-length component
-				replacedComponents.add(new DataTypeComponentImpl(DataType.DEFAULT, this, 1,
-					origDtc.getOrdinal() + 1, offset));
-			}
 
-			// case 2: sized component at offset is bit-field (must replace all bit-fields which contain offset)
-			else if (origDtc.isBitFieldComponent()) {
-				replacedComponents.add(origDtc);
-				for (int i = index - 1; i >= 0; i--) {
-					origDtc = components.get(i);
-					if (origDtc.getLength() == 0 || !origDtc.containsOffset(offset)) {
-						break;
+				// case 2: sized component at offset is bit-field (must replace all bit-fields which contain offset)
+				else if (origDtc.isBitFieldComponent()) {
+					replacedComponents.add(origDtc);
+					for (int i = index - 1; i >= 0; i--) {
+						origDtc = components.get(i);
+						if (origDtc.getLength() == 0 || !origDtc.containsOffset(offset)) {
+							break;
+						}
+						replacedComponents.add(0, origDtc);
 					}
-					replacedComponents.add(0, origDtc);
 				}
-			}
 
-			// case 3: normal replacement of sized component
-			else {
-				replacedComponents.add(origDtc);
+				// case 3: normal replacement of sized component
+				else {
+					replacedComponents.add(origDtc);
+				}
 			}
-		}
-		else {
-			// defined component not found
-			index = -index - 1;
+			else {
+				// defined component not found
+				index = -index - 1;
 
-			if (isPackingEnabled()) {
-				// case 4: if replacing padding for packed struction perform insert at correct ordinal
-				return insert(index, dataType, length, componentName, comment);
-			}
+				if (isPackingEnabled()) {
+					// case 4: if replacing padding for packed struction perform insert at correct ordinal
+					return insert(index, dataType, length, componentName, comment);
+				}
 
-			// case 5: replace undefined component at offset - compute undefined component to be replaced
-			int ordinal = offset;
-			if (index > 0) {
-				// use previous defined component to determine ordinal for undefined component
-				DataTypeComponent dtc = components.get(index - 1);
-				ordinal = dtc.getOrdinal() + offset - dtc.getEndOffset();
-			}
-			origDtc = new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
-			if (dataType == DataType.DEFAULT) {
-				return origDtc; // no change
+				// case 5: replace undefined component at offset - compute undefined component to be replaced
+				int ordinal = offset;
+				if (index > 0) {
+					// use previous defined component to determine ordinal for undefined component
+					DataTypeComponent dtc = components.get(index - 1);
+					ordinal = dtc.getOrdinal() + offset - dtc.getEndOffset();
+				}
+				origDtc = new DataTypeComponentImpl(DataType.DEFAULT, this, 1, ordinal, offset);
+				if (dataType == DataType.DEFAULT) {
+					return origDtc; // no change
+				}
+				replacedComponents.add(origDtc);
 			}
-			replacedComponents.add(origDtc);
-		}
 
-		length = getPreferredComponentLength(dataType, length);
+			length = getPreferredComponentLength(dataType, length);
 
-		DataTypeComponent replaceComponent = doComponentReplacement(replacedComponents, offset,
-			dataType, length, componentName, comment);
+			DataTypeComponent replaceComponent = doComponentReplacement(replacedComponents, offset,
+				dataType, length, componentName, comment);
 
-		return replaceComponent != null ? replaceComponent : getComponentContaining(offset);
+			return replaceComponent != null ? replaceComponent : getComponentContaining(offset);
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
+		}
 	}
 
 	/**
@@ -1797,11 +1832,6 @@ protected int getNumUndefinedBytes(int index) {
 
 	}
 
-	@Override
-	public boolean dependsOn(DataType dt) {
-		return false;
-	}
-
 	@Override
 	public void deleteAll() {
 		for (DataTypeComponentImpl dtc : components) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypeDef.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypeDef.java
index c0492db5bf0..4c97419e22e 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypeDef.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypeDef.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ public interface TypeDef extends DataType {
 	 * @return true if auto-named, else false.
 	 */
 	public boolean isAutoNamed();
-	
+
 	/**
 	 * Enable auto-naming for this typedef.  This will force naming to reflect the name of
 	 * associated datatype plus an attribute list which corresponds to any 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypedefDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypedefDataType.java
index 6ca53868c82..dcb5c977332 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypedefDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/TypedefDataType.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -92,17 +92,24 @@ public TypedefDataType(CategoryPath path, String name, DataType dt, UniversalID
 	}
 
 	private void validate(DataType dt) {
+		if (dataType instanceof VoidDataType) {
+			throw new IllegalArgumentException("TypeDef data type may not be 'void' data type");
+		}
+		if (dataType instanceof DefaultDataType) {
+			throw new IllegalArgumentException(
+				"TypeDef data type may not be 'default' undefined data type");
+		}
 		if (dt instanceof BitFieldDataType) {
 			throw new IllegalArgumentException(
-				"TypeDef data-type may not be a bitfield: " + dt.getName());
+				"TypeDef data type may not be a bitfield: " + dt.getName());
 		}
 		if (dt instanceof FactoryDataType) {
 			throw new IllegalArgumentException(
-				"TypeDef data-type may not be a Factory data-type: " + dt.getName());
+				"TypeDef data type may not be a Factory data type: " + dt.getName());
 		}
 		if (dt instanceof Dynamic) {
 			throw new IllegalArgumentException(
-				"TypeDef data-type may not be a Dynamic data-type: " + dt.getName());
+				"TypeDef data type may not be a Dynamic data type: " + dt.getName());
 		}
 	}
 
@@ -389,8 +396,8 @@ private boolean isAllowedSetting(String settingName) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
-		validate(newDt);
 		if (oldDt == dataType) {
+			DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 			settingsDef = null;
 			if (dataMgr != null) {
 				defaultSettings = null;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/UnionDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/UnionDataType.java
index d21431fc9b2..94ae9858713 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/UnionDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/UnionDataType.java
@@ -18,6 +18,7 @@
 import java.util.*;
 
 import ghidra.docking.settings.Settings;
+import ghidra.program.database.data.DataTypeUtilities;
 import ghidra.program.model.mem.MemBuffer;
 import ghidra.util.UniversalID;
 
@@ -129,13 +130,18 @@ public int getNumDefinedComponents() {
 	public DataTypeComponent add(DataType dataType, int length, String componentName,
 			String comment) throws IllegalArgumentException {
 
-		int oldAlignment = getAlignment();
+		try {
+			int oldAlignment = getAlignment();
 
-		DataTypeComponent dtc = doAdd(dataType, length, componentName, comment);
-		if (!repack(true) && isPackingEnabled() && oldAlignment != getAlignment()) {
-			notifyAlignmentChanged();
+			DataTypeComponent dtc = doAdd(dataType, length, componentName, comment);
+			if (!repack(true) && isPackingEnabled() && oldAlignment != getAlignment()) {
+				notifyAlignmentChanged();
+			}
+			return dtc;
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
 		}
-		return dtc;
 	}
 
 	private int getBitFieldAllocation(BitFieldDataType bitfieldDt) {
@@ -158,14 +164,14 @@ private int getBitFieldAllocation(BitFieldDataType bitfieldDt) {
 	}
 
 	DataTypeComponentImpl doAdd(DataType dataType, int length, String componentName, String comment)
-			throws IllegalArgumentException {
+			throws DataTypeDependencyException {
 
 		dataType = validateDataType(dataType);
 
 		dataType = adjustBitField(dataType);
 
 		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+		DataTypeUtilities.checkAncestry(this, dataType);
 
 		length = getPreferredComponentLength(dataType, length);
 
@@ -180,27 +186,32 @@ DataTypeComponentImpl doAdd(DataType dataType, int length, String componentName,
 	@Override
 	public DataTypeComponent insert(int ordinal, DataType dataType, int length,
 			String componentName, String comment) throws IllegalArgumentException {
-		dataType = validateDataType(dataType);
+		try {
+			dataType = validateDataType(dataType);
 
-		int oldAlignment = getAlignment();
+			int oldAlignment = getAlignment();
 
-		dataType = adjustBitField(dataType);
+			dataType = adjustBitField(dataType);
 
-		dataType = dataType.clone(dataMgr);
-		checkAncestry(dataType);
+			dataType = dataType.clone(dataMgr);
+			DataTypeUtilities.checkAncestry(this, dataType);
 
-		length = getPreferredComponentLength(dataType, length);
+			length = getPreferredComponentLength(dataType, length);
 
-		DataTypeComponentImpl dtc =
-			new DataTypeComponentImpl(dataType, this, length, ordinal, 0, componentName, comment);
-		dataType.addParent(this);
-		shiftOrdinals(ordinal, 1);
-		components.add(ordinal, dtc);
+			DataTypeComponentImpl dtc = new DataTypeComponentImpl(dataType, this, length, ordinal,
+				0, componentName, comment);
+			dataType.addParent(this);
+			shiftOrdinals(ordinal, 1);
+			components.add(ordinal, dtc);
 
-		if (!repack(true) && isPackingEnabled() && oldAlignment != getAlignment()) {
-			notifyAlignmentChanged();
+			if (!repack(true) && isPackingEnabled() && oldAlignment != getAlignment()) {
+				notifyAlignmentChanged();
+			}
+			return dtc;
+		}
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
 		}
-		return dtc;
 	}
 
 	@Override
@@ -502,11 +513,12 @@ public void dataTypeSizeChanged(DataType dt) {
 
 	@Override
 	public void dataTypeReplaced(DataType oldDt, DataType newDt) throws IllegalArgumentException {
+		DataTypeUtilities.checkValidReplacement(oldDt, newDt);
 		DataType replacementDt = newDt;
 		try {
 			replacementDt = validateDataType(replacementDt); // blocks DEFAULT use
 			replacementDt = replacementDt.clone(dataMgr);
-			checkAncestry(replacementDt);
+			DataTypeUtilities.checkAncestry(this, replacementDt);
 		}
 		catch (Exception e) {
 			replacementDt = Undefined1DataType.dataType;
@@ -562,38 +574,31 @@ else if (dtc.getDataType() == dt) {
 
 	@Override
 	public void replaceWith(DataType dataType) throws IllegalArgumentException {
-		if (!(dataType instanceof UnionInternal)) {
+		if (!(dataType instanceof UnionInternal union)) {
 			throw new IllegalArgumentException();
 		}
+		try {
+			for (DataTypeComponent dtc : components) {
+				dtc.getDataType().removeParent(this);
+			}
+			components.clear();
+			unionAlignment = -1;
 
-		UnionInternal union = (UnionInternal) dataType;
-
-		for (DataTypeComponent dtc : components) {
-			dtc.getDataType().removeParent(this);
-		}
-		components.clear();
-		unionAlignment = -1;
+			this.packing = union.getStoredPackingValue();
+			this.minimumAlignment = union.getStoredMinimumAlignment();
 
-		this.packing = union.getStoredPackingValue();
-		this.minimumAlignment = union.getStoredMinimumAlignment();
+			DataTypeComponent[] compArray = union.getComponents();
+			for (DataTypeComponent dtc : compArray) {
+				DataType dt = dtc.getDataType();
+				doAdd(dt, dtc.getLength(), dtc.getFieldName(), dtc.getComment());
+			}
 
-		DataTypeComponent[] compArray = union.getComponents();
-		for (DataTypeComponent dtc : compArray) {
-			DataType dt = dtc.getDataType();
-			doAdd(dt, dtc.getLength(), dtc.getFieldName(), dtc.getComment());
+			repack(false);
+			notifySizeChanged(); // simplified assumption to force parents to update
 		}
-
-		repack(false);
-		notifySizeChanged(); // simplified assumption to force parents to update
-	}
-
-	@Override
-	public boolean dependsOn(DataType dt) {
-		if (getNumComponents() == 1) {
-			DataTypeComponent dtc = getComponent(0);
-			return dtc.getDataType().dependsOn(dt);
+		catch (DataTypeDependencyException e) {
+			throw new IllegalArgumentException(e.getMessage(), e);
 		}
-		return false;
 	}
 
 	@Override
```
-----------------------------------
