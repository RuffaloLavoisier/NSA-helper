# Commit: 9f558ce395e4b65a7829dfb5eff5af99b7855504
## Message: Merge remote-tracking branch
'origin/GP-6451_dragonmacher_PR-8928_hay-mon_ano_mod' (Closes #8928)
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
index 94e176b6eed..bbe24f89295 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -115,7 +115,7 @@ boolean handleMouseClick(String[] annotationParts, Navigatable sourceNavigatable
 	 * @return the example of how this is used.
 	 */
 	String getPrototypeString();
-	
+
 	/**
 	 * Returns an example string of how the annotation is used
 	 * @param displayText The text that may be wrapped, cannot be null
@@ -125,4 +125,17 @@ default String getPrototypeString(String displayText) {
 		return getPrototypeString();
 	}
 
+	/**
+	 * Returns an array with modifications by the annotation; null otherwise.  This method will be 
+	 * called by the framework when comments are created, before they are applied.  This allows the
+	 * handler to perform fixups on the input text before it is saved to the database.
+	 * 
+	 * @param text the array of annotation parts to modify
+	 * @param program the program
+	 * @return the modified array; null otherwise
+	 */
+	default String[] modify(String[] text, Program program) {
+		return null;
+	}
+
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
index 9095d251da1..e17653a6e28 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
@@ -15,30 +15,51 @@
  */
 package ghidra.app.util.viewer.field;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
+import java.util.stream.Collectors;
 
 import ghidra.program.model.listing.Program;
 
 public class Annotation {
 
-	public static final String ESCAPABLE_CHARS = "{}\"\\";
+	private static final char BS = '\\';
+	private static final String SEP = "\\s";
+	private static final String ESCAPABLE_CHARS = "{}\"\\";
 
-	private String annotationText;
-	private String[] annotationParts;
+	private final String[] annotationParts;
+	private final String annotationText;
 
 	/**
 	 * Constructor
-	 * <b>Note</b>: This constructor assumes that the string starts with "{<pre>@</pre>" and ends with '}'
+	 * <br>
+	 * <b>Note</b>: This constructor assumes that the string starts with 
+	 * "{<pre>@</pre>" and ends with '}'
 	 * 
-	 * @param annotationText The complete annotation text.
-	 * text this Annotation can create
-	 * @param program the program
+	 * @param annotationText the complete annotation text.
 	 */
-	public Annotation(String annotationText, Program program) {
-
-		this.annotationText = annotationText;
+	public Annotation(String annotationText) {
 		this.annotationParts = parseAnnotationText(annotationText);
+		this.annotationText = annotationText;
+	}
+
+	/**
+	 * Constructor.  Used for creating a new Annotation from a previously parsed annotation String.
+	 *
+	 * @param annotationParts The annotation parts.
+	 */
+	public Annotation(String[] annotationParts) {
+		this.annotationParts = annotationParts;
+		this.annotationText = buildAnnotationText(annotationParts);
+	}
+
+	/**
+	 * Deprecated.  Use {@link #Annotation(String)}.
+	 * @param annotationText the complete annotation text
+	 * @param program ignored
+	 */
+	@Deprecated
+	public Annotation(String annotationText, Program program) {
+		this(annotationText);
 	}
 
 	public String[] getAnnotationParts() {
@@ -54,136 +75,113 @@ public String toString() {
 		return annotationText;
 	}
 
-	private String[] parseAnnotationText(String text) {
-
+	private static String[] parseAnnotationText(String text) {
 		String trimmed = text.substring(2, text.length() - 1); // remove "{@" and '}' 
-		List<String> tokens = new ArrayList<>();
-		List<TextPart> parts = parseText(trimmed);
-		for (TextPart part : parts) {
-			part.grabTokens(tokens);
-		}
-
-		return tokens.toArray(new String[tokens.size()]);
+		return parseText(trimmed);
 	}
 
-	private List<TextPart> parseText(String text) {
+	private static String buildAnnotationText(String[] text) {
+		return Arrays.stream(text)
+				.map(Annotation::maybeQuote)
+				.collect(Collectors.joining(" ", "{@", "}"));
+	}
 
-		List<TextPart> textParts = new ArrayList<>();
-		boolean escaped = false;
-		boolean inQuote = false;
-		int partStart = 0;
-		int n = text.length();
-		for (int i = 0; i < n; i++) {
+	private static String[] parseText(String text) {
+		List<String> parts = new ArrayList<>();
+		boolean escape = false;
+		boolean quote = false;
+		StringBuilder buffy = new StringBuilder();
 
-			boolean wasEscaped = escaped;
-			escaped = false;
-			char prev = '\0';
-			if (i != 0 && !wasEscaped) {
-				prev = text.charAt(i - 1);
+		for (char c : text.toCharArray()) {
+			if (escape) {
+				escape = false;
+				buffy.append(BS);
+				buffy.append(c);
+				continue;
 			}
 
-			char c = text.charAt(i);
-			if (prev == '\\') {
-				if (Annotation.ESCAPABLE_CHARS.indexOf(c) != -1) {
-					escaped = true;
-					continue;
-				}
+			if (c == BS) {
+				escape = true;
+				continue;
 			}
 
 			if (c == '"') {
-				if (inQuote) {
-					// end quote
-					String s = text.substring(partStart, i + 1); // keep the quote
-					textParts.add(new QuotedTextPart(s));
-					partStart = i + 1;
+				String s = buffy.toString();
+				if (quote) {
+					// end quote; keep the text as a single part
+					parts.add(s);
 				}
 				else {
-					// end previous word; start quote
-					if (i != 0) {
-						String s = text.substring(partStart, i);
-						textParts.add(new TextPart(s));
-						partStart = i;
-					}
+					// new quote start; split previous unquoted text into parts
+					parts.addAll(Arrays.asList(s.split(SEP)));
 				}
-				inQuote = !inQuote;
+				buffy.setLength(0);
+				quote = !quote;
+			}
+			else {
+				buffy.append(c);
 			}
 		}
 
-		if (partStart < n) { // grab trailing text
-			String s = text.substring(partStart, n);
-			textParts.add(new TextPart(s));
-		}
+		String s = buffy.toString();
+		parts.addAll(Arrays.asList(s.split(SEP)));
 
-		return textParts;
+		return parts.stream()
+				.filter(t -> t.length() > 0)
+				.map(t -> removeEscapeChars(t))
+				.toArray(String[]::new);
 	}
 
 	// remove any backslashes that escape special annotation characters, like '{' and '}'
 	private static String removeEscapeChars(String text) {
-		boolean escaped = false;
+		boolean escape = false;
 		StringBuilder buffy = new StringBuilder();
-		for (int i = 0; i < text.length(); i++) {
-			char c = text.charAt(i);
-			boolean wasEscaped = escaped;
-			escaped = false;
-			if (c != '\\') {
+		for (char c : text.toCharArray()) {
+			if (escape) {
+				escape = false;
+				if (ESCAPABLE_CHARS.indexOf(c) == -1) {
+					buffy.append(BS); // restore non-escaping backslash
+				}
 				buffy.append(c);
 				continue;
 			}
 
-			char next = '\0';
-			if (i != text.length() - 1 && !wasEscaped) {
-				next = text.charAt(i + 1);
-			}
-
-			if (ESCAPABLE_CHARS.indexOf(next) != -1) {
-				escaped = true;
+			if (c == BS) {
+				escape = true;
 				continue;
 			}
+
 			buffy.append(c);
 		}
 
 		return buffy.toString();
 	}
 
-	/**
-	 * A simple class to hold text and extract tokens 
-	 */
-	private class TextPart {
-
-		protected String text;
-
-		TextPart(String text) {
-			this.text = text;
+	private static String maybeQuote(String text) {
+		if (needsQuotes(text)) {
+			return '"' + escapeAnnotationChars(text) + '"';
 		}
+		return text;
+	}
 
-		public void grabTokens(List<String> tokens) {
-			String escaped = removeEscapeChars(text);
-			String[] strings = escaped.split("\\s");
-			for (String string : strings) {
-				// 0 length strings can happen when 'content' begins with a space
-				if (string.length() > 0) {
-					tokens.add(string);
-				}
+	private static boolean needsQuotes(String text) {
+		for (char c : text.toCharArray()) {
+			if (ESCAPABLE_CHARS.indexOf(c) != -1 || Character.isWhitespace(c)) {
+				return true;
 			}
 		}
-
-		@Override
-		public String toString() {
-			return text;
-		}
+		return false;
 	}
 
-	private class QuotedTextPart extends TextPart {
-		QuotedTextPart(String text) {
-			super(text);
+	private static String escapeAnnotationChars(String text) {
+		StringBuilder buffy = new StringBuilder();
+		for (char c : text.toCharArray()) {
+			if (ESCAPABLE_CHARS.indexOf(c) != -1) {
+				buffy.append(BS);
+			}
+			buffy.append(c);
 		}
 
-		@Override
-		public void grabTokens(List<String> tokens) {
-			String unquoted = text.substring(1, text.length() - 1);
-			String escaped = removeEscapeChars(unquoted);
-			tokens.add(escaped); // all quoted text is a 'token'
-		}
+		return buffy.toString();
 	}
-
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
index e23c86658a0..b56eb23c92e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
@@ -58,28 +58,24 @@ public static String fixupAnnotations(String rawCommentText, Program program) {
 			return null;
 		}
 
-		// this function will take any given Symbol annotations and change the text, replacing
-		// the symbol name with the address of the symbol
-		Function<Annotation, Annotation> symbolFixer = annotation -> {
-
+		// this function will take any annotation and call the annotation to perform updates to the 
+		// input text as needed.   An example is the Symbol annotation, which will replace any 
+		// symbol name with that symbol's address.  This allows future renames of that symbol to 
+		// appear in the comment text containing the annotation. 
+		Function<Annotation, Annotation> fixer = annotation -> {
 			String[] annotationParts = annotation.getAnnotationParts();
 			AnnotatedStringHandler handler = getAnnotationHandler(annotationParts);
-			if (!(handler instanceof SymbolAnnotatedStringHandler)) {
-				return annotation; // nothing to change
-			}
 
-			String rawText = annotation.getAnnotationText();
-			String updatedText =
-				convertAnnotationSymbolToAddress(annotationParts, rawText, program);
-			if (updatedText == null) {
+			String[] updatedParts = handler.modify(annotationParts, program);
+			if (updatedParts == null) {
 				return annotation; // nothing to change
 			}
 
-			return new Annotation(updatedText, program);
+			return new Annotation(updatedParts);
 		};
 
 		StringBuilder buffy = new StringBuilder();
-		List<CommentPart> parts = doParseTextIntoParts(rawCommentText, symbolFixer, program);
+		List<CommentPart> parts = doParseTextIntoParts(rawCommentText, fixer, program);
 		for (CommentPart part : parts) {
 			buffy.append(part.getRawText());
 		}
@@ -224,7 +220,7 @@ private static List<CommentPart> doParseTextIntoParts(String text,
 			}
 
 			String annotationText = word.getWord();
-			Annotation annotation = new Annotation(annotationText, program);
+			Annotation annotation = new Annotation(annotationText);
 			annotation = fixerUpper.apply(annotation);
 			results.add(new AnnotationCommentPart(annotationText, annotation));
 
@@ -290,64 +286,32 @@ private static Pattern createAnnotationStartPattern() {
 	 */
 	private static int findAnnotationEnd(String comment, int start) {
 
-		boolean escaped = false;
-		boolean inQuote = false;
+		boolean escape = false;
+		boolean quote = false;
 		for (int i = start; i < comment.length(); i++) {
-
-			boolean wasEscaped = escaped;
-			escaped = false;
-			char prev = '\0';
-			if (i != 0 && !wasEscaped) {
-				prev = comment.charAt(i - 1);
+			char c = comment.charAt(i);
+			if (escape) {
+				escape = false;
+				continue;
 			}
 
-			char c = comment.charAt(i);
-			if (prev == '\\') {
-				if (Annotation.ESCAPABLE_CHARS.indexOf(c) != -1) {
-					escaped = true;
-					continue;
-				}
+			if (c == '\\') {
+				escape = true;
+				continue;
 			}
 
 			if (c == '"') {
-				inQuote = !inQuote;
+				quote = !quote;
 			}
 			else if (c == '}') {
-				if (!inQuote) {
+				if (!quote) {
 					return i + 1;
 				}
 			}
 		}
-
 		return -1;
 	}
 
-	private static String convertAnnotationSymbolToAddress(String[] annotationParts, String rawText,
-			Program program) {
-		if (annotationParts.length <= 1) {
-			return null;
-		}
-
-		if (program == null) { // this can happen during merge operations
-			return null;
-		}
-
-		Address address = program.getAddressFactory().getAddress(annotationParts[1]);
-		if (address != null) {
-			return null; // nothing to do
-		}
-
-		String originalValue = annotationParts[1];
-		List<Symbol> symbols = getSymbols(originalValue, program);
-		if (symbols.size() != 1) {
-			// no unique symbol, so leave it as string name
-			return null;
-		}
-
-		Address symbolAddress = symbols.get(0).getAddress();
-		return rawText.replaceFirst(Pattern.quote(originalValue), symbolAddress.toString());
-	}
-
 	/**
 	 * Returns all symbols that match the given text or an empty list.
 	 * @param rawText the raw symbol text
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java
index 7b545eb6ec6..2a5c2b6a023 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java
@@ -469,7 +469,7 @@ private void prependRefAddress(Program program, AttributedString prefix, Address
 		RowColLocation startRowCol = commentElement.getDataLocationForCharacterIndex(0);
 		int encodedRow = startRowCol.row();
 		int encodedCol = startRowCol.col();
-		Annotation annotation = new Annotation(refAddrComment, program);
+		Annotation annotation = new Annotation(refAddrComment);
 		FieldElement addressElement =
 			new AnnotatedTextFieldElement(annotation, prefix, program, encodedRow, encodedCol);
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
index 1e9ca4042cd..3252cf86256 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
@@ -18,7 +18,7 @@
 import java.util.List;
 
 import org.apache.commons.io.FilenameUtils;
-import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Strings;
 
 import docking.widgets.fieldpanel.field.AttributedString;
 import ghidra.app.nav.Navigatable;
@@ -64,14 +64,15 @@ public AttributedString createAnnotatedString(AttributedString prototypeString,
 	}
 
 	private String getDisplayText(String[] text) {
-		// assume that the 'extra text' means that is how the user wants to display the annotation
+
 		if (text.length > 2) {
-			StringBuffer buffer = new StringBuffer();
+			// assume that the extra text means that is how the user wants to display the annotation
+			StringBuilder buffy = new StringBuilder();
 			for (int i = 2; i < text.length; i++) {
-				buffer.append(text[i]).append(" ");
+				buffy.append(text[i]).append(" ");
 			}
-			buffer.deleteCharAt(buffer.length() - 1); // remove last space
-			return buffer.toString();
+			buffy.deleteCharAt(buffy.length() - 1); // remove last space
+			return buffy.toString();
 		}
 
 		String symbolText = getUnvalidatedDisplayText(text);
@@ -137,7 +138,7 @@ public boolean handleMouseClick(String[] annotationParts, Navigatable navigatabl
 
 		DomainFolder folder;
 		if (path.length() > 0) {
-			path = StringUtils.prependIfMissing(FilenameUtils.separatorsToUnix(path), "/");
+			path = Strings.CS.prependIfMissing(FilenameUtils.separatorsToUnix(path), "/");
 			folder = projectData.getFolder(path);
 			if (folder == null) {
 				Msg.showInfo(getClass(), null, "Folder Not Found: " + path,
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
index dd6bd48d718..6509f93f00a 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
@@ -125,4 +125,31 @@ public String getPrototypeString(String displayText) {
 		return "{@symbol " + displayText.trim() + "}";
 	}
 
+	@Override
+	public String[] modify(String[] text, Program program) {
+		if (text.length <= 1) {
+			return null;
+		}
+
+		if (program == null) { // this can happen during merge operations
+			return null;
+		}
+
+		Address address = program.getAddressFactory().getAddress(text[1]);
+		if (address != null) {
+			return null; // nothing to do
+		}
+
+		String originalValue = text[1];
+		List<Symbol> symbols = CommentUtils.getSymbols(originalValue, program);
+		if (symbols.size() != 1) {
+			// no unique symbol, so leave it as string name
+			return null;
+		}
+
+		Address symbolAddress = symbols.get(0).getAddress();
+		text[1] = symbolAddress.toString();
+
+		return text;
+	}
 }
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
index 89f84aec35a..66c2cc8deea 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
@@ -16,6 +16,7 @@
 package ghidra.app.util.viewer.field;
 
 import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 
 import java.awt.*;
@@ -809,7 +810,6 @@ public void testInvalidAnnotation_MissingAttributes_DoesNotMatchKnownAnnotation(
 
 	@Test
 	public void testInvalidAnnotation_NoSuchSymbol() {
-
 		// valid annotation, invalid symbol
 		String data = "This is an annotated string {@symbol 01001001}";
 		FieldElement fieldElement =
```
-----------------------------------
