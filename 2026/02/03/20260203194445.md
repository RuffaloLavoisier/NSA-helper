# Commit: 3d48e7c7540aeb60731650231afda8df46f35f0a
## Message: Fixing junit test related to memory search changes
## Diff:
```
diff --git a/Ghidra/Features/Base/src/test/java/ghidra/util/bytesearch/BulkPatternSearcherTest.java b/Ghidra/Features/Base/src/test/java/ghidra/util/bytesearch/BulkPatternSearcherTest.java
index bd890ac31b7..c870c66f097 100644
--- a/Ghidra/Features/Base/src/test/java/ghidra/util/bytesearch/BulkPatternSearcherTest.java
+++ b/Ghidra/Features/Base/src/test/java/ghidra/util/bytesearch/BulkPatternSearcherTest.java
@@ -229,7 +229,7 @@ public void testByteSequenceStartsInMainEndsInPost() {
 		TestPattern p = new TestPattern("joebob");
 		search("xxxxjoexbob", "xxxjoe", "bob", p);
 		assertEquals(1, results.size());
-		assertMatch(results.get(0), p, 8);
+		assertMatch(results.get(0), p, 3);
 	}
 
 	@Test
diff --git a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/cmd/function/CreateFunctionThunkTest.java b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/cmd/function/CreateFunctionThunkTest.java
index da283cee297..5af19235cf7 100644
--- a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/cmd/function/CreateFunctionThunkTest.java
+++ b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/cmd/function/CreateFunctionThunkTest.java
@@ -71,7 +71,6 @@ private void analyze() {
 		tool.execute(cmd, program);
 		waitForBusyTool(tool);
 	}
-	
 
 	protected void setAnalysisOptions(String optionName) {
 		int txId = program.startTransaction("Analyze");
@@ -130,7 +129,7 @@ public void testDelayMips6432SlotThunk() throws Exception {
 		assertEquals(true, isThunk.isThunk());
 		assertEquals("chdir", isThunk.getName());
 	}
-	
+
 	/**
 	 * This tests the forcing of a function to be a thunk with CreateThunkFunctionCmd
 	 * Tests that the Function start analyzer will create a thunk given the thunk tag on a matching function
@@ -148,27 +147,26 @@ public void testArmThumbThunk() throws Exception {
 		builder.setRegisterValue("TMode", "0x00015da0", "0x00015da0", 1);
 		builder.disassemble("0x00015da0", 27, true);
 
-		
 		builder.createFunction("0x00015da0");
 		builder.createLabel("0x15dac", "chdir");
 		builder.createFunction("0x15dac");
 
 		program = builder.getProgram();
-		
+
 		builder.applyDataType("0x00015d9c", DWordDataType.dataType);
 
 		analyze();
-		
-		
+		// Note: find out why we need an extra analyze here
+		analyze();
+
 		Instruction instruction = program.getListing().getInstructionAt(builder.addr(0x15dac));
 		assertNotNull(instruction);
-		
 
 		Function isThunk = program.getFunctionManager().getFunctionAt(builder.addr(0x00015da0));
 		assertEquals(true, isThunk.isThunk());
 		assertEquals("chdir", isThunk.getName());
 	}
-	
+
 	/**
 	 * This tests the forcing of a function to be a thunk with CreateThunkFunctionCmd
 	 * Tests that the Function start analyzer will create a thunk given the thunk tag on a matching function
@@ -182,32 +180,30 @@ public void testArmThumbThunk2() throws Exception {
 
 		builder = new ProgramBuilder("thunk", ProgramBuilder._ARM);
 
-		builder.setBytes("0x10000", "10 b5 02 4c 24 68 01 94 10 bd 00 00 14 00 01 00 01 20 70 47 11 00 01 00");
+		builder.setBytes("0x10000",
+			"10 b5 02 4c 24 68 01 94 10 bd 00 00 14 00 01 00 01 20 70 47 11 00 01 00");
 		builder.setRegisterValue("TMode", "0x10000", "0x10000", 1);
 		builder.disassemble("0x10000", 27, true);
 
-		
 		builder.createLabel("00010000", "thunker");
 		builder.createFunction("0x10000");
 		builder.createLabel("00010010", "thunkee");
 		builder.createFunction("00010010");
 
 		program = builder.getProgram();
-		
+
 		//builder.applyDataType("0x00015d9c", DWordDataType.dataType);
 
 		analyze();
-		
-		
+
 		Instruction instruction = program.getListing().getInstructionAt(builder.addr(0x10000));
 		assertNotNull(instruction);
-		
 
 		Function isThunk = program.getFunctionManager().getFunctionAt(builder.addr(0x10000));
 		assertEquals(true, isThunk.isThunk());
 		assertEquals("thunker", isThunk.getName());
 	}
-	
+
 	/**
 	 * Tests that the Function start analyzer will create a thunk given the thunk tag on a matching function
 	 * Tests that constant propagation creates a reference using the callfixup value in LR
@@ -219,40 +215,38 @@ public void testPPCblrlThunk() throws Exception {
 		builder = new ProgramBuilder("thunk", ProgramBuilder._PPC_32);
 
 		/**
-         *  bl         __get_pc_thunk_lr
-         *  mfspr      r30,LR
-         *  lbz        r3,0x0(r30)
-         *  blr
+		 *  bl         __get_pc_thunk_lr
+		 *  mfspr      r30,LR
+		 *  lbz        r3,0x0(r30)
+		 *  blr
 		 */
 		builder.setBytes("0x00002000", "42 80 00 31 7f c8 02 a6 88 1e 00 00 4e 80 00 20");
 		builder.disassemble("0x00002000", 27, true);
 
 		/**
-         *  blrl
-         *  lbz        r12,0x0(r10)
-         *  blr
+		 *  blrl
+		 *  lbz        r12,0x0(r10)
+		 *  blr
 		 */
 		builder.setBytes("0x0002030", "4e 80 00 21 89 8a 00 00 4e 80 00 20");
 		builder.disassemble("0x0002030", 27, true);
 
 		builder.createFunction("0x0002000");
-		
+
 		builder.createFunction("0x0002030");
 
 		program = builder.getProgram();
 
 		analyze();
-		
-		
+
 		Instruction instruction = program.getListing().getInstructionAt(builder.addr(0x2008));
 		assertNotNull(instruction);
 		Reference[] referencesFrom = instruction.getReferencesFrom();
-		
+
 		// Thunk will set a value in LR that is not normal from the assumed return of a function
 		// used to calculate a constant reference
 		// TODO: There is a left-over BAD reference.  Need to clean references on re-analysis
 		assertEquals(0x2034L, referencesFrom[1].getToAddress().getOffset());
-		
 
 		Function thunker = program.getFunctionManager().getFunctionAt(builder.addr(0x0002030));
 		assertEquals("__get_pc_thunk_lr", thunker.getName());
```
-----------------------------------
