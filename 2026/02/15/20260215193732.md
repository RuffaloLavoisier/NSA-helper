# Commit: 92f895078c5bb65a86e64f02bbfc2b05dc99e7a9
## Message: Merge remote-tracking branch
'origin/GP-6421-dragonmacher-context-column-sorting' (Closes #8943)
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datawindow/DataTableModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datawindow/DataTableModel.java
index 5cd34439994..532c6a12d6b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datawindow/DataTableModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datawindow/DataTableModel.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -203,6 +203,11 @@ public String getColumnName() {
 			return "Data";
 		}
 
+		@Override
+		public String getColumnDescription() {
+			return "Data value";
+		}
+
 		@Override
 		public String getValue(DataRowObject rowObject, Settings settings, Program p,
 				ServiceProvider provider) throws IllegalArgumentException {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesTableModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesTableModel.java
index f93a71f6bf0..0b75ecd2ee6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesTableModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesTableModel.java
@@ -15,13 +15,17 @@
  */
 package ghidra.app.plugin.core.navigation.locationreferences;
 
-import java.awt.Component;
+import java.awt.*;
 import java.util.*;
 
+import javax.swing.*;
+import javax.swing.text.View;
+
 import org.apache.commons.lang3.StringUtils;
 
 import docking.widgets.search.SearchLocationContext;
 import docking.widgets.table.GTableCellRenderingData;
+import generic.theme.GThemeDefaults.Colors;
 import ghidra.docking.settings.Settings;
 import ghidra.framework.plugintool.ServiceProvider;
 import ghidra.program.model.address.Address;
@@ -29,12 +33,14 @@
 import ghidra.program.util.ProgramLocation;
 import ghidra.util.datastruct.Accumulator;
 import ghidra.util.exception.CancelledException;
+import ghidra.util.layout.AbstractLayoutManager;
 import ghidra.util.table.AddressBasedTableModel;
 import ghidra.util.table.AddressPreviewTableModel;
 import ghidra.util.table.column.AbstractGhidraColumnRenderer;
 import ghidra.util.table.column.GColumnRenderer;
 import ghidra.util.table.field.AbstractProgramBasedDynamicTableColumn;
 import ghidra.util.task.TaskMonitor;
+import utility.function.Callback;
 
 /**
  * A table model that shows the same contents as the {@link AddressPreviewTableModel}, but will
@@ -129,6 +135,12 @@ public ProgramLocation getProgramLocation(int row, int column) {
 	private class ContextTableColumn
 			extends AbstractProgramBasedDynamicTableColumn<LocationReference, LocationReference> {
 
+		private static final String OFFCUT_STRING = "<< OFFCUT >>";
+		private static final Callback DUMMY_CALLBACK = () -> {
+			// dummy
+		};
+
+		private Comparator<LocationReference> comparator = new ContextComparator();
 		private ContextCellRenderer renderer = new ContextCellRenderer();
 
 		@Override
@@ -150,45 +162,31 @@ public String getColumnDescription() {
 		}
 
 		@Override
-		public GColumnRenderer<LocationReference> getColumnRenderer() {
-			return renderer;
-		}
-	}
-
-	private class ContextCellRenderer extends AbstractGhidraColumnRenderer<LocationReference> {
-
-		private static final String OFFCUT_STRING = "<< OFFCUT >>";
-
-		{
-			setHTMLRenderingEnabled(true);
+		public Comparator<LocationReference> getComparator() {
+			return comparator;
 		}
 
 		@Override
-		public Component getTableCellRendererComponent(GTableCellRenderingData data) {
-
-			// initialize
-			super.getTableCellRendererComponent(data);
+		public GColumnRenderer<LocationReference> getColumnRenderer() {
+			return renderer;
+		}
 
-			LocationReference rowObject = (LocationReference) data.getRowObject();
-			String refTypeString = getRefTypeString(rowObject, data.isSelected());
+		private String getCellDisplayText(LocationReference rowObject) {
+			String refTypeString = getRefTypeString(rowObject, DUMMY_CALLBACK);
 			if (refTypeString != null) {
-				setText(refTypeString);
-				return this;
+				return refTypeString;
 			}
 
-			// when the row object does not represent an applied reference, then it may have context
 			SearchLocationContext context = rowObject.getContext();
-			String text = context.getBoldMatchingText();
-			setText(text);
-			return this;
+			return context.getPlainText();
 		}
 
-		private String getRefTypeString(LocationReference rowObject, boolean isSelected) {
+		private String getRefTypeString(LocationReference rowObject, Callback offcutCallback) {
 			String refType = rowObject.getRefTypeString();
 			if (!StringUtils.isBlank(refType)) {
 				String trailingText = "";
 				if (rowObject.isOffcutReference()) {
-					setForeground(getErrorForegroundColor(isSelected));
+					offcutCallback.call();
 					trailingText = OFFCUT_STRING;
 				}
 				return refType + trailingText;
@@ -196,15 +194,167 @@ private String getRefTypeString(LocationReference rowObject, boolean isSelected)
 			return null;
 		}
 
-		@Override
-		public String getFilterString(LocationReference rowObject, Settings settings) {
-			String refTypeString = getRefTypeString(rowObject, false);
-			if (refTypeString != null) {
-				return refTypeString;
+		private class ContextComparator implements Comparator<LocationReference> {
+
+			@Override
+			public int compare(LocationReference lr1, LocationReference lr2) {
+
+				/*
+				 * Context text may be lines with leading line numbers or other text, such as the 
+				 * ref type (e.g., READ, WRITE, etc).   Further, the table's results may include 
+				 * some matches with line numbers and some without.
+				 */
+
+				// Use line numbers when both clients have them, as string integer comparisons do not 
+				// naturally sort by integer value.
+				SearchLocationContext c1 = lr1.getContext();
+				int l1 = c1.getLineNumber();
+				SearchLocationContext c2 = lr2.getContext();
+				int l2 = c2.getLineNumber();
+				int result = 0;
+				if (l1 >= 0 && l2 >= 0) {
+					result = Integer.compare(l1, l2);
+					if (result != 0) {
+						return result;
+					}
+				}
+
+				// Either both or not using line numbers or they have the same line number.  Sort by
+				// the string display value.
+				String t1 = getCellDisplayText(lr1);
+				String t2 = getCellDisplayText(lr2);
+				result = t1.compareTo(t2);
+				if (result != 0) {
+					return result;
+				}
+
+				// Same text; compare by address
+				Address a1 = lr1.getLocationOfUse();
+				Address a2 = lr2.getLocationOfUse();
+				return a1.compareTo(a2);
 			}
+		}
 
-			SearchLocationContext context = rowObject.getContext();
-			return context.getPlainText();
+		private class ContextCellRenderer extends AbstractGhidraColumnRenderer<LocationReference> {
+
+			private JPanel htmlContainer = new JPanel(new HtmlTruncatingLayout());
+			private JLabel ellipsisLabel = new JLabel("...");
+
+			ContextCellRenderer() {
+				setHTMLRenderingEnabled(true);
+			}
+
+			@Override
+			public Component getTableCellRendererComponent(GTableCellRenderingData data) {
+
+				// initialize
+				super.getTableCellRendererComponent(data);
+
+				LocationReference rowObject = (LocationReference) data.getRowObject();
+				Callback offcutCallback = () -> {
+					boolean isSelected = data.isSelected();
+					setForeground(getErrorForegroundColor(isSelected));
+				};
+				String refTypeString = getRefTypeString(rowObject, offcutCallback);
+				if (refTypeString != null) {
+					setText(refTypeString);
+					return this;
+				}
+
+				/*
+				 	At this point we have html context.  Build a renderer that is a panel with 2
+				 	children: the html label (this renderer object) and an ellipsis label that will
+				 	be visible as needed. 
+				 */
+				SearchLocationContext context = rowObject.getContext();
+				String html = context.getBoldMatchingText();
+				setText(html);
+
+				ellipsisLabel.setOpaque(true);
+				ellipsisLabel.setForeground(Colors.FOREGROUND);
+				ellipsisLabel.setBackground(getBackground());
+
+				htmlContainer.setBackground(getBackground());
+				htmlContainer.removeAll();
+				htmlContainer.add(this);
+				htmlContainer.add(ellipsisLabel);
+
+				return htmlContainer;
+			}
+
+			@Override
+			public String getFilterString(LocationReference rowObject, Settings settings) {
+				String refTypeString = getRefTypeString(rowObject, DUMMY_CALLBACK);
+				if (refTypeString != null) {
+					return refTypeString;
+				}
+
+				SearchLocationContext context = rowObject.getContext();
+				return context.getPlainText();
+			}
 		}
+
+		/**
+		 * A layout manager that positions 2 labels: a leading label with html and a trailing label
+		 * with an ellipsis, which may not be visible.  JLabels rendering html will not show an
+		 * ellipsis when clipped.   We use these 2 labels here to show when the leading html label's
+		 * text is clipped.
+		 */
+		private class HtmlTruncatingLayout extends AbstractLayoutManager {
+
+			@Override
+			public Dimension preferredLayoutSize(Container parent) {
+
+				Dimension d = new Dimension();
+				int n = parent.getComponentCount();
+				for (int i = 0; i < n; i++) {
+					Component c = parent.getComponent(i);
+					Dimension cd = c.getPreferredSize();
+					d.width += cd.width;
+					d.height = Math.max(d.height, cd.height);
+				}
+
+				Insets insets = parent.getInsets();
+				d.width += insets.left + insets.right;
+				d.height += insets.top + insets.bottom;
+				return d;
+			}
+
+			@Override
+			public void layoutContainer(Container parent) {
+				// Assumption: the leading component is an html view; the trailing component is a
+				// label with an ellipsis
+
+				JComponent c1 = (JComponent) parent.getComponent(0);
+				Dimension d = parent.getSize();
+				Insets insets = parent.getInsets();
+				int width = d.width - insets.left - insets.right;
+
+				View v = (View) c1.getClientProperty("html");
+				Insets i = c1.getInsets();
+				int availableWidth = width - (i.left + i.right);
+				int htmlw = (int) v.getPreferredSpan(View.X_AXIS);
+
+				JLabel c2 = (JLabel) parent.getComponent(1);
+				Dimension c2d = c2.getPreferredSize();
+				boolean isClipped = htmlw > availableWidth && width != 0;
+				if (isClipped) {
+					availableWidth -= c2d.width; // save room for ellipsis
+					int c2x = availableWidth;
+					int c2y = insets.top;
+					c2.setBounds(c2x, c2y, c2d.width, c2d.height);
+				}
+
+				c2.setVisible(isClipped);
+
+				int c1x = insets.left;
+				int c1y = insets.top;
+				int cyh = d.height - (i.top + i.bottom);
+				c1.setBounds(c1x, c1y, availableWidth, cyh);
+			}
+
+		}
+
 	}
+
 }
diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java
index 5f1a3529b9b..f6f4b41fd12 100644
--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java
+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java
@@ -95,7 +95,7 @@ protected SearchLocationContext getContext() {
 	protected SearchLocationContext getContext(DecompilerVariable var) {
 
 		SearchLocationContextBuilder builder = new SearchLocationContextBuilder();
-		builder.append(line.getLineNumber() + ": ");
+		builder.lineNumber(line.getLineNumber());
 		List<ClangToken> tokens = line.getAllTokens();
 		for (ClangToken token : tokens) {
 			if (token.equals(var.variable)) {
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContext.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContext.java
index 310be816a93..e244fc1348a 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContext.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContext.java
@@ -35,6 +35,7 @@ public class SearchLocationContext {
 	public static final SearchLocationContext EMPTY_CONTEXT = new SearchLocationContext();
 
 	private final List<Part> parts;
+	private int lineNumber = -1;
 
 	/**
 	 * A factory method to create a context instance with the given text.  The context created this
@@ -81,12 +82,18 @@ private SearchLocationContext(String context) {
 		this.parts = parts;
 	}
 
+	SearchLocationContext(List<Part> parts, int lineNumber) {
+		this.parts = parts;
+		this.lineNumber = lineNumber;
+	}
+
 	/**
 	 * The full plain text of this context.
 	 * @return the text
 	 */
 	public String getPlainText() {
-		StringBuilder buffy = new StringBuilder();
+		String lnText = getLineNumberText(false);
+		StringBuilder buffy = new StringBuilder(lnText);
 		for (Part part : parts) {
 			buffy.append(part.getText());
 		}
@@ -98,20 +105,32 @@ public String getPlainText() {
 	 * @return the text
 	 */
 	public String getDebugText() {
-		StringBuilder buffy = new StringBuilder();
+		String lnText = getLineNumberText(false);
+		StringBuilder buffy = new StringBuilder(lnText);
 		for (Part part : parts) {
 			buffy.append(part.getDebugText());
 		}
 		return buffy.toString();
 	}
 
+	private String getLineNumberText(boolean isHtml) {
+		if (lineNumber < 0) {
+			return "";
+		}
+
+		// use a non-breaking space for html so lines do not get wrapped
+		String space = isHtml ? HTMLUtilities.HTML_SPACE : " ";
+		return lineNumber + ":" + space;
+	}
+
 	/**
 	 * Returns HTML text for this context.  Any matching items embedded in the returned string will
 	 * be bold.
 	 * @return the text
 	 */
 	public String getBoldMatchingText() {
-		StringBuilder buffy = new StringBuilder();
+		String lnText = getLineNumberText(true);
+		StringBuilder buffy = new StringBuilder(lnText);
 		for (Part part : parts) {
 			buffy.append(part.getHtmlText());
 		}
@@ -134,6 +153,14 @@ public List<String> getMatches() {
 		return matches;
 	}
 
+	/**
+	 * Returns the line number or -1 if the value has not been set.
+	 * @return the line number
+	 */
+	public int getLineNumber() {
+		return lineNumber;
+	}
+
 	@Override
 	public String toString() {
 		return getPlainText();
@@ -158,7 +185,7 @@ String getText() {
 		abstract String getDebugText();
 
 		static String fixBreakingSpaces(String s) {
-			String updated = s.replaceAll("\\s", "&nbsp;");
+			String updated = s.replaceAll("\\s", HTMLUtilities.HTML_SPACE);
 			return updated;
 		}
 
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContextBuilder.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContextBuilder.java
index c550f919d90..ed698448717 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContextBuilder.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/search/SearchLocationContextBuilder.java
@@ -29,6 +29,7 @@
 public class SearchLocationContextBuilder {
 
 	private List<Part> parts = new ArrayList<>();
+	private int lineNumber = -1;
 
 	/**
 	 * Appends the given text to this builder.
@@ -58,6 +59,17 @@ public SearchLocationContextBuilder appendMatch(String text) {
 		return this;
 	}
 
+	/**
+	 * Sets an optional line number for clients that use numbered lines.  The line number will be 
+	 * prepended to the text form of the context.
+	 * @param line the line number
+	 * @return this builder
+	 */
+	public SearchLocationContextBuilder lineNumber(int line) {
+		this.lineNumber = line;
+		return this;
+	}
+
 	/**
 	 * Adds a newline character to the previously added text. 
 	 * @return this builder
@@ -77,7 +89,7 @@ public SearchLocationContextBuilder newline() {
 	 * @return the context
 	 */
 	public SearchLocationContext build() {
-		return new SearchLocationContext(parts);
+		return new SearchLocationContext(parts, lineNumber);
 	}
 
 	/**
```
-----------------------------------
