# Commit: b61f0c27104169713d824ca5820512d6b2a3af0d
## Message: GP-6449: Fix Memory viewer with multiple address spaces.
## Diff:
```
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/BasicAutoReadMemorySpec.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/BasicAutoReadMemorySpec.java
index 5fec26d6920..e84000a10fc 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/BasicAutoReadMemorySpec.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/BasicAutoReadMemorySpec.java
@@ -52,7 +52,8 @@ public CompletableFuture<Boolean> readMemory(PluginTool tool,
 	/**
 	 * Automatically read all visible memory
 	 */
-	VISIBLE("1_READ_VISIBLE", AutoReadMemoryAction.NAME_VISIBLE, AutoReadMemoryAction.ICON_VISIBLE) {
+	VISIBLE("1_READ_VISIBLE", AutoReadMemoryAction.NAME_VISIBLE,
+			AutoReadMemoryAction.ICON_VISIBLE) {
 		@Override
 		public CompletableFuture<Boolean> readMemory(PluginTool tool,
 				DebuggerCoordinates coordinates,
@@ -77,7 +78,8 @@ public CompletableFuture<Boolean> readMemory(PluginTool tool,
 	 * Automatically read all visible memory, unless it is read-only, in which case, only read it if
 	 * it has not already been read.
 	 */
-	VIS_RO_ONCE("2_READ_VIS_RO_ONCE", AutoReadMemoryAction.NAME_VIS_RO_ONCE, AutoReadMemoryAction.ICON_VIS_RO_ONCE) {
+	VIS_RO_ONCE("2_READ_VIS_RO_ONCE", AutoReadMemoryAction.NAME_VIS_RO_ONCE,
+			AutoReadMemoryAction.ICON_VIS_RO_ONCE) {
 		@Override
 		public CompletableFuture<Boolean> readMemory(PluginTool tool,
 				DebuggerCoordinates coordinates,
@@ -136,8 +138,15 @@ protected AddressSetView quantize(int blockBits, AddressSetView set) {
 			// Not terribly efficient, but this is one range most of the time
 			for (AddressRange range : set) {
 				AddressSpace space = range.getAddressSpace();
-				Address min = space.getAddress(range.getMinAddress().getOffset() & blockMask);
-				Address max = space.getAddress(range.getMaxAddress().getOffset() | ~blockMask);
+				long minOffset = range.getMinAddress().getOffset() & blockMask;
+				minOffset = Math.max(minOffset, space.getMinAddress().getOffset());
+				long maxOffset = range.getMaxAddress().getOffset() | ~blockMask;
+				maxOffset = Math.min(maxOffset, space.getMaxAddress().getOffset());
+				if (minOffset > maxOffset) {
+					continue;
+				}
+				Address min = space.getAddress(minOffset);
+				Address max = space.getAddress(maxOffset);
 				result.add(new AddressRangeImpl(min, max));
 			}
 			return result;
diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memory/CachedBytePage.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memory/CachedBytePage.java
index 01a87f1d42e..88289b031a3 100644
--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memory/CachedBytePage.java
+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memory/CachedBytePage.java
@@ -47,6 +47,9 @@ private static boolean coordsEqualForMemory(DebuggerCoordinates c1, DebuggerCoor
 	record CacheKey(DebuggerCoordinates coordinates, Address start) {
 		int computeOffset(DebuggerCoordinates coordinates, Address address) {
 			if (coordsEqualForMemory(this.coordinates, coordinates)) {
+				if (start.getAddressSpace() != address.getAddressSpace()) {
+					return -1;
+				}
 				long offset = address.subtract(start);
 				if (0 <= offset && offset < PAGE_SIZE) {
 					return (int) offset;
```
-----------------------------------
