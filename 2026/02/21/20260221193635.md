# Commit: 7a895ec5e7d5ce0e623302dd2cc596835671c1a8
## Message: GP-6451 - PR for Annotation method update; minor fixups
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
index 7ba2871380a..bbe24f89295 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/AnnotatedStringHandler.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -126,12 +126,15 @@ default String getPrototypeString(String displayText) {
 	}
 
 	/**
-	 * Returns an array with modifications by the annotation; null otherwise.
-	 * @param  text An array of strings to modify.
-	 * @param  program The program with which the returned string is associated.
-	 * @return The modified array; null otherwise.
+	 * Returns an array with modifications by the annotation; null otherwise.  This method will be 
+	 * called by the framework when comments are created, before they are applied.  This allows the
+	 * handler to perform fixups on the input text before it is saved to the database.
+	 * 
+	 * @param text the array of annotation parts to modify
+	 * @param program the program
+	 * @return the modified array; null otherwise
 	 */
-	default String[] modify(String[] test, Program program) {
+	default String[] modify(String[] text, Program program) {
 		return null;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
index 733887c0a00..e17653a6e28 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/Annotation.java
@@ -15,51 +15,53 @@
  */
 package ghidra.app.util.viewer.field;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import java.util.*;
 import java.util.stream.Collectors;
 
 import ghidra.program.model.listing.Program;
 
 public class Annotation {
 
-	public static final String ESCAPABLE_CHARS = "{}\"\\";
+	private static final char BS = '\\';
+	private static final String SEP = "\\s";
+	private static final String ESCAPABLE_CHARS = "{}\"\\";
 
 	private final String[] annotationParts;
 	private final String annotationText;
 
 	/**
 	 * Constructor
-	 * <b>Note</b>: This constructor assumes that the string starts with "{<pre>@</pre>" and ends with '}'
+	 * <br>
+	 * <b>Note</b>: This constructor assumes that the string starts with 
+	 * "{<pre>@</pre>" and ends with '}'
 	 * 
-	 * @param annotationText The complete annotation text.
-	 * text this Annotation can create
-	 * @param program the program
+	 * @param annotationText the complete annotation text.
 	 */
 	public Annotation(String annotationText) {
 		this.annotationParts = parseAnnotationText(annotationText);
 		this.annotationText = annotationText;
 	}
 
-	@Deprecated
-	public Annotation(String annotationText, Program program) {
-		this(annotationText);
-	}
-
 	/**
-	 * Constructor
+	 * Constructor.  Used for creating a new Annotation from a previously parsed annotation String.
 	 *
 	 * @param annotationParts The annotation parts.
-	 * @param program the program
 	 */
 	public Annotation(String[] annotationParts) {
 		this.annotationParts = annotationParts;
 		this.annotationText = buildAnnotationText(annotationParts);
 	}
 
+	/**
+	 * Deprecated.  Use {@link #Annotation(String)}.
+	 * @param annotationText the complete annotation text
+	 * @param program ignored
+	 */
+	@Deprecated
+	public Annotation(String annotationText, Program program) {
+		this(annotationText);
+	}
+
 	public String[] getAnnotationParts() {
 		return annotationParts;
 	}
@@ -80,44 +82,53 @@ private static String[] parseAnnotationText(String text) {
 
 	private static String buildAnnotationText(String[] text) {
 		return Arrays.stream(text)
-				.map((t) -> hasEscapeChars(t) ?
-						("\"" + addEscapeChars(t) + "\"") : t)
+				.map(Annotation::maybeQuote)
 				.collect(Collectors.joining(" ", "{@", "}"));
 	}
 
 	private static String[] parseText(String text) {
-		List<String> textParts = new ArrayList<>();
+		List<String> parts = new ArrayList<>();
 		boolean escape = false;
 		boolean quote = false;
 		StringBuilder buffy = new StringBuilder();
 
-		for (char c: text.toCharArray()) {
+		for (char c : text.toCharArray()) {
 			if (escape) {
 				escape = false;
-				buffy.append('\\');
+				buffy.append(BS);
 				buffy.append(c);
-			} else {
-				if (c == '\\') {
-					escape = true;
-				} else if (c == '\"') {
-					String s = buffy.toString();
-					if (quote) {
-						textParts.add(s);
-					} else {
-						textParts.addAll(Arrays.asList(s.split("\\s")));
-					}
-					buffy.setLength(0);
-					quote = !quote;
-				} else {
-					buffy.append(c);
+				continue;
+			}
+
+			if (c == BS) {
+				escape = true;
+				continue;
+			}
+
+			if (c == '"') {
+				String s = buffy.toString();
+				if (quote) {
+					// end quote; keep the text as a single part
+					parts.add(s);
+				}
+				else {
+					// new quote start; split previous unquoted text into parts
+					parts.addAll(Arrays.asList(s.split(SEP)));
 				}
+				buffy.setLength(0);
+				quote = !quote;
+			}
+			else {
+				buffy.append(c);
 			}
 		}
-		textParts.addAll(Arrays.asList(buffy.toString().split("\\s")));
 
-		return textParts.stream()
-				.filter((t) -> t.length() > 0)
-				.map((t) -> removeEscapeChars(t))
+		String s = buffy.toString();
+		parts.addAll(Arrays.asList(s.split(SEP)));
+
+		return parts.stream()
+				.filter(t -> t.length() > 0)
+				.map(t -> removeEscapeChars(t))
 				.toArray(String[]::new);
 	}
 
@@ -125,28 +136,36 @@ private static String[] parseText(String text) {
 	private static String removeEscapeChars(String text) {
 		boolean escape = false;
 		StringBuilder buffy = new StringBuilder();
-
-		for (char c: text.toCharArray()) {
+		for (char c : text.toCharArray()) {
 			if (escape) {
 				escape = false;
 				if (ESCAPABLE_CHARS.indexOf(c) == -1) {
-					buffy.append('\\');
+					buffy.append(BS); // restore non-escaping backslash
 				}
 				buffy.append(c);
-			} else {
-				if (c == '\\') {
-					escape = true;
-				} else {
-					buffy.append(c);
-				}
+				continue;
 			}
+
+			if (c == BS) {
+				escape = true;
+				continue;
+			}
+
+			buffy.append(c);
 		}
 
 		return buffy.toString();
 	}
 
-	private static boolean hasEscapeChars(String text) {
-		for (char c: text.toCharArray()) {
+	private static String maybeQuote(String text) {
+		if (needsQuotes(text)) {
+			return '"' + escapeAnnotationChars(text) + '"';
+		}
+		return text;
+	}
+
+	private static boolean needsQuotes(String text) {
+		for (char c : text.toCharArray()) {
 			if (ESCAPABLE_CHARS.indexOf(c) != -1 || Character.isWhitespace(c)) {
 				return true;
 			}
@@ -154,12 +173,11 @@ private static boolean hasEscapeChars(String text) {
 		return false;
 	}
 
-	private static String addEscapeChars(String text) {
+	private static String escapeAnnotationChars(String text) {
 		StringBuilder buffy = new StringBuilder();
-
-		for (char c: text.toCharArray()) {
+		for (char c : text.toCharArray()) {
 			if (ESCAPABLE_CHARS.indexOf(c) != -1) {
-				buffy.append('\\');
+				buffy.append(BS);
 			}
 			buffy.append(c);
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
index 267469847f1..b56eb23c92e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/CommentUtils.java
@@ -58,9 +58,11 @@ public static String fixupAnnotations(String rawCommentText, Program program) {
 			return null;
 		}
 
-		// this function will take any given Symbol annotations and change the text, replacing
-		// the symbol name with the address of the symbol
-		Function<Annotation, Annotation> symbolFixer = annotation -> {
+		// this function will take any annotation and call the annotation to perform updates to the 
+		// input text as needed.   An example is the Symbol annotation, which will replace any 
+		// symbol name with that symbol's address.  This allows future renames of that symbol to 
+		// appear in the comment text containing the annotation. 
+		Function<Annotation, Annotation> fixer = annotation -> {
 			String[] annotationParts = annotation.getAnnotationParts();
 			AnnotatedStringHandler handler = getAnnotationHandler(annotationParts);
 
@@ -73,7 +75,7 @@ public static String fixupAnnotations(String rawCommentText, Program program) {
 		};
 
 		StringBuilder buffy = new StringBuilder();
-		List<CommentPart> parts = doParseTextIntoParts(rawCommentText, symbolFixer, program);
+		List<CommentPart> parts = doParseTextIntoParts(rawCommentText, fixer, program);
 		for (CommentPart part : parts) {
 			buffy.append(part.getRawText());
 		}
@@ -284,35 +286,29 @@ private static Pattern createAnnotationStartPattern() {
 	 */
 	private static int findAnnotationEnd(String comment, int start) {
 
-		boolean escaped = false;
-		boolean inQuote = false;
+		boolean escape = false;
+		boolean quote = false;
 		for (int i = start; i < comment.length(); i++) {
-
-			boolean wasEscaped = escaped;
-			escaped = false;
-			char prev = '\0';
-			if (i != 0 && !wasEscaped) {
-				prev = comment.charAt(i - 1);
+			char c = comment.charAt(i);
+			if (escape) {
+				escape = false;
+				continue;
 			}
 
-			char c = comment.charAt(i);
-			if (prev == '\\') {
-				if (Annotation.ESCAPABLE_CHARS.indexOf(c) != -1) {
-					escaped = true;
-					continue;
-				}
+			if (c == '\\') {
+				escape = true;
+				continue;
 			}
 
 			if (c == '"') {
-				inQuote = !inQuote;
+				quote = !quote;
 			}
 			else if (c == '}') {
-				if (!inQuote) {
+				if (!quote) {
 					return i + 1;
 				}
 			}
 		}
-
 		return -1;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
index 1e9ca4042cd..3252cf86256 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ProgramAnnotatedStringHandler.java
@@ -18,7 +18,7 @@
 import java.util.List;
 
 import org.apache.commons.io.FilenameUtils;
-import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Strings;
 
 import docking.widgets.fieldpanel.field.AttributedString;
 import ghidra.app.nav.Navigatable;
@@ -64,14 +64,15 @@ public AttributedString createAnnotatedString(AttributedString prototypeString,
 	}
 
 	private String getDisplayText(String[] text) {
-		// assume that the 'extra text' means that is how the user wants to display the annotation
+
 		if (text.length > 2) {
-			StringBuffer buffer = new StringBuffer();
+			// assume that the extra text means that is how the user wants to display the annotation
+			StringBuilder buffy = new StringBuilder();
 			for (int i = 2; i < text.length; i++) {
-				buffer.append(text[i]).append(" ");
+				buffy.append(text[i]).append(" ");
 			}
-			buffer.deleteCharAt(buffer.length() - 1); // remove last space
-			return buffer.toString();
+			buffy.deleteCharAt(buffy.length() - 1); // remove last space
+			return buffy.toString();
 		}
 
 		String symbolText = getUnvalidatedDisplayText(text);
@@ -137,7 +138,7 @@ public boolean handleMouseClick(String[] annotationParts, Navigatable navigatabl
 
 		DomainFolder folder;
 		if (path.length() > 0) {
-			path = StringUtils.prependIfMissing(FilenameUtils.separatorsToUnix(path), "/");
+			path = Strings.CS.prependIfMissing(FilenameUtils.separatorsToUnix(path), "/");
 			folder = projectData.getFolder(path);
 			if (folder == null) {
 				Msg.showInfo(getClass(), null, "Folder Not Found: " + path,
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
index 7e98ec9cec1..6509f93f00a 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java
@@ -16,7 +16,6 @@
 package ghidra.app.util.viewer.field;
 
 import java.util.List;
-import java.util.regex.Pattern;
 
 import docking.widgets.fieldpanel.field.AttributedString;
 import generic.theme.GThemeDefaults.Colors.Messages;
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
index 89f84aec35a..66c2cc8deea 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/util/viewer/field/AnnotationTest.java
@@ -16,6 +16,7 @@
 package ghidra.app.util.viewer.field;
 
 import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 
 import java.awt.*;
@@ -809,7 +810,6 @@ public void testInvalidAnnotation_MissingAttributes_DoesNotMatchKnownAnnotation(
 
 	@Test
 	public void testInvalidAnnotation_NoSuchSymbol() {
-
 		// valid annotation, invalid symbol
 		String data = "This is an annotated string {@symbol 01001001}";
 		FieldElement fieldElement =
```
-----------------------------------
