# Commit: 478abffe5b1d04c69c402b96623c2e56b4a7b67f
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceEmulationIntegration.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceEmulationIntegration.java
index 4fc58d32bd6..b0c4d1917aa 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceEmulationIntegration.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceEmulationIntegration.java
@@ -795,6 +795,9 @@ public <B, U> AddressSetView readUninitialized(PcodeThread<Object> thread,
 				return set;
 			}
 			AddressSpace space = set.getMinAddress().getAddressSpace();
+			if (space.isUniqueSpace()) {
+				return set;
+			}
 			PcodeTraceDataAccess acc = space.isRegisterSpace() ? getRegAccess(thread) : memAccess;
 			return handlerFor(piece).readUninitialized(acc, thread, piece, set);
 		}
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/time/DBTraceTimeManager.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/time/DBTraceTimeManager.java
index c5aa671421b..6588ea8e384 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/time/DBTraceTimeManager.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/time/DBTraceTimeManager.java
@@ -235,13 +235,14 @@ protected DBTraceSnapshot doFindNearest(TraceSchedule schedule, long version) {
 	@Override
 	public TraceSnapshot findSnapshotWithNearestPrefix(TraceSchedule schedule) {
 		long version = trace.getEmulatorCacheVersion();
-		Optional<? extends TraceSnapshot> exists = getSnapshotsWithSchedule(schedule).stream()
+		TraceSchedule noPSteps = schedule.dropPSteps();
+		Optional<? extends TraceSnapshot> exists = getSnapshotsWithSchedule(noPSteps).stream()
 				.filter(s -> s.getVersion() >= version)
 				.findFirst();
 		if (exists.isPresent()) {
 			return exists.get();
 		}
-		return doFindNearest(schedule.dropPSteps(), version);
+		return doFindNearest(noPSteps, version);
 	}
 
 	@Override
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
index d30d8879195..75ea6010504 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
@@ -86,7 +86,7 @@ Flow globalSet(Address address) {
 
 	protected class ReDisState {
 		protected final TaskMonitor monitor;
-		protected final Map<AddressSpace, MemBuffer> progMemBuffers = new HashMap<>();
+		protected final Map<AddressSpace, DumbMemBufferImpl> progMemBuffers = new HashMap<>();
 		protected final ProgramContext tempContext = new ProgramContextImpl(language);
 		protected final AddressSet visited = new AddressSet();
 		protected final Deque<Flow> queue = new LinkedList<>();
@@ -121,9 +121,10 @@ protected ReDisState addFlow(Flow flow) {
 		}
 
 		protected MemBuffer createBuffer(Address at) {
-			return progMemBuffers.computeIfAbsent(at.getAddressSpace(), space -> {
-				return new DumbMemBufferImpl(program.getMemory(), space.getMinAddress());
-			});
+			DumbMemBufferImpl buffer = progMemBuffers.computeIfAbsent(at.getAddressSpace(),
+				space -> new DumbMemBufferImpl(program.getMemory(), space.getMinAddress()));
+			buffer.setPosition(at);
+			return buffer;
 		}
 
 		/**
@@ -253,6 +254,11 @@ protected Instruction nextInstruction(Flow flow, boolean isInDelaySlot)
 			ReDisassemblerContext ctx = new ReDisassemblerContext(state, flow);
 			try {
 				InstructionPrototype prototype = language.parse(buffer, ctx, false);
+				Instruction exists = program.getListing().getInstructionAt(flow.to);
+				if (exists != null && exists.getPrototype().equals(prototype) &&
+					flow.type != FlowType.SEED) {
+					return null;
+				}
 				return createInstruction(flow.to, prototype, buffer, ctx);
 			}
 			catch (UnknownInstructionException e) {
```
-----------------------------------
