# Commit: 2a14ce7be480cd832e0c26e3d38d60b4d957f3a7
## Message: Merge remote-tracking branch 'origin/patch'
## Diff:
```
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
index c47293afb9c..260313c5768 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
@@ -417,7 +417,7 @@ bool SubvariableFlow::traceForward(ReplaceVarnode *rvn)
 	}
 	// Is the small variable getting zero padded into something that is fully consumed
 	if ((!aggressive)&&((outvn->getConsume() & rvn->mask) != outvn->getConsume())) {
-	  addSuggestedPatch(rvn,op,-1);
+	  addExtensionPatch(rvn,op,-1);
 	  hcount += 1;		// Dealt with this descendant
 	  break;
 	}
@@ -477,10 +477,10 @@ bool SubvariableFlow::traceForward(ReplaceVarnode *rvn)
       newmask = (rvn->mask << sa) & calc_mask( outvn->getSize() );
       if (newmask == 0) break;	// Subvar is cleared, truncate flow
       if (rvn->mask != (newmask >> sa)) return false; // subvar is clipped
-	// Is the small variable getting zero padded into something that is fully consumed
+	// Is the small variable getting zero padded into something that is consumed beyond the variable
       if (((rvn->mask & 1)!=0)&&(sa + bitsize == 8*outvn->getSize())
-	  &&(calc_mask(outvn->getSize()) == outvn->getConsume())) {
-	addSuggestedPatch(rvn,op,sa);
+	  &&((outvn->getConsume() & ~newmask) != 0)) {
+	addExtensionPatch(rvn,op,sa);
 	hcount += 1;
 	break;
       }
@@ -514,10 +514,10 @@ bool SubvariableFlow::traceForward(ReplaceVarnode *rvn)
 	hcount += 1;		// Dealt with this descendant
 	break;
       }
-	// Is the small variable getting zero padded into something that is fully consumed
+	// Is the small variable getting zero padded into something that is consumed beyond the variable
       if (((newmask&1)==1)&&(sa + bitsize == 8*outvn->getSize())
-	  &&(calc_mask(outvn->getSize()) == outvn->getConsume())) {
-	addSuggestedPatch(rvn,op,0);
+	  &&((outvn->getConsume() & ~newmask) != 0)) {
+	addExtensionPatch(rvn,op,0);
 	hcount += 1;
 	break;
       }
@@ -1211,14 +1211,14 @@ void SubvariableFlow::addBooleanPatch(PcodeOp *pullop,ReplaceVarnode *rvn,int4 s
   // this is not a true modification
 }
 
-/// \brief Mark a subgraph variable flowing to an operation that expands it by padding with zero bits.
+/// \brief Mark a subgraph variable flowing to an operation that extends it by padding with zero bits.
 ///
 /// Data-flow along the specified edge within the logical subgraph is terminated by added a PatchRecord.
 /// This doesn't count as a logical value that needs to be patched (by itself).
 /// \param rvn is the given subgraph variable
 /// \param pushop is the operation that pads the variable
 /// \param sa is the amount the logical value is shifted to the left
-void SubvariableFlow::addSuggestedPatch(ReplaceVarnode *rvn,PcodeOp *pushop,int4 sa)
+void SubvariableFlow::addExtensionPatch(ReplaceVarnode *rvn,PcodeOp *pushop,int4 sa)
 
 {
   patchlist.emplace_back();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
index d389e8979d4..6843eb77d86 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
@@ -114,7 +114,7 @@ class SubvariableFlow {
   void addTerminalPatch(PcodeOp *pullop,ReplaceVarnode *rvn);
   void addTerminalPatchSameOp(PcodeOp *pullop,ReplaceVarnode *rvn,int4 slot);
   void addBooleanPatch(PcodeOp *pullop,ReplaceVarnode *rvn,int4 slot);
-  void addSuggestedPatch(ReplaceVarnode *rvn,PcodeOp *pushop,int4 sa);
+  void addExtensionPatch(ReplaceVarnode *rvn,PcodeOp *pushop,int4 sa);
   void addComparePatch(ReplaceVarnode *in1,ReplaceVarnode *in2,PcodeOp *op);
   ReplaceVarnode *addConstant(ReplaceOp *rop,uintb mask,uint4 slot,Varnode *constvn);
   ReplaceVarnode *addNewConstant(ReplaceOp *rop,uint4 slot,uintb val);
diff --git a/Ghidra/Features/PyGhidra/src/main/py/README.md b/Ghidra/Features/PyGhidra/src/main/py/README.md
index 72ee7b09296..6be76ecd3f6 100644
--- a/Ghidra/Features/PyGhidra/src/main/py/README.md
+++ b/Ghidra/Features/PyGhidra/src/main/py/README.md
@@ -228,12 +228,12 @@ def program_loader() -> "ProgramLoader.Builder":
 ```python
 def task_monitor(
         timeout: Optional[int] = None
-    ) -> "PyGhidraTaskMonitor":
+    ) -> "TaskMonitor":
     """
-    Convenience function to get a "PyGhidraTaskMonitor" object.
+    Convenience function to get a "TaskMonitor" object.
 
     :param timeout: An optional number of seconds to wait before canceling the monitor.
-    :return: A "PyGhidraTaskMonitor"  object.
+    :return: A "TaskMonitor" object.
     """
 ```
 
@@ -577,7 +577,9 @@ __3.1.0__
 __3.0.2__
 * Fixed an issue that prevented [`pyghidra.analysis_properties()`](#pyghidraanalysis_properties)
   from having access to all of the analysis properties.
-* Fixed issues related to the PyGhidra API inadvertently squashing exceptions
+* Fixed issues related to the PyGhidra API inadvertently squashing exceptions.
+* Calling [`pyghidra.task_monitor()`](#pyghidratask_monitor) with no `timeout` parameter will now
+  return a `TaskMonitor.DUMMY` instead of a `PyGhidraTaskMonitor`. 
 
 __3.0.1__
 * Fixed `AttributeError: module 'pyghidra' has no attribute 'program_conext'` when performing a
diff --git a/Ghidra/Features/PyGhidra/src/main/py/src/pyghidra/api.py b/Ghidra/Features/PyGhidra/src/main/py/src/pyghidra/api.py
index 7fe59fe9684..72cfc1d15c1 100644
--- a/Ghidra/Features/PyGhidra/src/main/py/src/pyghidra/api.py
+++ b/Ghidra/Features/PyGhidra/src/main/py/src/pyghidra/api.py
@@ -305,17 +305,20 @@ def program_loader() -> "ProgramLoader.Builder":
 
 def task_monitor(
         timeout: Optional[int] = None
-    ) -> "PyGhidraTaskMonitor":
+    ) -> "TaskMonitor":
     """
-    Convenience function to get a "PyGhidraTaskMonitor" object.
+    Convenience function to get a "TaskMonitor" object.
 
     :param timeout: An optional number of seconds to wait before canceling the monitor.
-    :return: A "PyGhidraTaskMonitor"  object.
+    :return: A "TaskMonitor" object.
     """
+    from ghidra.util.task import TaskMonitor
     from ghidra.pyghidra import PyGhidraTaskMonitor
     from jpype.types import JInt
-    t = None if timeout is None else JInt(timeout)
-    return PyGhidraTaskMonitor(t, None)
+    if timeout is None:
+        return TaskMonitor.DUMMY
+    else:
+        return PyGhidraTaskMonitor(JInt(timeout), None)
 
 def walk_project(
         project: "Project",
```
-----------------------------------
