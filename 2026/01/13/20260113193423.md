# Commit: d95e9e35d7c2397756a646cbf1dbf72bcf641575
## Message: GP-6295: Fix ReDisassembler: MemBuffer address, avoid equiv prototype replacement.
## Diff:
```
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
index d30d8879195..75ea6010504 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/ReDisassembler.java
@@ -86,7 +86,7 @@ Flow globalSet(Address address) {
 
 	protected class ReDisState {
 		protected final TaskMonitor monitor;
-		protected final Map<AddressSpace, MemBuffer> progMemBuffers = new HashMap<>();
+		protected final Map<AddressSpace, DumbMemBufferImpl> progMemBuffers = new HashMap<>();
 		protected final ProgramContext tempContext = new ProgramContextImpl(language);
 		protected final AddressSet visited = new AddressSet();
 		protected final Deque<Flow> queue = new LinkedList<>();
@@ -121,9 +121,10 @@ protected ReDisState addFlow(Flow flow) {
 		}
 
 		protected MemBuffer createBuffer(Address at) {
-			return progMemBuffers.computeIfAbsent(at.getAddressSpace(), space -> {
-				return new DumbMemBufferImpl(program.getMemory(), space.getMinAddress());
-			});
+			DumbMemBufferImpl buffer = progMemBuffers.computeIfAbsent(at.getAddressSpace(),
+				space -> new DumbMemBufferImpl(program.getMemory(), space.getMinAddress()));
+			buffer.setPosition(at);
+			return buffer;
 		}
 
 		/**
@@ -253,6 +254,11 @@ protected Instruction nextInstruction(Flow flow, boolean isInDelaySlot)
 			ReDisassemblerContext ctx = new ReDisassemblerContext(state, flow);
 			try {
 				InstructionPrototype prototype = language.parse(buffer, ctx, false);
+				Instruction exists = program.getListing().getInstructionAt(flow.to);
+				if (exists != null && exists.getPrototype().equals(prototype) &&
+					flow.type != FlowType.SEED) {
+					return null;
+				}
 				return createInstruction(flow.to, prototype, buffer, ctx);
 			}
 			catch (UnknownInstructionException e) {
```
-----------------------------------
