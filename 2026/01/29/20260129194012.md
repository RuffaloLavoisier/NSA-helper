# Commit: 59128b201f84c4c71cef1456bbc784bb285eb8c3
## Message: GP-6362 Limit Associate with Archive action to Program DTM only.
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DataTypeManagerPlugin/data_type_manager_window.html b/Ghidra/Features/Base/src/main/help/help/topics/DataTypeManagerPlugin/data_type_manager_window.html
index 0fd896502ca..0427e54b60f 100644
--- a/Ghidra/Features/Base/src/main/help/help/topics/DataTypeManagerPlugin/data_type_manager_window.html
+++ b/Ghidra/Features/Base/src/main/help/help/topics/DataTypeManagerPlugin/data_type_manager_window.html
@@ -614,8 +614,10 @@ <H3><A name="Associate With Archive"></A>Associate With Archive</H3>
 
         <BLOCKQUOTE>
           <BLOCKQUOTE>
-          <P>Allows the user to associate the selected data type with a new source archive.  This  
-          can also be done by dragging one or more data types to a new source archive.
+          <P>Allows the user to associate the selected data type with a new source archive.  This action
+			copies the selected datatypes to a choosen archive and associates the datatypes with that
+			archive.  A similar result can also be achieved by dragging one or more data types to a new source archive.  This action
+		  only applies to non-Built-In datatypes selected within a Program's Data Type Manager.
 	See this page for more information on 
 	<a href="help/topics/DataTypeManagerPlugin/data_type_manager_description.htm#source_archive">source archives</a>.
 		</P>
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/associate/AssociateDataTypeAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/associate/AssociateDataTypeAction.java
index 1dcad8d47d5..05651aa52d9 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/associate/AssociateDataTypeAction.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/associate/AssociateDataTypeAction.java
@@ -57,17 +57,33 @@ public AssociateDataTypeAction(DataTypeManagerPlugin plugin) {
 		super("Associate With Archive", plugin.getName());
 		this.plugin = plugin;
 
-		setPopupMenuData(new MenuData(new String[] { "Associate With Archive" }, null, "Sync"));
+		setPopupMenuData(new MenuData(new String[] { "Associate With Archive..." }, null, "Sync"));
 	}
 
 	@Override
 	public boolean isEnabledForContext(ActionContext context) {
 		// enable this action if any node is a non-built-in data type
-		return context instanceof DataTypesActionContext dtac &&
-			dtac.getSelectedNodes().stream().anyMatch(node -> {
-				return node instanceof DataTypeNode dtNode &&
-					!(dtNode.getDataType() instanceof BuiltInDataType);
-			});
+		if (!(context instanceof DataTypesActionContext dtac)) {
+			return false;
+		}
+		List<GTreeNode> dtNodes = getDataTypeNodes(dtac);
+		if (dtNodes.isEmpty()) {
+			return false;
+		}
+		Archive singleDTArchive = getSingleDTArchive(dtNodes);
+
+		// NOTE: We only support program-to-archive since other cases become rather complicated
+		// when considering dependencies that must get copied and how their associations shuold be 
+		// handled.
+		return singleDTArchive instanceof ProgramArchive;
+	}
+
+	private List<GTreeNode> getDataTypeNodes(DataTypesActionContext ctx) {
+		List<GTreeNode> allNodes = ctx.getSelectedNodes();
+		return allNodes.stream()
+				.filter(n -> (n instanceof DataTypeNode dtn &&
+					!(dtn.getDataType() instanceof BuiltInDataType)))
+				.collect(Collectors.toList());
 	}
 
 	private boolean isAlreadyAssociated(DataTypesActionContext dtContext) {
@@ -102,31 +118,28 @@ private static Archive findArchive(GTreeNode node) {
 		return null;
 	}
 
-	private List<Archive> getDestinationArchives() {
+	private List<Archive> getDestinationArchives(Archive excludedArchive) {
 
 		List<Archive> archives = plugin.getAllArchives();
-		List<Archive> sourceArchives = archives.stream()
+		List<Archive> destArchives = archives.stream()
 				.filter(a -> !(a instanceof ProgramArchive))
 				.filter(a -> !(a instanceof BuiltInArchive))
+				.filter(a -> !a.equals(excludedArchive))
 				.sorted((a1, a2) -> a1.getName().compareToIgnoreCase(a2.getName()))
 				.collect(Collectors.toList());
 
-		return sourceArchives;
+		return destArchives;
 	}
 
 	@Override
 	public void actionPerformed(ActionContext context) {
 
-		List<GTreeNode> allNodes = ((DataTypesActionContext) context).getSelectedNodes();
-		List<GTreeNode> dtNodes = allNodes.stream()
-				.filter(n -> n instanceof DataTypeNode)
-				.collect(Collectors.toList());
-
+		List<GTreeNode> dtNodes = getDataTypeNodes((DataTypesActionContext) context);
+		if (dtNodes.isEmpty()) {
+			return;
+		}
 		Archive dtArchive = getSingleDTArchive(dtNodes);
 		if (dtArchive == null) {
-			Msg.showInfo(this, getProviderComponent(), "Multiple Data Type Archives",
-				"The currently selected nodes are from multiple archives.\n" +
-					"Please select only nodes from a single archvie.");
 			return;
 		}
 
@@ -143,7 +156,7 @@ public void actionPerformed(ActionContext context) {
 			return;
 		}
 
-		List<Archive> archives = getDestinationArchives();
+		List<Archive> archives = getDestinationArchives(dtArchive);
 		if (archives.isEmpty()) {
 			Msg.showInfo(this, getProviderComponent(), "No Source Archives Open",
 				"No source archives open.  Please open the desired source archive.");
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
index e15c859bb0c..3d86e8836f5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java
@@ -132,6 +132,15 @@ public void run(TaskMonitor monitor) throws CancelledException {
 			}
 
 			if (needToCreateAssociation()) {
+
+				// Warning! (See GP-6367): association should not really be made before copy
+				// which may return an equivalent datatype with the same name and category path
+				// and a different UniversalID. This condition results in an ORPHANed association.
+
+				// NOTE: The resulting copied datatype may end up with a different name due to a
+				// conflict (same UniversalID).  This name difference will persist without apparent 
+				// impact to the association or anyway to know this is the case.
+
 				associateDataTypes(monitor);
 			}
 
@@ -367,7 +376,7 @@ private void copyDataType(Category toCategory, DataType dataType) {
 		DataTypeManager nodeDtm = dataType.getDataTypeManager();
 		boolean sameManager = (dtm == nodeDtm);
 
-		DataType newDt = !sameManager ? dataType.clone(nodeDtm) : dataType.copy(nodeDtm);
+		DataType newDt = !sameManager ? dataType : dataType.copy(nodeDtm);
 
 		if (!sameManager && toCategory.isRoot()) {
 			// preserve use of source category when copy to root
```
-----------------------------------
