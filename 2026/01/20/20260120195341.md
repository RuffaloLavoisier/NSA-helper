# Commit: 19024ceb2546c9ee040d1c9aae701f7974ece996
## Message: Merge remote-tracking branch 'origin/GP-6325_dev747368_golang_win_dll'
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
index 4eeba458ab6..1b8c95916f6 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java
@@ -351,22 +351,23 @@ private void fixGcWriteBarrierBatchFunctions() {
 		try {
 			ReturnParameterImpl retVal =
 				new ReturnParameterImpl(goTypes.getDTM().getPointer(null), program);
+			retVal.setName(retVal.getName(), SourceType.IMPORTED);
 
 			GoFuncData funcData = goBinary.getFunctionByName("gcWriteBarrier");
 			Function func = funcData != null ? funcData.getFunction() : null;
 			if (func != null) {
 				List<ParameterImpl> params = List.of(new ParameterImpl("numbytes",
-					goTypes.findDataType("uint"), program, SourceType.ANALYSIS));
+					goTypes.findDataType("uint"), program, SourceType.IMPORTED));
 
 				func.updateFunction(ccname, retVal, params,
-					FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.ANALYSIS);
+					FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
 			}
 			for (int i = 1; i <= 8; i++) {
 				funcData = goBinary.getFunctionByName("runtime.gcWriteBarrier" + i);
 				func = funcData != null ? funcData.getFunction() : null;
 				if (func != null) {
 					func.updateFunction(ccname, retVal, List.of(),
-						FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.ANALYSIS);
+						FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
 				}
 			}
 		}
@@ -386,15 +387,17 @@ private void fixGcWriteBarrierBufferedFunctions() {
 		try {
 			DataType voidPtr = goTypes.getDTM().getPointer(null);
 			ReturnParameterImpl retVal = new ReturnParameterImpl(VoidDataType.dataType, program);
+			retVal.setName(retVal.getName(), SourceType.IMPORTED);
+
 			List<ParameterImpl> params =
-				List.of(new ParameterImpl("value", voidPtr, program, SourceType.ANALYSIS),
-					new ParameterImpl("dest", voidPtr, program, SourceType.ANALYSIS));
+				List.of(new ParameterImpl("value", voidPtr, program, SourceType.IMPORTED),
+					new ParameterImpl("dest", voidPtr, program, SourceType.IMPORTED));
 
 			GoFuncData funcData = goBinary.getFunctionByName("runtime.gcWriteBarrier");
 			Function func = funcData != null ? funcData.getFunction() : null;
 			if (func != null) {
 				func.updateFunction(ccname, retVal, params,
-					FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.ANALYSIS);
+					FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
 			}
 
 			if (goBinary.getBuildInfo().getGOARCH(program).equals("amd64")) {
@@ -408,11 +411,11 @@ private void fixGcWriteBarrierBufferedFunctions() {
 					Register reg = lang.getRegister(gregName);
 					if (func != null && reg != null) {
 						params = List.of(
-							new ParameterImpl("value", voidPtr, reg, program, SourceType.ANALYSIS),
+							new ParameterImpl("value", voidPtr, reg, program, SourceType.IMPORTED),
 							new ParameterImpl("dest", voidPtr, destReg, program,
-								SourceType.ANALYSIS));
+								SourceType.IMPORTED));
 						func.updateFunction(ccname, retVal, params,
-							FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.ANALYSIS);
+							FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.IMPORTED);
 					}
 				}
 			}
@@ -451,7 +454,7 @@ private void fixDuffFunctions() {
 				ReturnParameterImpl voidRet = new ReturnParameterImpl(VoidDataType.dataType,
 					VariableStorage.VOID_STORAGE, program);
 				duffzeroFunc.updateFunction(GOLANG_DUFFZERO_CALLINGCONVENTION_NAME, voidRet,
-					duffzeroParams, FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.ANALYSIS);
+					duffzeroParams, FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.IMPORTED);
 
 				markupSession.appendComment(duffzeroFunc, null,
 					"Golang special function: duffzero");
@@ -474,7 +477,7 @@ private void fixDuffFunctions() {
 						new ParameterImpl("src", voidPtr, program));
 					duffcopyFunc.updateFunction(GOLANG_DUFFCOPY_CALLINGCONVENTION_NAME,
 						new ReturnParameterImpl(VoidDataType.dataType, program), params,
-						FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.ANALYSIS);
+						FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
 
 					markupSession.appendComment(duffcopyFunc, null,
 						"Golang special function: duffcopy");
@@ -636,13 +639,13 @@ public boolean applyTo(Program program, TaskMonitor monitor) {
 				}
 				try {
 					func.setName(duffFunc.getName() + "_" + func.getEntryPoint(),
-						SourceType.ANALYSIS);
+						SourceType.IMPORTED);
 					func.setParentNamespace(funcNS);
 					FunctionUpdateType fut =
 						duffFunc.hasCustomVariableStorage() ? FunctionUpdateType.CUSTOM_STORAGE
 								: FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS;
 					func.updateFunction(ccName, duffFunc.getReturn(),
-						Arrays.asList(duffFunc.getParameters()), fut, true, SourceType.ANALYSIS);
+						Arrays.asList(duffFunc.getParameters()), fut, true, SourceType.IMPORTED);
 					if (duffComment != null && !duffComment.isBlank()) {
 						new SetCommentCmd(func.getEntryPoint(), CommentType.PLATE, duffComment)
 								.applyTo(program);
@@ -969,10 +972,10 @@ private void fixupClosureFunc(GoFuncData funcData, Function func,
 				List<Variable> closureParams =
 					List.of(new ParameterImpl(GOLANG_CLOSURE_CONTEXT_NAME,
 						goBinary.getDTM().getPointer(closureStructDT), closureContextRegister,
-						program, SourceType.ANALYSIS));
+						program, SourceType.IMPORTED));
 
 				func.updateFunction(null, null, closureParams, FunctionUpdateType.CUSTOM_STORAGE,
-					true, SourceType.ANALYSIS);
+					true, SourceType.IMPORTED);
 
 				closureFuncsFixed++;
 			}
@@ -998,10 +1001,10 @@ private void fixupMethodWrapperClosureFunc(GoFuncData funcData, Function func,
 					List<Variable> closureParams =
 						List.of(new ParameterImpl(GOLANG_CLOSURE_CONTEXT_NAME,
 							goBinary.getDTM().getPointer(closureStructDT), closureContextRegister,
-							program, SourceType.ANALYSIS));
+							program, SourceType.IMPORTED));
 
 					func.updateFunction(null, null, closureParams,
-						FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.ANALYSIS);
+						FunctionUpdateType.CUSTOM_STORAGE, true, SourceType.IMPORTED);
 
 					methodWrapperFuncsFixed++;
 
@@ -1029,9 +1032,9 @@ private void fixupMethodWrapperClosureFunc(GoFuncData funcData, Function func,
 				Parameter[] methodParams = methodFunc.getParameters();
 				methodParams[0] = new ParameterImpl(GOLANG_CLOSURE_CONTEXT_NAME,
 					goBinary.getDTM().getPointer(closureStructDT), closureContextRegister, program,
-					SourceType.ANALYSIS);
+					SourceType.IMPORTED);
 				func.updateFunction(null, methodReturn, FunctionUpdateType.CUSTOM_STORAGE, true,
-					SourceType.ANALYSIS, methodParams);
+					SourceType.IMPORTED, methodParams);
 				methodWrapperFuncsFixed++;
 			}
 			catch (IOException | InvalidInputException | DuplicateNameException e) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoBuildInfo.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoBuildInfo.java
index 0205e6fc67c..5f6e79bdd8b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoBuildInfo.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoBuildInfo.java
@@ -18,7 +18,6 @@
 import static ghidra.app.util.bin.StructConverter.*;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.nio.charset.StandardCharsets;
 import java.util.*;
 
@@ -92,23 +91,59 @@ public static GoBuildInfo fromProgram(Program program) {
 	 */
 	public static ItemWithAddress<GoBuildInfo> findBuildInfo(Program program) {
 		ItemWithAddress<GoBuildInfo> wrappedItem = readItemFromSection(program,
-			GoRttiMapper.getFirstGoSection(program, SECTION_NAME, MACHO_SECTION_NAME));
+			GoRttiMapper.getFirstGoSection(program, SECTION_NAME, MACHO_SECTION_NAME), 0);
 		if (wrappedItem == null) {
 			// if not present, try common PE location for buildinfo
-			wrappedItem = readItemFromSection(program, GoRttiMapper.getGoSection(program, "data"));
+			MemoryBlock dataMB = GoRttiMapper.getGoSection(program, "data");
+			if (dataMB != null) {
+				MemoryByteProvider dataBP =
+					MemoryByteProvider.createMemoryBlockByteProvider(program.getMemory(), dataMB);
+				long offset = findGoBuildInfoOffset(dataBP, 512);
+				if (offset != -1) {
+					wrappedItem = readItemFromSection(program, dataMB, offset);
+				}
+			}
 		}
 		return wrappedItem;
 	}
 
+	/**
+	 * Searches for the offset of the GoBuildInfo magic string.
+	 * 
+	 * @param bp {@link ByteProvider} to search
+	 * @param maxSearchLength max number of bytes to search
+	 * @return offset of the magic string, or -1 if not found
+	 */
+	public static long findGoBuildInfoOffset(ByteProvider bp, int maxSearchLength) {
+		try {
+			long pos = 0;
+			while (pos < maxSearchLength && pos < bp.length()) {
+				byte b = bp.readByte(pos);
+				if (b == GO_BUILDINF_MAGIC[0]) {
+					byte[] bytes = bp.readBytes(pos, GO_BUILDINF_MAGIC.length);
+					if (Arrays.equals(GO_BUILDINF_MAGIC, bytes)) {
+						return pos;
+					}
+				}
+				pos++;
+			}
+		}
+		catch (IOException e) {
+			// fail, return -1
+		}
+		return -1;
+	}
+
 	private static ItemWithAddress<GoBuildInfo> readItemFromSection(Program program,
-			MemoryBlock memBlock) {
+			MemoryBlock memBlock, long offset) {
 		if (memBlock != null) {
 			try (ByteProvider bp =
 				MemoryByteProvider.createMemoryBlockByteProvider(program.getMemory(), memBlock)) {
 				BinaryReader br = new BinaryReader(bp, !program.getMemory().isBigEndian());
+				br.setPointerIndex(offset);
 
 				GoBuildInfo item = read(br, program);
-				return new ItemWithAddress<>(item, memBlock.getStart());
+				return new ItemWithAddress<>(item, memBlock.getStart().add(offset));
 			}
 			catch (IOException e) {
 				// fall thru, return null
@@ -126,6 +161,7 @@ private static ItemWithAddress<GoBuildInfo> readItemFromSection(Program program,
 	 * @throws IOException if error reading or bad data
 	 */
 	public static GoBuildInfo read(BinaryReader reader, Program program) throws IOException {
+		long startOffset = reader.getPointerIndex();
 		byte[] magicBytes = reader.readNextByteArray(GO_BUILDINF_MAGIC.length /* 14 */);
 		if (!Arrays.equals(magicBytes, GO_BUILDINF_MAGIC)) {
 			throw new IOException("Missing GoBuildInfo magic");
@@ -146,7 +182,7 @@ public static GoBuildInfo read(BinaryReader reader, Program program) throws IOEx
 		struct.add(BYTE, "ptrSize", null);
 		struct.add(BYTE, "flags", null);
 
-		return readStringInfo(reader, inlineStr, program, pointerSize, struct);
+		return readStringInfo(reader, startOffset, inlineStr, program, pointerSize, struct);
 	}
 
 	public static void setFallbackVersion(Program program, String fallbackGoVerStr) {
@@ -164,26 +200,6 @@ public static GoBuildInfo fromFallbackInfo(Program program) {
 			"unknown path", null, List.of(), List.of(), null);
 	}
 
-	/**
-	 * Probes the specified InputStream and returns true if it starts with a Go buildinfo magic
-	 * signature.
-	 * 
-	 * @param is InputStream
-	 * @return true if starts with buildinfo magic signature
-	 */
-	public static boolean isPresent(InputStream is) {
-		try {
-			byte[] buffer = new byte[GO_BUILDINF_MAGIC.length];
-			int bytesRead = is.read(buffer);
-			return bytesRead == GO_BUILDINF_MAGIC.length &&
-				Arrays.equals(buffer, GO_BUILDINF_MAGIC);
-		}
-		catch (IOException e) {
-			// fall thru
-		}
-		return false;
-	}
-
 	private final int pointerSize;
 	private final Endian endian;
 	private final String version;	// Go compiler version 
@@ -364,15 +380,16 @@ public String toString() {
 
 	//---------------------------------------------------------------------------------------------
 
-	private static GoBuildInfo readStringInfo(BinaryReader reader, boolean inlineStr,
-			Program program, int ptrSize, StructureDataType struct) throws IOException {
+	private static GoBuildInfo readStringInfo(BinaryReader reader, long startOffset,
+			boolean inlineStr, Program program, int ptrSize, StructureDataType struct)
+			throws IOException {
 
 		DataTypeManager dtm = program.getDataTypeManager();
 		String moduleString;
 		String versionString;
 
 		if (inlineStr) {
-			reader.setPointerIndex(32 /* static start of inline strings */);
+			reader.setPointerIndex(startOffset + 32 /* static start of inline strings */);
 
 			LEB128Info verStrLen = reader.readNext(LEB128Info::unsigned);
 			byte[] versionStringBytes = reader.readNextByteArray(verStrLen.asInt32());
@@ -398,7 +415,7 @@ private static GoBuildInfo readStringInfo(BinaryReader reader, boolean inlineStr
 			}
 		}
 		else {
-			reader.setPointerIndex(16 /* static start of 2 string pointers */);
+			reader.setPointerIndex(startOffset + 16 /* static start of 2 string pointers */);
 			long versionStrOffset = reader.readNextUnsignedValue(ptrSize);
 			long moduleStrOffset = reader.readNextUnsignedValue(ptrSize);
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoFunctionFixup.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoFunctionFixup.java
index f04a161da47..0174c25b8a1 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoFunctionFixup.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoFunctionFixup.java
@@ -257,8 +257,10 @@ private ReturnParameterImpl updateReturn(List<LocalVariable> returnResultAliasVa
 			return null;
 		}
 		if (DWARFUtil.isVoid(returnDT)) {
-			return new ReturnParameterImpl(VoidDataType.dataType, VariableStorage.VOID_STORAGE,
-				program);
+			ReturnParameterImpl result = new ReturnParameterImpl(VoidDataType.dataType,
+				VariableStorage.VOID_STORAGE, program);
+			result.setName(result.getName(), SourceType.IMPORTED);
+			return result;
 		}
 
 		GoFunctionMultiReturn multiReturn;
@@ -294,7 +296,9 @@ else if (DWARFUtil.isZeroByteDataType(returnDT)) {
 			return null;
 		}
 		VariableStorage varStorage = new VariableStorage(program, varnodes.toArray(Varnode[]::new));
-		return new ReturnParameterImpl(returnDT, varStorage, true, program);
+		ReturnParameterImpl result = new ReturnParameterImpl(returnDT, varStorage, true, program);
+		result.setName(result.getName(), SourceType.IMPORTED);
+		return result;
 	}
 
 	private void allocateReturnStorage(String name_unused, DataType dt, List<Varnode> varnodes,
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoRegisterInfo.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoRegisterInfo.java
index 12cfd92364b..923944ee855 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoRegisterInfo.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/GoRegisterInfo.java
@@ -123,7 +123,7 @@ public List<Variable> getDuffzeroParams(Program program) {
 
 			params.add(new ParameterImpl("dest", Parameter.UNASSIGNED_ORDINAL, voidPtr,
 				getStorageForReg(program, duffzeroDestParam, voidPtr.getLength()), true, program,
-				SourceType.ANALYSIS));
+				SourceType.IMPORTED));
 			if (duffzeroZeroParam != null && duffzeroZeroParamType != null) {
 				int regSize = duffzeroZeroParam.getMinimumByteSize();
 				DataType dt = switch (duffzeroZeroParamType) {
@@ -132,7 +132,7 @@ public List<Variable> getDuffzeroParams(Program program) {
 				};
 				params.add(new ParameterImpl("zeroValue", Parameter.UNASSIGNED_ORDINAL, dt,
 					getStorageForReg(program, duffzeroZeroParam, regSize), true, program,
-					SourceType.ANALYSIS));
+					SourceType.IMPORTED));
 			}
 
 			return params;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/SectionHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/SectionHeader.java
index beffe42475c..85e348c14e7 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/SectionHeader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/SectionHeader.java
@@ -489,6 +489,15 @@ public InputStream getDataStream() throws IOException {
 		return reader.getByteProvider().getInputStream(getPointerToRawData());
 	}
 
+	/**
+	 * Returns a ByteProvider to underlying bytes of this section.
+	 * @return a ByteProvider to underlying bytes of this section
+	 */
+	public ByteProvider getDataByteProvider()  {
+		return new ByteProviderWrapper(reader.getByteProvider(), getPointerToRawData(),
+			getSizeOfRawData());
+	}
+
 	/**
 	 * @see java.lang.Object#toString()
 	 */
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java
index 0f1de137df7..0e956f782bf 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java
@@ -1160,8 +1160,8 @@ private static boolean isGolang(PortableExecutable pe, ByteProvider provider) {
 
 			SectionHeader dataSection = pe.getNTHeader().getFileHeader().getSectionHeader(".data");
 			if (dataSection != null) {
-				try (InputStream is = dataSection.getDataStream()) {
-					buildInfoPresent = GoBuildInfo.isPresent(is);
+				try (ByteProvider bp = dataSection.getDataByteProvider()) {
+					buildInfoPresent = GoBuildInfo.findGoBuildInfoOffset(bp, 512) != -1;
 				}
 				catch (IOException e) {
 					// fail
```
-----------------------------------
