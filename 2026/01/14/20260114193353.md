# Commit: 7828f235d315807d18ecb873fad34b209a02ce65
## Message: GP-6316 Increase maximum temporary size for SLEIGH to 256 bytes
## Diff:
```
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
index 82cd8bcb7fc..26805d642e3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
@@ -17,7 +17,7 @@
 
 namespace ghidra {
 
-const uint4 SleighBase::MAX_UNIQUE_SIZE = 128;
+const uint4 SleighBase::MAX_UNIQUE_SIZE = 256;
 
 int4 SourceFileIndexer::index(const string filename){
 	auto it = fileToIndex.find(filename);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index d5ca7302c04..1c94fd9b10e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -256,7 +256,7 @@ void ConsistencyChecker::OptimizeRecord::updateCombine(ConsistencyChecker::Optim
 /// \param un is \b true to request "Unnecessary extension" warnings
 /// \param warndead is \b true to request warnings for written but not read temporaries
 /// \param warnlargetemp is \b true to request warnings for temporaries that are too large
-ConsistencyChecker::ConsistencyChecker(SleighCompile *sleigh,SubtableSymbol *rt,bool un,bool warndead, bool warnlargetemp)
+ConsistencyChecker::ConsistencyChecker(SleighCompile *sleigh,SubtableSymbol *rt,bool un,bool warndead)
 
 {
   compiler = sleigh;
@@ -264,10 +264,8 @@ ConsistencyChecker::ConsistencyChecker(SleighCompile *sleigh,SubtableSymbol *rt,
   unnecessarypcode = 0;
   readnowrite = 0;
   writenoread = 0;
-  largetemp = 0;        ///<Number of constructors using at least one temporary varnode larger than SleighBase::MAX_UNIQUE_SIZE
   printextwarning = un;
   printdeadwarning = warndead;
-  printlargetempwarning = warnlargetemp; ///< If true, prints a warning about each constructor using a temporary varnode larger than SleighBase::MAX_UNIQUE_SIZE
 }
 
 /// \brief Recover a specific value for the size associated with a Varnode template
@@ -1632,12 +1630,9 @@ void ConsistencyChecker::checkLargeTemporaries(Constructor *ct,ConstructTpl *ctp
   vector<OpTpl*> ops = ctpl->getOpvec();
   for(vector<OpTpl*>::iterator iter = ops.begin();iter != ops.end();++iter) {
     if (hasLargeTemporary(*iter)) {
-      if (printlargetempwarning) {
-	compiler->reportWarning(
-	    compiler->getLocation(ct),
-	    "Constructor uses temporary varnode larger than " + to_string(SleighBase::MAX_UNIQUE_SIZE) + " bytes.");
-      }
-      largetemp++;
+      compiler->reportError(
+	  compiler->getLocation(ct),
+	  "Constructor uses temporary varnode larger than " + to_string(SleighBase::MAX_UNIQUE_SIZE) + " bytes.");
       return;
     }
   }
@@ -1959,7 +1954,6 @@ SleighCompile::SleighCompile(void)
   warnunnecessarypcode = false;
   warndeadtemps = false;
   lenientconflicterrors = true;
-  largetemporarywarning = false;
   warnalllocalcollisions = false;
   warnallnops = false;
   failinsensitivedups = true;
@@ -2141,7 +2135,7 @@ void SleighCompile::buildPatterns(void)
 void SleighCompile::checkConsistency(void)
 
 {
-  ConsistencyChecker checker(this, root,warnunnecessarypcode,warndeadtemps,largetemporarywarning);
+  ConsistencyChecker checker(this, root,warnunnecessarypcode,warndeadtemps);
 
   if (!checker.testSizeRestrictions()) {
     errors += 1;
@@ -2171,14 +2165,6 @@ void SleighCompile::checkConsistency(void)
     reportWarning("Use -t switch to list each individually");
   }
   checker.testLargeTemporary();
-  if ((!largetemporarywarning) && (checker.getNumLargeTemporaries() > 0)) {
-	ostringstream msg;
-	msg << dec << checker.getNumLargeTemporaries();
-	msg << " constructors contain temporaries larger than ";
-	msg << SleighBase::MAX_UNIQUE_SIZE << " bytes";
-	reportWarning(msg.str());
-	reportWarning("Use -o switch to list each individually.");
-  }
 }
 
 /// \brief Search for offset matches between a previous set and the given current set
@@ -3882,13 +3868,12 @@ static void findSlaSpecs(vector<string> &res, const string &dir, const string &s
 /// \param allNopWarning is \b true for individual warnings about NOP constructors
 /// \param deadTempWarning is \b true for individual warnings about dead temporary varnodes
 /// \param enforceLocalKeyWord is \b true to force all local variable definitions to use the \b local keyword
-/// \param largeTemporaryWarning is \b true for individual warnings about temporary varnodes that are too large
 /// \param caseSensitiveRegisterNames is \b true if register names are allowed to be case sensitive
 /// \param debugOutput is \b true if the output file is written using the debug (XML) form of the .sla format
 void SleighCompile::setAllOptions(const map<string,string> &defines, bool unnecessaryPcodeWarning,
 				  bool lenientConflict, bool allCollisionWarning,
 				  bool allNopWarning,bool deadTempWarning,bool enforceLocalKeyWord,
-				  bool largeTemporaryWarning, bool caseSensitiveRegisterNames,bool debugOutput)
+				  bool caseSensitiveRegisterNames,bool debugOutput)
 {
   map<string,string>::const_iterator iter = defines.begin();
   for (iter = defines.begin(); iter != defines.end(); iter++) {
@@ -3900,7 +3885,6 @@ void SleighCompile::setAllOptions(const map<string,string> &defines, bool unnece
   setAllNopWarning( allNopWarning );
   setDeadTempWarning(deadTempWarning);
   setEnforceLocalKeyWord(enforceLocalKeyWord);
-  setLargeTemporaryWarning(largeTemporaryWarning);
   setInsensitiveDuplicateError(!caseSensitiveRegisterNames);
   setDebugOutput(debugOutput);
 }
@@ -3935,7 +3919,6 @@ int main(int argc,char **argv)
     cerr << "   -t              print warnings for dead temporaries" << endl;
     cerr << "   -e              enforce use of 'local' keyword for temporaries" << endl;
     cerr << "   -c              print warnings for all constructors with colliding operands" << endl;
-    cerr << "   -o              print warnings for temporaries which are too large" << endl;
     cerr << "   -s              treat register names as case sensitive" << endl;
     cerr << "   -DNAME=VALUE    defines a preprocessor macro NAME with value VALUE" << endl;
     exit(2);
@@ -3950,7 +3933,6 @@ int main(int argc,char **argv)
   bool allNopWarning = false;
   bool deadTempWarning = false;
   bool enforceLocalKeyWord = false;
-  bool largeTemporaryWarning = false;
   bool caseSensitiveRegisterNames = false;
   bool debugOutput = false;
   
@@ -3984,8 +3966,6 @@ int main(int argc,char **argv)
       deadTempWarning = true;
     else if (argv[i][1] == 'e')
       enforceLocalKeyWord = true;
-    else if (argv[i][1] == 'o')
-      largeTemporaryWarning = true;
     else if (argv[i][1] == 's')
       caseSensitiveRegisterNames = true;
     else if (argv[i][1] == 'y')
@@ -4021,8 +4001,7 @@ int main(int argc,char **argv)
       sla.replace(slaspec.length() - slaspecExtLen, slaspecExtLen, SLAEXT);
       SleighCompile compiler;
       compiler.setAllOptions(defines, unnecessaryPcodeWarning, lenientConflict, allCollisionWarning, allNopWarning,
-			     deadTempWarning, enforceLocalKeyWord,largeTemporaryWarning, caseSensitiveRegisterNames,
-			     debugOutput);
+			     deadTempWarning, enforceLocalKeyWord, caseSensitiveRegisterNames, debugOutput);
       retval = compiler.run_compilation(slaspec,sla);
       if (retval != 0) {
 	return retval; // stop on first error
@@ -4058,8 +4037,7 @@ int main(int argc,char **argv)
     
     SleighCompile compiler;
     compiler.setAllOptions(defines, unnecessaryPcodeWarning, lenientConflict, allCollisionWarning, allNopWarning,
-			   deadTempWarning, enforceLocalKeyWord,largeTemporaryWarning,caseSensitiveRegisterNames,
-			   debugOutput);
+			   deadTempWarning, enforceLocalKeyWord,caseSensitiveRegisterNames,debugOutput);
     
     if (i < argc - 1) {
       string fileoutExamine(argv[i+1]);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
index 4f55bea0b80..128d847a796 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
@@ -188,10 +188,8 @@ private:
   int4 unnecessarypcode;	///< Count of unnecessary extension/truncation operations
   int4 readnowrite;		///< Count of temporary registers that are read but not written
   int4 writenoread;		///< Count of temporary registers that are written but not read
-  int4 largetemp;		///< Count of temporary registers that are too large
   bool printextwarning;		///< Set to \b true if warning emitted for each unnecessary truncation/extension
   bool printdeadwarning;	///< Set to \b true if warning emitted for each written but not read temporary
-  bool printlargetempwarning;	///< Set to \b true if warning emitted for each too large temporary
   SubtableSymbol *root_symbol;	///< The root symbol table for the parsed SLEIGH file
   vector<SubtableSymbol *> postorder;	///< Subtables sorted into \e post order (dependent tables listed earlier)
   map<SubtableSymbol *,int4> sizemap;	///< Sizes associated with table \e exports
@@ -223,7 +221,7 @@ private:
   void checkLargeTemporaries(Constructor *ct,ConstructTpl *ctpl);
   void optimize(Constructor *ct);
 public:
-  ConsistencyChecker(SleighCompile *sleigh, SubtableSymbol *rt,bool unnecessary,bool warndead, bool warnlargetemp);
+  ConsistencyChecker(SleighCompile *sleigh, SubtableSymbol *rt,bool unnecessary,bool warndead);
   bool testSizeRestrictions(void);		///< Test size consistency of all p-code
   bool testTruncations(void);			///< Test truncation validity of all p-code
   void testLargeTemporary(void);		///< Test for temporary Varnodes that are too large
@@ -231,7 +229,6 @@ public:
   int4 getNumUnnecessaryPcode(void) const { return unnecessarypcode; }	///< Return the number of unnecessary extensions and truncations
   int4 getNumReadNoWrite(void) const { return readnowrite; }	///< Return the number of temporaries read but not written
   int4 getNumWriteNoRead(void) const { return writenoread; }	///< Return the number of temporaries written but not read
-  int4 getNumLargeTemporaries(void) const {return largetemp;}	///< Return the number of \e too large temporaries
 };
 
 /// \brief Helper function holding properties of a \e context field prior to calculating the context layout
@@ -325,7 +322,6 @@ private:
   bool warnunnecessarypcode;		///< \b true if we warn of unnecessary ZEXT or SEXT
   bool warndeadtemps;			///< \b true if we warn of temporaries that are written but not read
   bool lenientconflicterrors;		///< \b true if we ignore most pattern conflict errors
-  bool largetemporarywarning;   	///< \b true if we warn about temporaries larger than SleighBase::MAX_UNIQUE_SIZE
   bool warnalllocalcollisions;		///< \b true if local export collisions generate individual warnings
   bool warnallnops;			///< \b true if pcode NOPs generate individual warnings
   bool failinsensitivedups;		///< \b true if case insensitive register duplicates cause error
@@ -388,11 +384,6 @@ public:
   /// \param val is \b true if the \b local keyword must always be used. The default is \b false.
   void setEnforceLocalKeyWord(bool val) { pcode.setEnforceLocalKey(val); }
 
-  /// \brief Set whether too large temporary registers generate warnings individually
-  ///
-  /// \param val is \b true if warnings are generated individually.  The default is \b false.
-  void setLargeTemporaryWarning (bool val) {largetemporarywarning = val;}
-
   /// \brief Set whether indistinguishable Constructor patterns generate fatal errors
   ///
   /// \param val is \b true if no error is generated.  The default is \b true.
@@ -484,7 +475,7 @@ public:
   void setAllOptions(const map<string,string> &defines, bool unnecessaryPcodeWarning,
 		     bool lenientConflict, bool allCollisionWarning,
 		     bool allNopWarning,bool deadTempWarning,bool enforceLocalKeyWord,
-		     bool largeTemporaryWarning, bool caseSensitiveRegisterNames,bool debugOutput);
+		     bool caseSensitiveRegisterNames,bool debugOutput);
   int4 run_compilation(const string &filein,const string &fileout);
 };
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/sleighbase/SleighBase.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/sleighbase/SleighBase.java
index 5223f6a466c..0273875dbb6 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/sleighbase/SleighBase.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/sleighbase/SleighBase.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,7 +37,7 @@ public abstract class SleighBase extends Translate implements NamedSymbolProvide
 	 * Note: The value of {@link #MAX_UNIQUE_SIZE}  must match the corresponding value
 	 * defined by sleighbase.cc
 	 */
-	public static final long MAX_UNIQUE_SIZE = 128;  //Maximum size of a varnode in the unique space.  
+	public static final long MAX_UNIQUE_SIZE = 256;  //Maximum size of a varnode in the unique space.  
 													//Should match value in sleighbase.cc
 
 	private VectorSTL<String> userop = new VectorSTL<>();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java
index dfad7abd0ef..baee4e47305 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java
@@ -35,10 +35,8 @@ class ConsistencyChecker {
 	private int readnowrite;
 	private int writenoread;
 
-	private int largetemp;			// number of constructors using a temporary varnode larger than SleighBase.MAX_UNIQUE_SIZE
 	private boolean printextwarning;
 	private boolean printdeadwarning;
-	private boolean printlargetempwarning;	// if true, warning about temporary varnodes larger than SleighBase.MAX_UNIQUE_SIZE 
 	private SleighCompile compiler;
 	private SubtableSymbol root_symbol;
 	private List<SubtableSymbol> postorder = new ArrayList<>();
@@ -1261,12 +1259,9 @@ private void checkLargeTemporaries(Constructor ct, ConstructTpl ctpl) {
 		VectorSTL<OpTpl> ops = ctpl.getOpvec();
 		for (IteratorSTL<OpTpl> iter = ops.begin(); !iter.isEnd(); iter.increment()) {
 			if (hasLargeTemporary(iter.get())) {
-				if (printlargetempwarning) {
-					compiler.reportWarning(ct.location,
-						"Constructor uses temporary varnode larger than " +
-							SleighBase.MAX_UNIQUE_SIZE + " bytes.");
-				}
-				largetemp++;
+				compiler.reportError(ct.location,
+					"Constructor uses temporary varnode larger than " +
+						SleighBase.MAX_UNIQUE_SIZE + " bytes.");
 				return;
 			}
 		}
@@ -1298,12 +1293,8 @@ public ConsistencyChecker(SleighCompile cp, SubtableSymbol rt, boolean unnecessa
 		unnecessarypcode = 0;
 		readnowrite = 0;
 		writenoread = 0;
-		//number of constructors which reference a temporary varnode larger than SleighBase.MAX_UNIQUE_SIZE
-		largetemp = 0;
 		printextwarning = unnecessary;
 		printdeadwarning = warndead;
-		//whether to print information about constructors which reference large temporary varnodes
-		printlargetempwarning = warnlargetemp;
 	}
 
 	// Main entry point for size consistency check
@@ -1401,14 +1392,4 @@ public int getNumReadNoWrite() {
 	public int getNumWriteNoRead() {
 		return writenoread;
 	}
-
-	/**
-	 * Returns the number of constructors which reference a varnode in the unique space with size
-	 * larger than {@link SleighBase#MAX_UNIQUE_SIZE}.
-	 * 
-	 * @return num constructors with large temp varnodes
-	 */
-	public int getNumLargeTemporaries() {
-		return largetemp;
-	}
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
index 332f70e6ca8..cbd58674bf4 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
@@ -534,13 +534,6 @@ private void checkConsistency() {
 			reportWarning(null, "Use -t switch to list each individually");
 		}
 		checker.testLargeTemporary();
-		if ((!largetemporarywarning) && checker.getNumLargeTemporaries() > 0) {
-			reportWarning(null,
-				checker.getNumLargeTemporaries() +
-					" constructors contain temporaries larger than " + SleighBase.MAX_UNIQUE_SIZE +
-					" bytes.");
-			reportWarning(null, "Use -o switch to list each individually.");
-		}
 	}
 
 	private static int findCollision(Map<Long, Integer> local2Operand, ArrayList<Long> locals,
@@ -776,17 +769,6 @@ public void setEnforceLocalKeyWord(boolean val) {
 		pcode.setEnforceLocalKey(val);
 	}
 
-	/**
-	 * Sets whether or not to print out warning info about
-	 * {@link Constructor}s which reference varnodes in the
-	 * unique space larger than {@link SleighBase#MAX_UNIQUE_SIZE}.
-	 * @param val whether to print info about contructors using large varnodes
-	 */
-	public void setLargeTemporaryWarning(boolean val) {
-		entry("setLargeTemporaryWarning", val);
-		largetemporarywarning = val;
-	}
-
 	public void setLenientConflict(boolean val) {
 		entry("setLenientConflict", val);
 		lenientconflicterrors = val;
@@ -1794,8 +1776,7 @@ public int printAssembly(PrintStream s, int size, Address baseaddr) {
 	public void setAllOptions(Map<String, String> preprocs, boolean unnecessaryPcodeWarning,
 			boolean lenientConflict, boolean allCollisionWarning, boolean allNopWarning,
 			boolean deadTempWarning, boolean unusedFieldWarning, boolean enforceLocalKeyWord,
-			boolean largeTemporaryWarning, boolean caseSensitiveRegisterNames,
-			boolean debugOutput) {
+			boolean caseSensitiveRegisterNames, boolean debugOutput) {
 		Set<Entry<String, String>> entrySet = preprocs.entrySet();
 		for (Entry<String, String> entry : entrySet) {
 			setPreprocValue(entry.getKey(), entry.getValue());
@@ -1807,7 +1788,6 @@ public void setAllOptions(Map<String, String> preprocs, boolean unnecessaryPcode
 		setDeadTempWarning(deadTempWarning);
 		setUnusedFieldWarning(unusedFieldWarning);
 		setEnforceLocalKeyWord(enforceLocalKeyWord);
-		setLargeTemporaryWarning(largeTemporaryWarning);
 		setInsensitiveDuplicateError(!caseSensitiveRegisterNames);
 		setDebugOutput(debugOutput);
 	}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
index 7b847279416..be52d69c536 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -86,7 +86,6 @@ public static int runMain(String[] args) throws IOException, RecognitionExceptio
 			Msg.info(SleighCompile.class, "   -e                enforce use of 'local' keyword for temporaries");
 			Msg.info(SleighCompile.class, "   -c                print warnings for all constructors with colliding operands");
 			Msg.info(SleighCompile.class, "   -f                print warnings for unused token fields");
-			Msg.info(SleighCompile.class, "   -o                print warnings for temporaries which are too large");
 			Msg.info(SleighCompile.class,  "  -s                treat register names as case sensitive");
 			Msg.info(SleighCompile.class, "   -DNAME=VALUE      defines a preprocessor macro NAME with value VALUE (option may be repeated)");
 			Msg.info(SleighCompile.class, "   -dMODULE          defines a preprocessor macro MODULE with a value of its module path (option may be repeated)");
@@ -102,7 +101,6 @@ public static int runMain(String[] args) throws IOException, RecognitionExceptio
 		boolean deadTempWarning = false;
 		boolean enforceLocalKeyWord = false;
 		boolean unusedFieldWarning = false;
-		boolean largeTemporaryWarning = false;
 		boolean caseSensitiveRegisterNames = false;
 		boolean debugOutput = false;
 
@@ -165,9 +163,6 @@ else if (args[i].charAt(1) == 'n') {
 			else if (args[i].charAt(1) == 'a') {
 				allMode = true;
 			}
-			else if (args[i].charAt(1) == 'o') {
-				largeTemporaryWarning = true;
-			}
 			else if (args[i].charAt(1) == 's') {
 				caseSensitiveRegisterNames = true;
 			}
@@ -208,7 +203,7 @@ else if (args[i].charAt(1) == 'x') {
 				SleighCompile compiler = new SleighCompile();
 				compiler.setAllOptions(preprocs, unnecessaryPcodeWarning, lenientConflict,
 					allCollisionWarning, allNopWarning, deadTempWarning, unusedFieldWarning,
-					enforceLocalKeyWord, largeTemporaryWarning, caseSensitiveRegisterNames,
+					enforceLocalKeyWord, caseSensitiveRegisterNames,
 					debugOutput);
 
 				String outname = input.getName().replace(".slaspec", ".sla");
@@ -238,7 +233,7 @@ else if (args[i].charAt(1) == 'x') {
 		SleighCompile compiler = new SleighCompile();
 		compiler.setAllOptions(preprocs, unnecessaryPcodeWarning, lenientConflict,
 			allCollisionWarning, allNopWarning, deadTempWarning, unusedFieldWarning,
-			enforceLocalKeyWord, largeTemporaryWarning, caseSensitiveRegisterNames, debugOutput);
+			enforceLocalKeyWord, caseSensitiveRegisterNames, debugOutput);
 		if (i == args.length) {
 			Msg.error(SleighCompile.class, "Missing input file name");
 			return 1;
```
-----------------------------------
