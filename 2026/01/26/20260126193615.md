# Commit: f4080a7771625d7c9557d15bed406c8455bf1cd6
## Message: Merge remote-tracking branch 'origin/GP-5936_dev747368_register_varnode_displayfield'
## Diff:
```
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/model/listing/CodeUnitFormat.java b/Ghidra/Features/Base/src/main/java/ghidra/program/model/listing/CodeUnitFormat.java
index f87acc065cd..b5bdf462df5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/program/model/listing/CodeUnitFormat.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/model/listing/CodeUnitFormat.java
@@ -322,13 +322,14 @@ private boolean performRegisterMarkup(Instruction instr, int opIndex, Function f
 			}
 			else if (options.includeInferredVariableMarkup) {
 				boolean isRead = isRead(reg, instr);
+				boolean operandIsOnlyReg = instr.getRegister(opIndex) != null;
 				Variable regVar = program.getFunctionManager()
 						.getReferencedVariable(instr.getMinAddress(), reg.getAddress(),
 							reg.getMinimumByteSize(), isRead);
 				if (regVar != null) {
 					// TODO: If register appears more than once, how can we distinguish read vs. write occurrence in operands
 					if (isRead && isWritten(reg, instr) && !hasRegisterWriteReference(instr, reg) &&
-						instr.getRegister(opIndex) != null) {
+						operandIsOnlyReg) {
 						// If register both read and written and there are no write references for this instruction
 						// see if there is only one reference to choose from - if not we can't determine how to markup
 						Variable regWriteVar = program.getFunctionManager()
@@ -341,8 +342,13 @@ else if (options.includeInferredVariableMarkup) {
 
 					// if can't get just a register out of it, assume indirection for the VariableOffset
 					long offset = 0;
-					varOff = new VariableOffset(regVar, offset, instr.getRegister(opIndex) == null,
-						true);
+					if (operandIsOnlyReg) {
+						offset = regVar.getVariableStorage().getRegisterOffset(reg);
+						if (offset < 0) {
+							offset = 0; // failed?
+						}
+					}
+					varOff = new VariableOffset(regVar, offset, !operandIsOnlyReg, true);
 				}
 			}
 			if (varOff != null) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableOffset.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableOffset.java
index 04cd0cdc333..3dc6a446d06 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableOffset.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableOffset.java
@@ -124,7 +124,7 @@ public String getDataTypeDisplayText() {
 	private List<Object> getObjects(boolean showScalarAdjustment) {
 
 		DataType dt = variable.getDataType();
-		StringBuffer name = new StringBuffer(variable.getName());
+		StringBuilder name = new StringBuilder(variable.getName());
 
 		long scalarAdjustment = 0;
 		if (showScalarAdjustment && (replacedElement instanceof Scalar)) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java
index 94ab195608d..ffcfe9cb686 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java
@@ -495,6 +495,43 @@ public List<Register> getRegisters() {
 		return registers;
 	}
 
+	/**
+	 * Returns the offset of the specified register, in the varnode storage, based on the
+	 * endianness of the storage.  If the searched-for register is a sub-register of a storage
+	 * location, it will be found and its offset inside the containing register will be included.
+	 * 
+	 * @param reg {@link Register} to search for
+	 * @return offset of specified register, or -1 if not found
+	 */
+	public long getRegisterOffset(Register reg) {
+		Address regAddrMin = reg.getAddress();
+		Address regAddrMax = regAddrMin.add(reg.getMinimumByteSize() - 1);
+		long offset = 0;
+		if (programArch.getLanguage().isBigEndian()) {
+			for (int i = 0; i < varnodes.length; i++) {
+				Varnode varnode = varnodes[i];
+				if (varnode.isRegister() && varnode.contains(regAddrMin) &&
+					varnode.contains(regAddrMax)) {
+					return offset + (regAddrMin.subtract(varnode.getAddress()));
+				}
+				offset += varnode.getSize();
+			}
+		}
+		else {
+			for (int i = varnodes.length - 1; i >= 0; i--) {
+				Varnode varnode = varnodes[i];
+				if (varnode.isRegister() && varnode.contains(regAddrMin) &&
+					varnode.contains(regAddrMax)) {
+					long varnodeEndOffset =
+						varnode.getAddress().getOffset() + (varnode.getSize() - 1);
+					return offset + (varnodeEndOffset - regAddrMax.getOffset());
+				}
+				offset += varnode.getSize();
+			}
+		}
+		return -1;
+	}
+
 	/**
 	 * @return the stack offset associated with simple stack storage or compound 
 	 * storage where the last varnode is stack, see {@link #hasStackStorage()}. 
```
-----------------------------------
